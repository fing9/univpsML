내용링크,title,problem,level,분류,유사도,number
/problem/24479,알고리즘 수업 - 깊이 우선 탐색 1,"오늘도 서준이는 깊이 우선 탐색(DFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 깊이 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 오름차순으로 방문한다.dfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를 오름차순으로 방문한다)        if (visited[x] = NO) then dfs(V, E, x);}첫째 줄부터 N개의 줄에 정수를 한 개씩 출력한다. i번째 줄에는 정점 i의 방문 순서를 출력한다. 시작 정점의 방문 순서는 1이다. 시작 정점에서 방문할 수 없는 경우 0을 출력한다.",9.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,정렬,",기준,24479
/problem/24484,알고리즘 수업 - 깊이 우선 탐색 6,"오늘도 서준이는 깊이 우선 탐색(DFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 깊이 우선 탐색으로 만들어 지는 트리를 깊이 우선 탐색 트리라고 하자. 깊이 우선 탐색 트리에 있는 i번 노드의 깊이(depth)를 di라고 하자. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1이다. 정점 R에서 시작하여 깊이 우선 탐색으로 노드를 방문할 경우 i번 노드의 방문 순서를 ti라고 하자. 시작 정점의 방문 순서는 1이고 시작 정점에서 방문할 수 없는 노드는 0이다. 모든 노드에 대한 di × ti 값의 합을 구해보자.깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 내림차순으로 방문한다.dfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를 내림차순으로 방문한다)        if (visited[x] = NO) then dfs(V, E, x);}첫째 줄에 모든 노드에 대한 di × ti 값의 합을 출력한다.",9.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,정렬,",2.0,24484
/problem/24481,알고리즘 수업 - 깊이 우선 탐색 3,"오늘도 서준이는 깊이 우선 탐색(DFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 깊이 우선 탐색으로 만들어 지는 트리를 깊이 우선 탐색 트리라고 하자. 깊이 우선 탐색 트리에 있는 모든 노드의 깊이(depth)를 출력하자. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1로 출력하자.깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 오름차순으로 방문한다.dfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를 오름차순으로 방문한다)        if (visited[x] = NO) then dfs(V, E, x);}첫째 줄부터 N개의 줄에 정수를 한 개씩 출력한다. i번째 줄에는 정점 i의 깊이를 출력한다. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1로 출력하자.",9.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,정렬,",2.0,24481
/problem/24483,알고리즘 수업 - 깊이 우선 탐색 5,"오늘도 서준이는 깊이 우선 탐색(DFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 깊이 우선 탐색으로 만들어 지는 트리를 깊이 우선 탐색 트리라고 하자. 깊이 우선 탐색 트리에 있는 i번 노드의 깊이(depth)를 di라고 하자. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1이다. 정점 R에서 시작하여 깊이 우선 탐색으로 노드를 방문할 경우 i번 노드의 방문 순서를 ti라고 하자. 시작 정점의 방문 순서는 1이고 시작 정점에서 방문할 수 없는 노드는 0이다. 모든 노드에 대한 di × ti 값의 합을 구해보자.깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 오름차순으로 방문한다.dfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를 오름차순으로 방문한다)        if (visited[x] = NO) then dfs(V, E, x);}첫째 줄에 모든 노드에 대한 di × ti 값의 합을 출력한다.",9.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,정렬,",2.0,24483
/problem/24482,알고리즘 수업 - 깊이 우선 탐색 4,"오늘도 서준이는 깊이 우선 탐색(DFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 깊이 우선 탐색으로 만들어 지는 트리를 깊이 우선 탐색 트리라고 하자. 깊이 우선 탐색 트리에 있는 모든 노드의 깊이(depth)를 출력하자. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1로 출력하자.깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 내림차순으로 방문한다.dfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를 내림차순으로 방문한다)        if (visited[x] = NO) then dfs(V, E, x);}첫째 줄부터 N개의 줄에 정수를 한 개씩 출력한다. i번째 줄에는 정점 i의 깊이를 출력한다. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1로 출력하자.",9.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,정렬,",2.0,24482
/problem/24480,알고리즘 수업 - 깊이 우선 탐색 2,"오늘도 서준이는 깊이 우선 탐색(DFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 깊이 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.깊이 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 내림차순으로 방문한다.dfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.    for each x ∈ E(R)  # E(R) : 정점 R의 인접 정점 집합.(정점 번호를 내림차순으로 방문한다)        if (visited[x] = NO) then dfs(V, E, x);}첫째 줄부터 N개의 줄에 정수를 한 개씩 출력한다. i번째 줄에는 정점 i의 방문 순서를 출력한다. 시작 정점의 방문 순서는 1이다. 시작 정점에서 방문할 수 없는 경우 0을 출력한다.",9.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,정렬,",2.0,24480
/problem/2379,트리 탐색하기,"n개의 정점으로 이루어진 트리가 있다. 이와 같은 트리를 DFS와 비슷한 방식으로 탐색하려 한다. 탐색을 시작할 때에는 트리의 한 정점에서 시작하여, 한 번도 지나지 않은 간선을 따라서 다음 정점으로 이동한다. 이때 한 번도 지나지 않은 간선이 여러 개 존재한다면 그 중 하나를 임의로 선택한다. 만약 한 번도 지나지 않은 간선이 존재하지 않는다면, 전 단계로 돌아간다. 이와 같은 과정을 반복하면 모든 간선을 두 번씩 지나게 된다.이와 같은 탐색을 할 때, 시작 정점에서 멀어질 때 0을, 시작 정점에 가까워 질 때 1을 적으면 경로를 얻을 수 있다. 하지만 이와 같은 경로 저장 방식을 사용하면, 같은 트리라 하더라도 여러 개의 경로로 저장될 수 있다.예를 들어 위와 같은 트리를 살펴보면, 0010011101001011, 0100011011001011, 0100101100100111 등의 경로로 탐색될 수 있다. 탐색 시작 정점은 그림에서 크게 표시된 정점이다.트리를 탐색한 경로가 두 개 주어졌을 때, 이 경로들이 같은 트리를 탐색한 것인지 알아내는 프로그램을 작성하시오.입력 데이터 순서대로 T개의 줄에 출력을 하는데, 만약 같은 트리라면 1을, 다른 트리라면 0을 출력한다.",17.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,정렬,트리,",1.7783282309029462,2379
/problem/16217,옥토끼나라,"옥토끼나라는 N개의 섬들과 섬들을 연결하는 M개의 다리들로 이루어진, 달에서 이주해 온 토끼들이 사는 자그마한 나라예요! 각각의 다리는 두 개의 섬을 서로 오갈 수 있게 해 주며, 몇 개의 다리들을 건너면 어떠한 두 섬들 간에도 이동이 가능하답니다. 같은 두 섬을 연결하는 다리가 여러 개 있지는 않아요. 평화로운 나날을 보내던 옥토끼나라에 슬프게도 큰 재앙이 닥쳤는데, 바로 전염병이에요. 이 전염병은 무려 라이언을 곰이라 생각하게 되는 끔찍한 질병이에요. (혹시 주변에도 그런 질병이 걸린 사람이 있다면 조심하길 바라요.)이미 K개나 되는 섬들에 이 전염병이 퍼지고 말았어요. 이 전염병들은 다리를 타고 연결된 다른 섬들의 토끼들까지 전염시키고 말 거예요. 그래서 저희는 섬들을 격리시키는 방안을 생각해냈어요! 하지만 저희는 아직 기술력이 부족해, 단 하나의 섬만을 격리시킬 수 있어요. 섬을 격리시키면 해당되는 섬과 연결된 모든 다리가 사라져요. 다리가 사라진 후, 섬들은 몇 개씩 서로 오갈 수 있는 그룹 여러개로 나타날 거예요. 이때, 그룹에서 T개 이상의 섬들이 감염되어 있으면, 그 그룹 내의 모든 섬은 전염병을 막지 못하고 모두 감염될 거랍니다. 저희를 위해 각 섬을 격리했을때 감염되지 않게 되는 섬의 개수를 구해주세요. 감염된 섬을 격리시켜도 섬 내의 토끼들은 슬프지만 이미 감염되어 있다는 걸 명심해주세요.1번 섬부터 순서대로 N번 섬까지 N개의 섬 각각에 대해, 각 섬을 격리했을 때 감염되지 않는 섬의 개수를 공백으로 구분하여 출력해 주세요.",21.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,",1.7002609920476404,16217
/problem/26153,로하의 농사,"로하가 사는 마을에는 정사각형 땅들이 $N \times M$행렬로 이루어져 있다. 로하는 그중 한 개의 땅에 살고 있으며 그 땅에 농사를 지으려 한다. 하지만 자신의 땅에서 나오는 물로는 농사짓기에 턱없이 부족하여 파이프를 만들어 주변에서 물을 최대한 끌어오려고 한다. 로하에게는 파이프를 만들기 위한 $p$개의 재료가 있으며 다음과 같은 규칙을 지키며 파이프를 건설해야 한다. 땅 한 칸에는 일자 파이프나 구부러진 파이프 중 하나만 설치할 수 있다.일자 파이프는 하나당 재료를 1개 소비하고 구부러진 파이프는 2개 소비한다. 설치한 모든 파이프는 하나로 연결되어 있어야 하며, 파이프 한쪽 끝은 반드시 자신의 땅이어야 한다.자신의 땅에는 파이프를 설치하지 않는다.로하는 파이프가 설치된 곳의 물과 자신의 땅에서 나오는 물을 모두 합한 양을 길어올 수 있다. 로하가 길어올 수 있는 물의 최대량을 구해보자.로하가 길어올 수 있는 물의 최대량을 출력한다.",12.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,",1.6784231018994775,26153
/problem/1733,등번호,"전국 마라톤 대회가 개최될 예정이다. 몹시 큰 규모의 대회이므로 주최측에서는 등번호가 적힌 티셔츠를 일률적으로 배부하여 참가자들이 이를 입고 뛰게 한다.이 티셔츠들은 양방향으로 뒤집어서 입을 수 있게 설계 되어 있다. 즉, 안쪽 면과 바깥쪽 면 모두에 등번호가 적혀있기 때문에 참가자들은 한 쪽 면을 선택하여 티셔츠를 입어야 한다.문제는 티셔츠마다 고유한 등번호를 가지고 있는 것이 아니라는 것이다. 그래서 참가자들이 주의하지 않으면 서로 같은 등번호를 달고 뛰는 경우가 발생하게 된다.이런 일이 발생하지 않도록, 참가자들에게 어떤 방향으로 옷을 입어야 하는지 알려주기 위한 프로그램을 작성하시오.N개의 행에 각 셔츠별로, 밖으로 내보여야 할 등번호를 출력한다. 불가능한 경우에는 -1을 출력한다.",20.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,",1.6767206740354028,1733
/problem/24444,알고리즘 수업 - 너비 우선 탐색 1,"오늘도 서준이는 너비 우선 탐색(BFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 너비 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.너비 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 오름차순으로 방문한다.bfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점    for each v ∈ V - {R}        visited[v] <- NO;    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.    enqueue(Q, R);  # 큐 맨 뒤에 시작 정점 R을 추가한다.    while (Q ≠ ∅) {        u <- dequeue(Q);  # 큐 맨 앞쪽의 요소를 삭제한다.        for each v ∈ E(u)  # E(u) : 정점 u의 인접 정점 집합.(정점 번호를 오름차순으로 방문한다)            if (visited[v] = NO) then {                visited[v] <- YES;  # 정점 v를 방문 했다고 표시한다.                enqueue(Q, v);  # 큐 맨 뒤에 정점 v를 추가한다.            }    }}첫째 줄부터 N개의 줄에 정수를 한 개씩 출력한다. i번째 줄에는 정점 i의 방문 순서를 출력한다. 시작 정점의 방문 순서는 1이다. 시작 정점에서 방문할 수 없는 경우 0을 출력한다.",9.0,"너비 우선 탐색,그래프 이론,그래프 탐색,정렬,",기준,24444
/problem/24447,알고리즘 수업 - 너비 우선 탐색 4,"오늘도 서준이는 너비 우선 탐색(BFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 너비 우선 탐색으로 만들어 지는 트리를 너비 우선 탐색 트리라고 하자. 너비 우선 탐색 트리에 있는 i번 노드의 깊이(depth)를 di라고 하자. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1이다. 정점 R에서 시작하여 너비 우선 탐색으로 노드를 방문할 경우 i번 노드의 방문 순서를 ti라고 하자. 시작 정점의 방문 순서는 1이고 시작 정점에서 방문할 수 없는 노드는 0이다. 모든 노드에 대한 di × ti 값의 합을 구해보자.너비 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 오름차순으로 방문한다.bfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점    for each v ∈ V - {R}        visited[v] <- NO;    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.    enqueue(Q, R);  # 큐 맨 뒤에 시작 정점 R을 추가한다.    while (Q ≠ ∅) {        u <- dequeue(Q);  # 큐 맨 앞쪽의 요소를 삭제한다.        for each v ∈ E(u)  # E(u) : 정점 u의 인접 정점 집합.(정점 번호를 오름차순으로 방문한다)            if (visited[v] = NO) then {                visited[v] <- YES;  # 정점 v를 방문 했다고 표시한다.                enqueue(Q, v);  # 큐 맨 뒤에 정점 v를 추가한다.            }    }}첫째 줄에 모든 노드에 대한 di × ti 값의 합을 출력한다.",9.0,"너비 우선 탐색,그래프 이론,그래프 탐색,정렬,",1.9999998807907107,24447
/problem/24445,알고리즘 수업 - 너비 우선 탐색 2,"오늘도 서준이는 너비 우선 탐색(BFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 너비 우선 탐색으로 노드를 방문할 경우 노드의 방문 순서를 출력하자.너비 우선 탐색 의사 코드는 다음과 같다. 인접 정점은 내림차순으로 방문한다.bfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점    for each v ∈ V - {R}        visited[v] <- NO;    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.    enqueue(Q, R);  # 큐 맨 뒤에 시작 정점 R을 추가한다.    while (Q ≠ ∅) {        u <- dequeue(Q);  # 큐 맨 앞쪽의 요소를 삭제한다.        for each v ∈ E(u)  # E(u) : 정점 u의 인접 정점 집합.(정점 번호를 내림차순으로 방문한다)            if (visited[v] = NO) then {                visited[v] <- YES;  # 정점 v를 방문 했다고 표시한다.                enqueue(Q, v);  # 큐 맨 뒤에 정점 v를 추가한다.            }    }}첫째 줄부터 N개의 줄에 정수를 한 개씩 출력한다. i번째 줄에는 정점 i의 방문 순서를 출력한다. 시작 정점의 방문 순서는 1이다. 시작 정점에서 방문할 수 없는 경우 0을 출력한다.",9.0,"너비 우선 탐색,그래프 이론,그래프 탐색,정렬,",1.9999998807907107,24445
/problem/24446,알고리즘 수업 - 너비 우선 탐색 3,"오늘도 서준이는 너비 우선 탐색(BFS) 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 정점과 M개의 간선으로 구성된 무방향 그래프(undirected graph)가 주어진다. 정점 번호는 1번부터 N번이고 모든 간선의 가중치는 1이다. 정점 R에서 시작하여 너비 우선 탐색으로 만들어 지는 트리를 너비 우선 탐색 트리라고 하자. 너비 우선 탐색 트리에 있는 모든 노드의 깊이(depth)를 출력하자. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1로 출력하자.너비 우선 탐색 의사 코드는 다음과 같다. bfs(V, E, R) {  # V : 정점 집합, E : 간선 집합, R : 시작 정점    for each v ∈ V - {R}        visited[v] <- NO;    visited[R] <- YES;  # 시작 정점 R을 방문 했다고 표시한다.    enqueue(Q, R);  # 큐 맨 뒤에 시작 정점 R을 추가한다.    while (Q ≠ ∅) {        u <- dequeue(Q);  # 큐 맨 앞쪽의 요소를 삭제한다.        for each v ∈ E(u)  # E(u) : 정점 u의 인접 정점 집합            if (visited[v] = NO) then {                visited[v] <- YES;  # 정점 v를 방문 했다고 표시한다.                enqueue(Q, v);  # 큐 맨 뒤에 정점 v를 추가한다.            }    }}첫째 줄부터 N개의 줄에 정수를 한 개씩 출력한다. i번째 줄에는 정점 i의 깊이를 출력한다. 시작 정점 R의 깊이는 0이고 방문 되지 않는 노드의 깊이는 -1로 출력하자.",9.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.9475190709762422,24446
/problem/1260,DFS와 BFS,"그래프를 DFS로 탐색한 결과와 BFS로 탐색한 결과를 출력하는 프로그램을 작성하시오. 단, 방문할 수 있는 정점이 여러 개인 경우에는 정점 번호가 작은 것을 먼저 방문하고, 더 이상 방문할 수 있는 점이 없는 경우 종료한다. 정점 번호는 1번부터 N번까지이다.첫째 줄에 DFS를 수행한 결과를, 그 다음 줄에는 BFS를 수행한 결과를 출력한다. V부터 방문된 점을 순서대로 출력하면 된다.",9.0,"그래프 이론,그래프 탐색,너비 우선 탐색,깊이 우선 탐색,",1.768528103218416,1260
/problem/19952,인성 문제 있어??,"인성이는 인싸가 되기 위해서 인싸트 특별과정에 참가했다. 훈련 첫날 인성이는 험난한 미로에서 목적지에 도달해야 하는 훈련을 받고 있다. 제한 시간 안에 미로를 통과하지 못하면 명기 교관 님에게 욕을 듣기에 인성이는 최선을 다해 미로를 통과하려고 한다.미로는 가로 길이 W, 세로 길이 H의 격자 형태를 가지며, 인성이는 한 번에 격자 상의 상, 하, 좌, 우로 한칸 씩 움직일 수 있다.  매 이동이 완료될 시에 인성이의 남은 힘은 1씩 감소하고, 남은 힘이 0이하인 경우에는 더 이상 움직이지 못하게 된다.미로의 각 격자에는 장애물이 있는데, 각각의 장애물은 높이 정보를 가지고 있다. 장애물이 없는 위치는 전부 높이가 0 이다. 인성이가 이동할 때, 현재 위치보다 이동할 위치의 높이가 더 낮으면 아무런 제약을 갖지 않고 이동할 수 있다. 더 높은 곳으로 이동할 때는 점프를 할 수 있는데, 점프해야 하는 높이는 (이동할 곳의 높이 - 현재 위치한 곳의 높이) 이다. 이때 남아있는 힘이 점프해야 하는 높이보다 크거나 같으면 이동할 수 있고, 그렇지 않으면 이동하지 못한다.인성이는 신체적 한계를 극복하고 무사히 목적지에 도달해서 명기 교관님의 욕설을 듣지 않을 수 있을까?T개의 줄에 인성이가 목적지에 도착할 수 있을 때 ""잘했어!!"", 목적지에 도착할 수 없을 때 ""인성 문제있어??"" 를 출력한다.",12.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.713300413959488,19952
/problem/28471,W키가 빠진 성원이,"성원이는 게임을 너무 열심히 한 나머지 키보드의 W키가 빠져버리게 되었다. 그럼에도 게임이 하고 싶었던 성원이는 W키 없이도 할 수 있는 게임을 찾아 나섰다. 그러다 한 게임을 찾았는데, 보통의 게임에서 WASD를 이용해 캐릭터를 움직이는 것과 달리, 이 게임에서는 Q, W, E, A, D, Z, X, C 키를 이용해 $8$방향으로 캐릭터를 움직일 수 있었다. 물론 성원이는 W키를 누르지 못하기 때문에 W키를 제외한 나머지 $7$개의 키만을 이용해 캐릭터를 움직일 수 있다. 각 키를 눌렀을 때 세부적인 이동 방식은 다음과 같다.Q: 왼쪽 위 대각선으로 $1$칸 이동W: 위쪽으로 $1$칸 이동E: 오른쪽 위 대각선으로 $1$칸 이동A: 왼쪽으로 $1$칸 이동D: 오른쪽으로 $1$칸 이동Z: 오른쪽 아래 대각선으로 $1$칸 이동X: 아래쪽으로 $1$칸 이동C: 왼쪽 아래 대각선으로 $1$칸 이동이 게임은 $N\times N$의 게임판 위에서 앞선 $8$방향(성원이의 경우 $7$방향)의 키 조작을 통해 목적지에 도달하는 것이 목표이다. 게임판은 빈 공간이 ""."", 이동할 수 없는 공간인 벽이 ""#"", 목적지가 ""F""로 주어진다. 그리고 게임을 시작하기 전에 빈 공간 중 어느 지점에 캐릭터를 둘 지 결정할 수 있다. 단, 벽이나 목적지 위에는 캐릭터를 둘 수 없다. 목적지는 항상 한 개 존재한다.#.#.#..#F게임판이 위와 같이 주어졌다고 하면, 성원이는 맨 왼쪽 아래에 캐릭터를 두지만 않는다면 목적지에 도달할 수 있다. 성원이를 위해 목적지에 도달할 수 있도록 하는 시작 지점의 개수를 구해주자.첫 번째 줄에 성원이가 목적지에 도달할 수 있도록 하는 시작 지점의 개수를 출력한다.",10.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.7112345765762178,28471
/problem/2364,담장 너머로,"어떤 나라에는 커다란 담장이 여러 개 건설되어, 한 담장의 양 끝은 정확히 두 마을과 연결이 돼 있다. 이 문제에서 마을은 점으로, 담장은 마을을 연결하는 선으로 표현된다. 담끼리 교차하는 경우는 없다. 그래서 이 나라는 담장 때문에 국토가 여러 ""구역""으로 나눠지게 되는데, 한 구역에서 다른 구역으로 가려면 마을을 통과하거나 담을 넘어야 한다. 각 담장들은 모두 서로 이어져 있기 때문에 임의의 마을 A와 B에 대해서 한쪽 끝이 A이거나 B인 담장이 반드시 존재하며, 고립돼 있는 마을이 없다. 또한 담장만 따라 걸어가면 A에서 B까지 갈 수 있다.이들 마을에 사는 사람들을 대상으로 하는 모임이 하나 있다. 각 마을마다 최대 한 명이 모임에 가입해 있으며, 모임에 가입한 사람이 한 명도 없는 마을도 있다. 그런데, 모임에 든 사람들이 마을 바깥에 있는 한 구역에서 만나고 싶어한다. 여기 회원들은 자전거를 타고 그 약속장소로 가는데, 교통 문제 때문에 마을을 통과하지 않으려 한다. 그리고 가는 과정에서 담장은 가능한 한 적게 넘고 싶다. 이들은, 도착하기 위해 각 회원들이 담장을 넘어야 하는 횟수의 합이 가장 적게 되는 곳을 찾아 거기서 모이기를 원한다.마을은 1부터 N까지 번호가 매겨져 있다. (N은 마을의 총 개수) 그림 1을 보면, 정점은 마을을 나타내고, 정점들을 잇는 선은 담장을 나타낸다. 그리고 모임에 든 사람은 3번, 6번, 9번 마을에 한 사람씩 있다고 가정하자. 이때, 이 사람들이 전체적으로 담장을 가장 적게 거쳐서 모일 수 있는 적합한 곳은 그림 2에 나타나 있는 구역이다. 각 마을 사람이 화살표 친 대로 이동하면 되는 것이다. 담장을 넘은 총횟수는 2이다. 6번 사람이 4번과 7번 마을 사이에 있는 담을 넘어야 하고, 9번 사람이 2번과 4번 마을 사이에 있는 담을 넘었기 때문이다.마을과 담장, 그리고 모임에 속한 사람들에 대한 자료를 입력받아, 모이기에 가장 적합한 구역을 고르고 담장을 넘는 총횟수의 최솟값을 구하는 프로그램을 작성하라.첫째 줄에는 답안 프로그램이 구한 총횟수의 최솟값을 출력한다. 둘째 줄에는 담장을 가장 적게 넘고 만날 수 있는 구역의 번호를 출력한다. 그런 구역이 여러 개 있을 수 있더라도 한 곳만 출력하면 된다.",15.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.705471999519333,2364
/problem/20158,사장님 달려가고 있습니다,"알바 첫날인 정훈이는 늦잠을 잤다. 다행히도 정훈이는 달리기가 정말 빨라서 괜찮다고 생각했지만, 오늘은 공사로 인해 길을 통제하는 중이었다. 첫날부터 늦을 수 없는 정훈이는 가장 빠른 경로를 생각하며 달린다.공사 지도 N x N가 있다.정훈이는 0초에 맨 왼쪽 위(1, 1)에서 출발하고 맨 오른쪽 아래(N, N)에 도착해야 한다.달리는 방향은 상,하,좌,우로 달릴 수 있다.매초 1칸을 갈 수 있고 전과 같은 방향으로 달린다면 가속도가 붙어 1초 안에 전보다 1칸을 더 갈 수 있다. (전에 오른쪽으로 1칸을 갔다면 오른쪽으로 2칸을 1초에 갈 수 있다.)가속도를 주체할 수 없으므로 방향전환을 해야만 다시 1초에 1칸을 갈 수 있다.정훈이는 현재 위치에서 달려갈 때 1초 후 지도 밖에 서 있다면 갈 수 없다고 판단한다.공사로 인해 통제하는 구역은 N x N 지도에 통제 시작시각이 초 단위로 주어지며 통제를 시작하기 전까지만 그 구역을 들어갈 수 있다. 통제 시작시각과 그 구역에 도착시각이 같은 시간일 경우에는 구역에 들어갈 수 없다.정훈이가 (N, N)에 도착할 수 있는 최소 시간을 출력한다.",15.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.7046697210006563,20158
/problem/15984,유물 도둑,"마녀로부터 도망치는데 겨우겨우 성공한 현욱은 여행을 계속해서 이어나갔다. 여행 중에 현욱은 어떤 유적에 도착했다. 이 유적은 총 N개의 구역으로 이루어져있고, 각각의 구역을 잇는 M개의 길이 존재한다. M개의 길은 양방향이라 어느 방향으로든 지나다닐 수 있으며, 길을 지나가는데에는 1분의 시간이 걸린다. 모든 구역은 연결되어 있어서 서로 방문 가능하다.이 유적은 한창 발굴이 진행중이고 지금으로부터 K분 후에 발굴이 끝날 것으로 예상하고 있다. 유적 발굴단은 각 구역마다 어떤 가치를 지닌 유물이 나올지를 미리 계산해뒀는데, 현욱은 이 정보를 몰래 입수하고는 이 중에 제일 가치 있는 유물이 있는 지역으로 가서 몰래 유물을 훔쳐가려고 한다.물론 유적 발굴단 역시 이런 유물 도둑들을 경계하고 있기 때문에, 훔쳐가지 못하게 구역들을 감시하고 있다. 현욱은 최대한 안전하게 유물을 가져가고 싶기 때문에 사람들이 감시하고 있는 구역은 가지 않으려고 한다. 현욱은 이 감시 일정표를 미리 입수해뒀는데, 감시 일정표에는 총 Q개의 일정이 적혀있으며 각각의 일정은 Ti와 Xi 값으로 구성되어있다. 이 값의 의미는 Ti분부터 1분동안 Xi구역을 감시한다는 의미이다. Ti분에 누군가가 Xi 구역을 감시하고 있다면 현욱은 그 구역에 방문할 수 없고, Ti + 1분이 되면 다시 방문할 수 있게 된다.또, 한 구역에 계속 머물고 있으면 유적 발굴단이 경계를 할 수 있기 때문에 현욱은 한 구역에 머무르지 않고 한 장소에 도착하는 즉시 다른 장소로 이동을 하려고 한다.현욱은 지금 1번 구역에 있고, 정확히 K분이 지난 후 발굴이 끝나자마자 가장 가치가 높은 유물이 있는 지역에서 유물을 챙겨 도망가려고 한다. 현욱을 도와 감시를 피해 정확히 K분 후에 방문 가능한 구역들 중 유물의 가치가 가장 높은 지역의 유물 가치와 그런 지역의 개수를 구해서 출력하는 프로그램을 작성해보자.첫째 줄에 정확히 K분 후에 도착 할 수 있는 구역중 유물의 가치가 가장 높은 구역의 유물 가치와 그러한 구역의 개수를 공백으로 구분하여 출력한다. 만약 정확히 K분 후에 도착 가능한 구역이 존재하지 않는다면 -1을 출력한다.",21.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.7032133411102144,15984
/problem/2606,바이러스,"신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.예를 들어 7대의 컴퓨터가 <그림 1>과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.",8.0,"그래프 이론,그래프 탐색,너비 우선 탐색,깊이 우선 탐색,",기준,2606
/problem/16174,점프왕 쩰리 (Large),"‘쩰리’는 점프하는 것을 좋아하는 젤리다. 단순히 점프하는 것에 지루함을 느낀 ‘쩰리’는 새로운 점프 게임을 해보고 싶어 한다. 새로운 점프 게임의 조건은 다음과 같다.‘쩰리’는 가로와 세로의 칸 수가 같은 정사각형의 구역 내부에서만 움직일 수 있다. ‘쩰리’가 정사각형 구역의 외부로 나가는 경우엔 바닥으로 떨어져 즉시 게임에서 패배하게 된다.‘쩰리’의 출발점은 항상 정사각형의 가장 왼쪽, 가장 위의 칸이다. 다른 출발점에서는 출발하지 않는다.‘쩰리’가 이동 가능한 방향은 오른쪽과 아래 뿐이다. 위쪽과 왼쪽으로는 이동할 수 없다.‘쩰리’가 가장 오른쪽, 가장 아래 칸에 도달하는 순간, 그 즉시 ‘쩰리’의 승리로 게임은 종료된다.‘쩰리’가 한 번에 이동할 수 있는 칸의 수는, 현재 밟고 있는 칸에 쓰여 있는 수 만큼이다. 칸에 쓰여 있는 수 초과나 그 미만으로 이동할 수 없다.새로운 게임이 맘에 든 ‘쩰리’는, 계속 게임을 진행해 마침내 최종 단계에 도달했다. 하지만, 게임을 진행하는 구역이 너무 넓어져버린 나머지, 이 게임에서 이길 수 있는지 없는지 가늠할 수 없어졌다. ‘쩰리’는 유능한 프로그래머인 당신에게 주어진 구역에서 승리할 수 있는 지 알아봐 달라고 부탁했다. ‘쩰리’를 도와 주어진 게임 구역에서 끝 점(오른쪽 맨 아래 칸)까지 도달할 수 있는지를 알아보자!‘쩰리’가 끝 점에 도달할 수 있으면 “HaruHaru”(인용부호 없이), 도달할 수 없으면 “Hing” (인용부호 없이)을 한 줄에 출력합니다.",10.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.9499127864837646,16174
/problem/13265,색칠하기,"어린 토니킴은 색칠공부를 좋아한다.토니킴은 먼저 여러 동그라미와 동그라미 두 개를 연결하는 직선들 만으로 그림을 그리고 (모든 동그라미들 사이에 직선이 있을 필요는 없다), 연결된 두 동그라미는 서로 색이 다르게 되도록 색을 칠하고자 한다.이 그림을 색칠하는데 필요한 최소의 색의 개수를 구하는 문제는 어렵기 때문에 토니킴은 2 가지 색상으로 색칠이 가능한지의 여부만을 알고 싶어한다.동그라미들의 번호와 동그라미들이 서로 연결된 직선에 대한 정보가 주어졌을 때, 이 동그라미들이 2 가지 색상으로 색칠이 가능한지 알아내자.각 테스트 케이스에 대해서 possible 이나 impossible 을 출력한다. 2 가지 색상으로 색칠이 가능하면 possible. 불가능하면 impossible 이다.",11.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.9378736019134521,13265
/problem/1926,그림,"어떤 큰 도화지에 그림이 그려져 있을 때, 그 그림의 개수와, 그 그림 중 넓이가 가장 넓은 것의 넓이를 출력하여라. 단, 그림이라는 것은 1로 연결된 것을 한 그림이라고 정의하자. 가로나 세로로 연결된 것은 연결이 된 것이고 대각선으로 연결이 된 것은 떨어진 그림이다. 그림의 넓이란 그림에 포함된 1의 개수이다.첫째 줄에는 그림의 개수, 둘째 줄에는 그 중 가장 넓은 그림의 넓이를 출력하여라. 단, 그림이 하나도 없는 경우에는 가장 넓은 그림의 넓이는 0이다.",10.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.9257274270057678,1926
/problem/14466,소가 길을 건너간 이유 6,"소가 길을 건너간 이유는 그냥 길이 많아서이다. 존의 농장에는 길이 너무 많아서, 길을 건너지 않고서는 별로 돌아다닐 수가 없다.존의 농장에 대대적인 개편이 있었다. 이제 작은 정사각형 목초지가 N×N (2 ≤ N ≤ 100) 격자로 이루어져 있다. 인접한 목초지 사이는 일반적으로 자유롭게 건너갈 수 있지만, 그 중 일부는 길을 건너야 한다. 농장의 바깥에는 높은 울타리가 있어서 소가 농장 밖으로 나갈 일은 없다.K마리의 (1 ≤ K ≤ 100,K ≤ N2) 소가 존의 농장에 있고, 각 소는 서로 다른 목초지에 있다. 어떤 두 소는 길을 건너지 않으면 만나지 못 할 수 있다. 이런 소가 몇 쌍인지 세어보자.길을 건너지 않으면 만날 수 없는 소가 몇 쌍인지 출력한다.",12.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.9256537556648254,14466
/problem/1012,유기농 배추,"차세대 영농인 한나는 강원도 고랭지에서 유기농 배추를 재배하기로 하였다. 농약을 쓰지 않고 배추를 재배하려면 배추를 해충으로부터 보호하는 것이 중요하기 때문에, 한나는 해충 방지에 효과적인 배추흰지렁이를 구입하기로 결심한다. 이 지렁이는 배추근처에 서식하며 해충을 잡아 먹음으로써 배추를 보호한다. 특히, 어떤 배추에 배추흰지렁이가 한 마리라도 살고 있으면 이 지렁이는 인접한 다른 배추로 이동할 수 있어, 그 배추들 역시 해충으로부터 보호받을 수 있다. 한 배추의 상하좌우 네 방향에 다른 배추가 위치한 경우에 서로 인접해있는 것이다.한나가 배추를 재배하는 땅은 고르지 못해서 배추를 군데군데 심어 놓았다. 배추들이 모여있는 곳에는 배추흰지렁이가 한 마리만 있으면 되므로 서로 인접해있는 배추들이 몇 군데에 퍼져있는지 조사하면 총 몇 마리의 지렁이가 필요한지 알 수 있다. 예를 들어 배추밭이 아래와 같이 구성되어 있으면 최소 5마리의 배추흰지렁이가 필요하다. 0은 배추가 심어져 있지 않은 땅이고, 1은 배추가 심어져 있는 땅을 나타낸다.110000000001000000000000100000000010000000110001110000100111각 테스트 케이스에 대해 필요한 최소의 배추흰지렁이 마리 수를 출력한다.",9.0,"그래프 이론,그래프 탐색,너비 우선 탐색,깊이 우선 탐색,",1.9141465425491333,1012
/problem/2644,촌수계산,"우리 나라는 가족 혹은 친척들 사이의 관계를 촌수라는 단위로 표현하는 독특한 문화를 가지고 있다. 이러한 촌수는 다음과 같은 방식으로 계산된다. 기본적으로 부모와 자식 사이를 1촌으로 정의하고 이로부터 사람들 간의 촌수를 계산한다. 예를 들면 나와 아버지, 아버지와 할아버지는 각각 1촌으로 나와 할아버지는 2촌이 되고, 아버지 형제들과 할아버지는 1촌, 나와 아버지 형제들과는 3촌이 된다.여러 사람들에 대한 부모 자식들 간의 관계가 주어졌을 때, 주어진 두 사람의 촌수를 계산하는 프로그램을 작성하시오.입력에서 요구한 두 사람의 촌수를 나타내는 정수를 출력한다. 어떤 경우에는 두 사람의 친척 관계가 전혀 없어 촌수를 계산할 수 없을 때가 있다. 이때에는 -1을 출력해야 한다.",9.0,"그래프 이론,그래프 탐색,너비 우선 탐색,깊이 우선 탐색,",1.9107251167297363,2644
/problem/1325,효율적인 해킹,"해커 김지민은 잘 알려진 어느 회사를 해킹하려고 한다. 이 회사는 N개의 컴퓨터로 이루어져 있다. 김지민은 귀찮기 때문에, 한 번의 해킹으로 여러 개의 컴퓨터를 해킹 할 수 있는 컴퓨터를 해킹하려고 한다.이 회사의 컴퓨터는 신뢰하는 관계와, 신뢰하지 않는 관계로 이루어져 있는데, A가 B를 신뢰하는 경우에는 B를 해킹하면, A도 해킹할 수 있다는 소리다.이 회사의 컴퓨터의 신뢰하는 관계가 주어졌을 때, 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 출력하는 프로그램을 작성하시오.첫째 줄에, 김지민이 한 번에 가장 많은 컴퓨터를 해킹할 수 있는 컴퓨터의 번호를 오름차순으로 출력한다.",10.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.906862199306488,1325
/problem/4963,섬의 개수,"정사각형으로 이루어져 있는 섬과 바다 지도가 주어진다. 섬의 개수를 세는 프로그램을 작성하시오.한 정사각형과 가로, 세로 또는 대각선으로 연결되어 있는 사각형은 걸어갈 수 있는 사각형이다. 두 정사각형이 같은 섬에 있으려면, 한 정사각형에서 다른 정사각형으로 걸어서 갈 수 있는 경로가 있어야 한다. 지도는 바다로 둘러싸여 있으며, 지도 밖으로 나갈 수 없다.각 테스트 케이스에 대해서, 섬의 개수를 출력한다.",9.0,"그래프 이론,그래프 탐색,너비 우선 탐색,깊이 우선 탐색,",1.9018364548683167,4963
/problem/25032,Young Zebra,"요즘 젊은 얼룩말 사이에서는, 가죽의 흑백 무늬를 새롭게 바꾸는 수술이 대인기다. 젊은 얼룩말인 정우도 이 수술로 가죽의 무늬를 바꾸는 것에 관심이 많다.이 수술을 받기 전에 수술을 받는 얼룩말이 원하는 크기의 흑백 패턴을 준비 해야 하고, 수술은 이 패턴을 무한히 이어 붙인 것을 기준으로 한다. 예를 들어, $2 \times 3$크기의 패턴과 이 패턴을 이어 붙인 그림이다.그림 1: $2 \times 3$크기의 패턴그림 2 : 위의 패턴을 무한히 이어 붙인 것의 일부. 빨간 직사각형은 위의 패턴을 나타내며, 뒤틀림 없이 그대로 맞춰서 이어 붙인다.격자는 시술할 때 없어지므로 이상하게 시술이 될 것 같다는 걱정은 하지 않으셔도 됩니다.정우는 먼저 패턴을 정한 후, 무한히 이어 붙여보는 것을 해보려고 한다. 이 때, 중요한 것은 무한히 이어 붙인 다음 각 칸이 이루는 연결 성분의 크기이다. 이것은 미관상 매우 중요한 문제다. 만약 색이 같은 두 칸이 상하좌우로 붙어있다면 그 두 칸은 같은 연결 성분에 들어가는 것이다.그림 2에서 각 칸이 속한 연결 성분의 크기를 구해보면, 검은색 칸이 속한 연결 성분의 크기는 모두 $24$이고, 흰색 칸이 속한 연결 성분에는 무한히 많은 칸이 포함된다. 즉, 크기가 무한대이다. 주어진 패턴을 무한히 이어 붙인 다음 각 칸이 속한 연결 성분의 크기를 구하는 프로그램을 작성하라.총 $N$개의 줄에 걸쳐 정답을 출력한다. $i$번째 줄에는 $M$개의 수가 공백 하나로 구분되어 출력되어야 하고, 그 중 $j$번째 수는 입력에서 $i$번째 행 $j$번째 열에 주어진 칸이 속한 연결 성분의 크기여야 한다. 만약 그 크기가 무한히 크다면 -1로 출력해야 한다.",18.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.9005536437034607,25032
/problem/11123,양 한마리... 양 두마리...,"얼마전에 나는 불면증에 시달렸지... 천장이 뚫어져라 뜬 눈으로 밤을 지새우곤 했었지.  그러던 어느 날 내 친구 광민이에게 나의 불면증에 대해 말했더니 이렇게 말하더군. ""양이라도 세봐!""  정말 도움이 안되는 친구라고 생각했었지. 그런데 막상 또 다시 잠을 청해보려고 침대에 눕고 보니 양을 세고 있더군... 그런데 양을 세다보니 이걸로 프로그램을 하나 짜볼 수 있겠단 생각이 들더군 후후후... 그렇게 나는 침대에서 일어나 컴퓨터 앞으로 향했지.양을 # 으로 나타내고 . 으로 풀을 표현하는 거야. 서로 다른 # 두 개 이상이 붙어있다면 한 무리의 양들이 있는거지. 그래... 좋았어..! 이걸로 초원에서 풀을 뜯고 있는 양들을 그리드로 표현해 보는거야!그렇게 나는 양들을 그리드로 표현하고 나니까 갑자기 졸렵기 시작했어. 하지만 난 너무 궁금했지. 내가 표현한 그 그리드 위에 몇 개의 양무리가 있었는지! 그래서 나는 동이 트기 전까지 이 프로그램을 작성하고 장렬히 전사했지. 다음날 내가 잠에서 깨어났을 때 내 모니터에는 몇 개의 양무리가 있었는지 출력되어 있었지.각 테스트 케이스마다, 양의 몇 개의 무리로 이루어져 있었는지를 한 줄에 출력하면 된다. ",9.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.6879688501358032,11123
/problem/2667,단지번호붙이기,"<그림 1>과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. <그림 2>는 <그림 1>을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.",10.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",기준,2667
/problem/2310,어드벤처 게임,"어드벤처 게임을 하던 중, 1부터 n까지의 번호가 붙은 방을 지나가야 하는 마법의 미로를 마주쳤다. 각 방 안에는 번호가 붙은 문이 있을 수 있고, 각 문은 해당하는 번호의 방으로 통한다. 방 안에는 레프리콘이나 트롤이 있을 수도 있다.레프리콘이 있는 방에 들어가면 레프리콘은 모험가의 소지금이 일정 양 이하로 떨어지지 않게 채워준다. 레프리콘은 모험가의 소지금이 일정량 미만일 때에는 그만한 양이 되도록 금화를 채워주고, 소지금이 일정량 이상일 때에는 그대로 둔다. 트롤이 있는 방에 들어가려면 일정량의 통행료를 지불해야 한다. 이는 맨 처음에 모험가가 1번 방에서 시작하려 할 때에도 마찬가지이다.모험가는 소지금이 0인 상태에서 출발한다. 과연 모험가는 1번 방에서 출발해서 n번 방에 도착할 수 있을까?출력은 각 미로마다 한 줄씩으로 이루어진다. 각 줄에는 1번 방에서 n번 방까지 갈 수 있는지를 ""Yes"" 또는 ""No""로 출력한다.",12.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.8561099767684937,2310
/problem/2583,영역 구하기,"눈금의 간격이 1인 M×N(M,N≤100)크기의 모눈종이가 있다. 이 모눈종이 위에 눈금에 맞추어 K개의 직사각형을 그릴 때, 이들 K개의 직사각형의 내부를 제외한 나머지 부분이 몇 개의 분리된 영역으로 나누어진다.예를 들어 M=5, N=7 인 모눈종이 위에 <그림 1>과 같이 직사각형 3개를 그렸다면, 그 나머지 영역은 <그림 2>와 같이 3개의 분리된 영역으로 나누어지게 된다.<그림 2>와 같이 분리된 세 영역의 넓이는 각각 1, 7, 13이 된다.M, N과 K 그리고 K개의 직사각형의 좌표가 주어질 때, K개의 직사각형 내부를 제외한 나머지 부분이 몇 개의 분리된 영역으로 나누어지는지, 그리고 분리된 각 영역의 넓이가 얼마인지를 구하여 이를 출력하는 프로그램을 작성하시오.첫째 줄에 분리되어 나누어지는 영역의 개수를 출력한다. 둘째 줄에는 각 영역의 넓이를 오름차순으로 정렬하여 빈칸을 사이에 두고 출력한다.",10.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.828989028930664,2583
/problem/5547,일루미네이션,"부유한 집안의 상속자 상근이네 집은 그림과 같이 1미터의 정육각형이 붙어있는 상태이다. 크리스마스가 다가오기 때문에, 여자친구에게 잘 보이기 위해 상근이는 건물의 벽면을 조명으로 장식하려고 한다. 외부에 보이지 않는 부분에 조명을 장식하는 것은 낭비라고 생각했기 때문에, 밖에서 보이는 부분만 장식하려고 한다.위의 그림은 상공에서 본 상근이네 집의 건물 배치이다. 정육각형 안의 숫자는 좌표를 나타낸다. 여기서 회색 정육각형은 건물의 위치이고, 흰색은 건물이 없는 곳이다. 위에서 붉은 색 선으로 표시된 부분이 밖에서 보이는 벽이고, 이 벽에 조명을 장식할 것이다. 벽의 총 길이는 64미터이다.상근이네 집의 건물 위치 지도가 주어졌을 때, 조명을 장식할 벽면의 길이의 합을 구하는 프로그램을 작성하시오. 지도의 바깥은 자유롭게 왕래 할 수 있는 곳이고, 인접한 건물 사이는 통과할 수 없다.조명을 장식하는 벽면의 길이의 합을 출력한다.",12.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.8271418809890747,5547
/problem/11725,트리의 부모 찾기,"루트 없는 트리가 주어진다. 이때, 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프로그램을 작성하시오.첫째 줄부터 N-1개의 줄에 각 노드의 부모 노드 번호를 2번 노드부터 순서대로 출력한다.",9.0,"그래프 이론,그래프 탐색,트리,너비 우선 탐색,깊이 우선 탐색,",1.8238140622004506,11725
/problem/1938,통나무 옮기기,"가로와 세로의 길이가 같은 평지에서 벌목을 한다. 그 지형은 0과 1로 나타나 있다. 1은 아직 잘려지지 않은 나무를 나타내고 0은 아무 것도 없음을 나타낸다. 다음 지형을 보자.B 0 0 1 1B 0 0 0 0B 0 0 0 01 1 0 0 0E E E 0 0위의 지형에서 길이 3인 통나무 BBB를 밀거나 회전시켜 EEE의 위치로 옮기는 작업을 하는 문제를 생각해 보자. BBB와 EEE의 위치는 임의로 주어진다. 단 문제에서 통나무의 길이는 항상 3이며 B의 개수와 E의 개수는 같다. 통나무를 움직이는 방법은 아래와 같이 상하좌우(Up, Down, Left, Right)와 회전(Turn)이 있다.코드의미U통나무를 위로 한 칸 옮긴다.D통나무를 아래로 한 칸 옮긴다.L통나무를 왼쪽으로 한 칸 옮긴다.R통나무를 오른쪽으로 한 칸 옮긴다.T중심점을 중심으로 90도 회전시킨다.예를 들면, 다음과 같다. (초기상태로부터의 이동)초기상태상(U)하(D)좌(L)우(R)회전(T)0 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 B B B 0 00 0 0 0 0 00 0 0 1 0 00 0 0 0 0 00 0 0 0 0 00 B B B 0 00 0 0 0 0 00 0 0 0 0 00 0 0 1 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 B B B 0 00 0 0 1 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 0B B B 0 0 00 0 0 0 0 00 0 0 1 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 B B B 00 0 0 0 0 00 0 0 1 0 00 0 0 0 0 00 0 0 0 0 00 0 B 0 0 00 0 B 0 0 00 0 B 0 0 00 0 0 1 0 0이와 같은 방식으로 이동시킬 때에 그 움직일 위치에 다른 나무, 즉 1이 없어야만 움직일 수 있다. 그리고 움직임은 위의 그림과 같이 한 번에 한 칸씩만 움직인다. 단 움직이는 통나무는 어떤 경우이든지 중간단계에서 한 행이나 한 열에만 놓일 수 있다. 예를 들면 아래 그림에서 a와 같은 단계는 불가능하다. 그리고 회전의 경우에서는 반드시 중심점을 중심으로 90도 회전을 해야 한다. (항상 통나무의 길이가 3이므로 중심점이 있음)그리고 이런 회전(Turn)이 가능하기 위해서는 그 통나무를 둘러싸고 있는 3*3 정사각형의 구역에 단 한 그루의 나무도 없어야만 한다. 즉, 아래그림 b, d와 같이 ?로 표시된 지역에 다른 나무, 즉 1이 없어야만 회전시킬 수 있다. 따라서 c와 같은 경우에, 통나무는 왼쪽 아직 벌채되지 않은 나무 때문에 회전시킬 수 없다.abcd0 0 0 0 0 00 0 0 0 0 00 0 0 B 0 00 0 B 0 0 00 B 0 0 0 00 0 0 1 0 00 0 0 0 0 00 0 0 0 0 00 0 ? ? ? 00 0 B B B 00 0 ? ? ? 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 1 B 0 00 0 0 B 0 00 0 0 B 0 00 0 0 0 0 00 0 0 0 0 00 0 0 0 0 00 0 ? B ? 00 0 ? B ? 00 0 ? B ? 00 0 0 0 0 0문제는 통나무를 5개의 기본동작(U, D, L, R, T)만을 사용하여 처음위치(BBB)에서 최종위치(EEE)로 옮기는 프로그램을 작성하는 것이다. 단, 최소 횟수의 단위 동작을 사용해야 한다.첫째 줄에 최소 동작 횟수를 출력한다. 이동이 불가능하면 0만을 출력한다.",14.0,"너비 우선 탐색,그래프 이론,그래프 탐색,구현,",1.8150291968763592,1938
/problem/16946,벽 부수고 이동하기 4,"N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 한 칸에서 다른 칸으로 이동하려면, 두 칸이 인접해야 한다. 두 칸이 변을 공유할 때, 인접하다고 한다.각각의 벽에 대해서 다음을 구해보려고 한다.벽을 부수고 이동할 수 있는 곳으로 변경한다.그 위치에서 이동할 수 있는 칸의 개수를 세어본다.한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.맵의 형태로 정답을 출력한다. 원래 빈 칸인 곳은 0을 출력하고, 벽인 곳은 이동할 수 있는 칸의 개수를 10으로 나눈 나머지를 출력한다.",14.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.7888081073760986,16946
/problem/2178,미로 탐색,"N×M크기의 배열로 표현되는 미로가 있다.101111101010101011111011미로에서 1은 이동할 수 있는 칸을 나타내고, 0은 이동할 수 없는 칸을 나타낸다. 이러한 미로가 주어졌을 때, (1, 1)에서 출발하여 (N, M)의 위치로 이동할 때 지나야 하는 최소의 칸 수를 구하는 프로그램을 작성하시오. 한 칸에서 다른 칸으로 이동할 때, 서로 인접한 칸으로만 이동할 수 있다.위의 예에서는 15칸을 지나야 (N, M)의 위치로 이동할 수 있다. 칸을 셀 때에는 시작 위치와 도착 위치도 포함한다.첫째 줄에 지나야 하는 최소의 칸 수를 출력한다. 항상 도착위치로 이동할 수 있는 경우만 입력으로 주어진다.",10.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.7879352591420652,2178
/problem/8111,0과 1,"폴란드 왕자 구사과는 다음과 같은 수를 좋아한다.0과 1로만 이루어져 있어야 한다.1이 적어도 하나 있어야 한다.수의 길이가 100 이하이다.수가 0으로 시작하지 않는다.예를 들어, 101은 구사과가 좋아하는 수이다.자연수 N이 주어졌을 때, N의 배수 중에서 구사과가 좋아하는 수를 구하는 프로그램을 작성하시오.각각의 테스트 케이스마다 N의 배수이면서, 구사과가 좋아하는 수를 아무거나 출력한다. 만약, 그러한 수가 없다면 BRAK을 출력한다.",16.0,"너비 우선 탐색,그래프 이론,그래프 탐색,수학,",1.7850687876641984,8111
/problem/8112,0과 1 - 2,"폴란드 왕자 구사과는 다음과 같은 수를 좋아한다.0과 1로만 이루어져 있어야 한다.1이 적어도 하나 있어야 한다.수가 0으로 시작하지 않는다.예를 들어, 101은 구사과가 좋아하는 수이다.자연수 N이 주어졌을 때, N의 배수이면서, 구사과가 좋아하는 수 중에서 가장 작은 수를 구하는 프로그램을 작성하시오.각각의 테스트 케이스마다 N의 배수이면서, 구사과가 좋아하는 수 중에서 가장 작은 수를 출력한다. 만약, 그러한 수가 없다면 BRAK을 출력한다.",17.0,"너비 우선 탐색,그래프 이론,그래프 탐색,수학,",1.7850687876641984,8112
/problem/3187,양치기 꿍,"양치기 꿍은 맨날 늑대가 나타났다고 마을 사람들을 속였지만 이젠 더이상 마을 사람들이 속지 않는다. 화가 난 꿍은 복수심에 불타 아예 늑대들을 양들이 있는 울타리안에 마구 집어넣어 양들을 잡아먹게 했다.하지만 양들은 보통 양들이 아니다. 같은 울타리 영역 안의 양들의 숫자가 늑대의 숫자보다 더 많을 경우 늑대가 전부 잡아먹힌다. 물론 그 외의 경우는 양이 전부 잡아먹히겠지만 말이다.꿍은 워낙 똑똑했기 때문에 이들의 결과는 이미 알고있다. 만약 빈 공간을 '.'(점)으로 나타내고 울타리를 '#', 늑대를 'v', 양을 'k'라고 나타낸다면 여러분은 몇 마리의 양과 늑대가 살아남을지 계산할 수 있겠는가?단, 울타리로 막히지 않은 영역에는 양과 늑대가 없으며 양과 늑대는 대각선으로 이동할 수 없다.살아남게 되는 양과 늑대의 수를 각각 순서대로 출력한다.",10.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.9161615371704102,3187
/problem/1303,전쟁 - 전투,"전쟁은 어느덧 전면전이 시작되었다. 결국 전투는 난전이 되었고, 우리 병사와 적국 병사가 섞여 싸우게 되었다. 그러나 당신의 병사들은 흰색 옷을 입고, 적국의 병사들은 파란색 옷을 입었기 때문에 서로가 적인지 아군인지는 구분할 수 있다. 문제는 같은 팀의 병사들은 모이면 모일수록 강해진다는 사실이다.N명이 뭉쳐있을 때는 N2의 위력을 낼 수 있다. 과연 지금 난전의 상황에서는 누가 승리할 것인가? 단, 같은 팀의 병사들이 대각선으로만 인접한 경우는 뭉쳐 있다고 보지 않는다.첫 번째 줄에 당신의 병사의 위력의 합과 적국의 병사의 위력의 합을 출력한다.",10.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.907882809638977,1303
/problem/10026,적록색약,"적록색약은 빨간색과 초록색의 차이를 거의 느끼지 못한다. 따라서, 적록색약인 사람이 보는 그림은 아닌 사람이 보는 그림과는 좀 다를 수 있다.크기가 N×N인 그리드의 각 칸에 R(빨강), G(초록), B(파랑) 중 하나를 색칠한 그림이 있다. 그림은 몇 개의 구역으로 나뉘어져 있는데, 구역은 같은 색으로 이루어져 있다. 또, 같은 색상이 상하좌우로 인접해 있는 경우에 두 글자는 같은 구역에 속한다. (색상의 차이를 거의 느끼지 못하는 경우도 같은 색상이라 한다)예를 들어, 그림이 아래와 같은 경우에RRRBBGGBBBBBBRRBBRRRRRRRR적록색약이 아닌 사람이 봤을 때 구역의 수는 총 4개이다. (빨강 2, 파랑 1, 초록 1) 하지만, 적록색약인 사람은 구역을 3개 볼 수 있다. (빨강-초록 2, 파랑 1)그림이 입력으로 주어졌을 때, 적록색약인 사람이 봤을 때와 아닌 사람이 봤을 때 구역의 수를 구하는 프로그램을 작성하시오.적록색약이 아닌 사람이 봤을 때의 구역의 개수와 적록색약인 사람이 봤을 때의 구역의 수를 공백으로 구분해 출력한다.",11.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.897754430770874,10026
/problem/17220,마약수사대,"최근들어 세계적으로 마약과 관련한 사회적 문제들이 많이 발생하고 있다. 이에 따라 경찰은 마약 수사대의 한정된 인력이 허용하는 선에서 최대한 마약공급을 막고자 한다.마약 공급책들은 서로에게 마약을 공급받는데, 최근 마약수사대는 마약 공급책들 간의 관계도를 일부 파악하였다. 이 관계도는 그래프로 표현될 수 있다. 각 노드는 마약 공급책, 간선은 공급 관계를 표현한다. 예를 들어 아래와 같은 그래프는 다음을 나타낸 것이다.마약공급책 A가 마약 공급책 B, C, D, E 에게 마약을 공급한다.마약공급책 F는 B와 C로부터 마약을 공급받아서 I에게 공급한다.I는 J에게, J는 K에게, D는 G에게, E는 H에게 각각 마약을 공급한다.마약수사대는 소재를 파악하고 있는 마약 공급책을 검거할 수 있다.예를 들어, 마약수사대가 B와 C를 검거해도 D, E, G, H는 여전히 마약을 공급받을 수 있다.마약의 원산지는 '다른 공급책에게 공급받지 않으면서 마약을 공급하는 마약공급책'이다.마약 공급책들의 관계도에 대한 정보와 마약수사대가 검거한 마약 공급책들이 주어졌을 때 여전히 마약을 공급 받을 수 있는 마약 공급책의 수를 내어주는 프로그램을 작성해보자.마약수사대가 파악중인 마약 공급책을 검거한 후 여전히 마약을 공급 받는 마약 공급책의 수를 출력한다.",12.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.8931655287742615,17220
/problem/2206,벽 부수고 이동하기,"N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.만약에 이동하는 도중에 한 개의 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 한 개 까지 부수고 이동하여도 된다.한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.",13.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.8834112882614138,2206
/problem/16933,벽 부수고 이동하기 3,"N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다. 이동하지 않고 같은 칸에 머물러있는 경우도 가능하다. 이 경우도 방문한 칸의 개수가 하나 늘어나는 것으로 생각해야 한다.이번 문제에서는 낮과 밤이 번갈아가면서 등장한다. 가장 처음에 이동할 때는 낮이고, 한 번 이동할 때마다 낮과 밤이 바뀌게 된다. 이동하지 않고 같은 칸에 머무르는 경우에도 낮과 밤이 바뀌게 된다.만약에 이동하는 도중에 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 K개 까지 부수고 이동하여도 된다. 단, 벽은 낮에만 부술 수 있다.한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.",15.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.8834112882614138,16933
/problem/14442,벽 부수고 이동하기 2,"N×M의 행렬로 표현되는 맵이 있다. 맵에서 0은 이동할 수 있는 곳을 나타내고, 1은 이동할 수 없는 벽이 있는 곳을 나타낸다. 당신은 (1, 1)에서 (N, M)의 위치까지 이동하려 하는데, 이때 최단 경로로 이동하려 한다. 최단경로는 맵에서 가장 적은 개수의 칸을 지나는 경로를 말하는데, 이때 시작하는 칸과 끝나는 칸도 포함해서 센다.만약에 이동하는 도중에 벽을 부수고 이동하는 것이 좀 더 경로가 짧아진다면, 벽을 K개 까지 부수고 이동하여도 된다.한 칸에서 이동할 수 있는 칸은 상하좌우로 인접한 칸이다.맵이 주어졌을 때, 최단 경로를 구해 내는 프로그램을 작성하시오.첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.",13.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.8834112882614138,14442
/problem/2593,엘리베이터,"N층으로 이뤄진 고층 아파트에 M대의 엘리베이터가 있다. 각 엘리베이터에는 1부터 M까지 번호가 매겨져있다.아파트 관리인은 유지비를 줄이기 위하여 각 엘리베이터가 특정한 층에서만 서도록 하였다. 그 결과 i번 엘리베이터는 Xi번째 층에서부터 시작하여 매 Yi번째 층에서만 선다. 예를 들어 Xi = 4, Yi = 3이라면 i번 엘리베이터는 4층, 7층, 10층, …에서만 서게 된다.이 아파트 A층에서 사는 철수는 B층에 있는 친구 집에 놀러 가려고 한다. 그런데 가능하면 엘리베이터를 타는 횟수를 줄이고 싶어 한다.예를 들어 아파트가 총 12층이고, 엘리베이터가 3대 있으며, 각 엘리베이터가 다음과 같이 운행한다고 하자.10층에서 8층으로 가기 위해서는 1번 - 2번 - 3번 엘리베이터를 차례로 탈 수도 있고, 1번 - 3번 엘리베이터를 탈 수도 있다. 어떤 방법이든 최소 두 번 엘리베이터를 타야한다.N과 M 그리고 엘리베이터 운행 정보가 주어질 때 철수가 최소 몇 번 엘리베이터를 타야하는지와 타야할 엘리베이터의 순서를 구하는 프로그램을 작성하시오.첫째 줄에는 A층에서 B층으로 가기 위해 최소 몇 번 엘리베이터를 타야하는지를 출력한다. 다음 줄부터 타야하는 엘리베이터의 번호를 한 줄에 하나씩 타는 순서대로 출력한다. 또한 엘리베이터를 타는 방법이 여러 가지인 경우에는 그 중의 한 방법만을 출력한다. 만약 A층에서 B층으로 갈 수 없다면 첫째 줄에 -1을 출력한다.",16.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.8167327642440798,2593
/problem/16959,체스판 여행 1,"크기가 N×N인 체스판이 있고, 체스판의 각 칸에는 1부터 N2까지의 정수가 한 번씩 적혀있다. 지학이는 이 체스판을 이용해서 재미있는 게임을 해보려고 한다.지학이가 가지고 있는 말은 나이트, 비숍, 룩이다. 가장 먼저 1이 적혀있는 칸에 말 하나를 놓는다. 그 다음, 1, 2, ..., N2 순서로 이동시키려고 한다.먼저, 1에 나이트, 비숍, 룩 중 하나를 놓는다. 그 다음, 말을 이동시켜서 2가 적힌 칸으로 이동시킨다. 1에서 2로 이동시킬 때, 다른 수가 적힌 칸을 방문할 수도 있다. 그 다음에는 3이 적힌 칸으로 이동시키고, ..., N2이 적힌 칸으로 이동시킨다. 같은 칸을 여러 번 방문하는 것도 가능하다.지학이가 1초 동안 할 수 있는 행동은 체스판 위에 놓인 말을 이동시키거나, 다른 말로 바꾸는 것이다.1에서 출발해서, 2, 3, ..., N2-1을 방문하고, N2까지 도착하는데 걸리는 시간의 최솟값을 구해보자.첫째 줄에 문제에 주어진 대로 방문하는데 필요한 시간의 최솟값을 출력한다. ",16.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.8026462197303774,16959
/problem/5022,연결,"전기 회로에서 두 점을 전선으로 이을 때, 길이는 짧을 수록 좋다.크기가 N×M인 비어있는 회로판에서 두 점 A1과 A2, 그리고 B1와 B2를 전선을 이용해서 이으려고 한다. 전선은 항상 그리드의 수직, 수평선 위에 있어야 한다. 또, 두 직선은 접하면 안 된다. 이 경우에 필요한 전선의 길이의 최솟값을 구하는 프로그램을 작성하시오. 전선은 회로판 바깥으로 나갈 수 없다.A1과 A2, 그리고 B1과 B2를 연결하는데 필요한 전선의 길이의 최솟값을 출력한다. 만약, 불가능한 경우에는 ""IMPOSSIBLE""을 출력한다.",15.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.799958109855652,5022
/problem/1697,숨바꼭질,"수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.",10.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",기준,1697
/problem/13913,숨바꼭질 4,"수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.",12.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.9999998807907107,13913
/problem/12851,숨바꼭질 2,"수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 그리고, 가장 빠른 시간으로 찾는 방법이 몇 가지 인지 구하는 프로그램을 작성하시오.첫째 줄에 수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.",12.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.9870132207870486,12851
/problem/13549,숨바꼭질 3,"수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 0초 후에 2*X의 위치로 이동하게 된다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.",11.0,"0-1 너비 우선 탐색,너비 우선 탐색,데이크스트라,그래프 이론,그래프 탐색,",1.908378630293849,13549
/problem/17071,숨바꼭질 5,"수빈이는 동생과 숨바꼭질을 하고 있다. 수빈이는 현재 점 N(0 ≤ N ≤ 500,000)에 있고, 동생은 점 K(0 ≤ K ≤ 500,000)에 있다. 수빈이는 걷거나 순간이동을 할 수 있다. 만약, 수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동하게 된다. 동생은 항상 걷기만 한다. 동생은 항상 매 초마다 이동을 하며, 이동은 가속이 붙는다. 동생이 이동하는 거리는 이전에 이동한 거리보다 1을 더한 만큼 이동한다. 즉, 동생의 처음 위치는 K, 1초가 지난 후 위치는 K+1, 2초가 지난 후 위치는 K+1+2, 3초가 지난 후의 위치는 K+1+2+3이다.수빈이와 동생의 위치가 주어졌을 때, 수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오. 동생을 찾는 위치는 정수 좌표이어야 하고, 수빈이가 0보다 작은 좌표로, 50만보다 큰 좌표로 이동하는 것은 불가능하다.수빈이가 동생을 찾는 가장 빠른 시간을 출력한다. 수빈이가 동생을 찾을 수 없거나, 찾는 위치가 500,000을 넘는 경우에는 -1을 출력한다.",16.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.8826593756675722,17071
/problem/12761,돌다리,"동규와 주미는 일직선 상의 돌 다리 위에있다. 돌의 번호는 0 부터 100,000 까지 존재하고 동규는 \(N\)번 돌 위에, 주미는 \(M\)번 돌 위에 위치하고 있다. 동규는 주미가 너무 보고싶기 때문에 최대한 빨리 주미에게 가기 위해 \(A, B\) 만큼의 힘을 가진 스카이 콩콩을 가져왔다. 동규가 정한 다리를 건너는 규칙은 턴 방식인데, 한 턴에 이동할 수 있는 거리는 이러하다. 현 위치에서 +1칸, -1칸을 이동할 수 있고, 스카이 콩콩을 이용해 현 위치에서 \(A\)나 \(B\)만큼 좌우로 점프할 수 있으며, 순간적으로 힘을 모아 현 위치의 \(A\)배나 \(B\)배의 위치로 이동을 할 수 있다. 예를 들어 지금 동규가 7번 돌 위에 있고 스카이 콩콩의 힘이 8이면 그냥 점프를 해서 15번 돌에 갈 수도 있고, 순간적으로 힘을 모아 56번 돌에 갈 수도 있다는 것이다. 주어진 8가지의 방법 중 적절한 방법을 골라서 최대한 빨리 동규가 주미를 만날 수 있게 도와주자. 단, 이동 과정에서 100,000보다 크거나 0보다 작은 번호의 돌은 존재하지 않으므로 갈 수 없고, 같은 방법을 계속 사용해도 되며 항상 도달할 수 있는 케이스만 주어진다.동규가 주미에게 도달하기 위한 최소한의 이동 횟수를 출력하라.",10.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.8631440401077273,12761
/problem/4179,불!,"지훈이는 미로에서 일을 한다. 지훈이를 미로에서 탈출하도록 도와주자!미로에서의 지훈이의 위치와 불이 붙은 위치를 감안해서 지훈이가 불에 타기전에 탈출할 수 있는지의 여부, 그리고 얼마나 빨리 탈출할 수 있는지를 결정해야한다.지훈이와 불은 매 분마다 한칸씩 수평또는 수직으로(비스듬하게 이동하지 않는다)  이동한다. 불은 각 지점에서 네 방향으로 확산된다. 지훈이는 미로의 가장자리에 접한 공간에서 탈출할 수 있다. 지훈이와 불은 벽이 있는 공간은 통과하지 못한다.지훈이가 불이 도달하기 전에 미로를 탈출 할 수 없는 경우 IMPOSSIBLE 을 출력한다.",12.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.75041401386261,4179
/problem/1039,교환,"0으로 시작하지 않는 정수 N이 주어진다. 이때, M을 정수 N의 자릿수라고 했을 때, 다음과 같은 연산을 K번 수행한다.1 ≤ i < j ≤ M인 i와 j를 고른다. 그 다음, i번 위치의 숫자와 j번 위치의 숫자를 바꾼다. 이때, 바꾼 수가 0으로 시작하면 안 된다.위의 연산을 K번 했을 때, 나올 수 있는 수의 최댓값을 구하는 프로그램을 작성하시오.첫째 줄에 문제에 주어진 연산을 K번 했을 때, 만들 수 있는 가장 큰 수를 출력한다. 만약 연산을 K번 할 수 없으면 -1을 출력한다.",14.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.7427184581756594,1039
/problem/28333,화이트 칼라,"전미 최고의 사기꾼. 안 해본 도둑질, 안 해본 사기가 없는 닐 카프리는 오늘 저녁 세계 최고의 미술품 중 하나인 “뮤직박스”를 훔칠 예정이다.오늘 아침, 이 정보를 입수한 AdbyMe, Inc. 는 그를 검거하기 위한 작전을 세우고 있다. AdbyMe, Inc. 는 그가 현재 어느 도시에 있는지, 그리고 뮤직박스가 어느 도시에 있는지 파악했고, 그를 잡기 위해 직원들을 배치할 것이다. AdbyMe, Inc. 가 입수한 정보에 의하면 닐 카프리는 매우 급한 성격 (?)이고, 그의 성격으로 볼 때, 현재 위치에서 뮤직박스가 있는 곳까지 최단 경로로 이동할 것이다.그래서 AdbyMe, Inc. 는 현재 닐 카프리가 있는 도시와 뮤직박스가 있는 도시, 그리고 그가 이동할 때 거쳐갈 가능성이 있는 모든 도시에 직원들을 배치하려고 한다. 지도를 보고 직원들을 배치해야 되는 도시를 모두 골라내자.각 테스트 케이스에 대해 한 행에 하나씩 AdbyMe, Inc. 가 직원들을 배치해야하는 도시의 번호를 오름차순으로 출력한다.",12.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.7403529882431032,28333
/problem/14947,상자 배달,"택배 배달원인 박건은 택배를 손님 집으로 옮겨야 한다. 돈이 없는 박건은 직접 상자를 굴려서 옮기기로 했다.상자는 1×1×3모양이고 처음에는 1×1이 밑면인 상태다.최근 싱크홀이 많이 일어나서 땅에 구멍이 나있다. 상자를 구멍에 빠트리면 목표지점까지 옮길 수 없다. 1×3이 밑면일 때는 세 면 중 양 옆 모두 땅이 있거나 가운데에 땅이 있을 때에만 버틸 수 있다. 그 외의 경우에는 상자가 떨어져서 운반할 수가 없다.지도와 시작 위치, 도착지점이 주어져 있으면 상자를 최소 몇번 굴려서  목표지점까지 도달할 수 있는지 구하여라. 도착지점에서 상자가 꼭 서있을 필요는 없다. 어떤 면이든 도착지점에 닿기만 하면 된다. 하지만 상자가 굴러 떨어지면 안 된다. 박스는 밖으로 벗어나면 안 된다. 상자를 굴릴 때는 항상 어떤 변이 바닥과 붙어있어야 한다.목표지점까지 최소 몇번 옮길 수 있는지 출력해라. 만약 옮길 수 없으면 -2를 출력해라.",13.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.7363260984420779,14947
/problem/7562,나이트의 이동,체스판 위에 한 나이트가 놓여져 있다. 나이트가 한 번에 이동할 수 있는 칸은 아래 그림에 나와있다. 나이트가 이동하려고 하는 칸이 주어진다. 나이트는 몇 번 움직이면 이 칸으로 이동할 수 있을까?각 테스트 케이스마다 나이트가 최소 몇 번만에 이동할 수 있는지 출력한다.,10.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",기준,7562
/problem/16948,데스 나이트,"게임을 좋아하는 큐브러버는 체스에서 사용할 새로운 말 ""데스 나이트""를 만들었다. 데스 나이트가 있는 곳이 (r, c)라면, (r-2, c-1), (r-2, c+1), (r, c-2), (r, c+2), (r+2, c-1), (r+2, c+1)로 이동할 수 있다.크기가 N×N인 체스판과 두 칸 (r1, c1), (r2, c2)가 주어진다. 데스 나이트가 (r1, c1)에서 (r2, c2)로 이동하는 최소 이동 횟수를 구해보자. 체스판의 행과 열은 0번부터 시작한다.데스 나이트는 체스판 밖으로 벗어날 수 없다.첫째 줄에 데스 나이트가 (r1, c1)에서 (r2, c2)로 이동하는 최소 이동 횟수를 출력한다. 이동할 수 없는 경우에는 -1을 출력한다.",10.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.9410669803619387,16948
/problem/14271,그리드 게임,"크기가 무한대이고 단위 정사각형으로 나누어져있는 그리드가 있다. 그리드의 칸은 살아있거나 죽어있다.매초마다 모든 칸의 상태는 아래와 같은 규칙을 통해서 바뀐다.칸 C와 변을 인접한 네 개의 칸 중에서 적어도 한 칸이 살아있으면, C는 1초 후에도 살아있다. 그 외의 경우에는 죽어있다.모든 칸은 동시에 변한다.처음 그리드의 상태가 주어졌을 때, K초가 지난 후에 총 몇 개의 칸이 살아있는지 구하는 프로그램을 작성하시오.첫째 줄에 K초가 지난 후에 살아있는 칸의 개수를 출력한다.",11.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.9393760561943056,14271
/problem/16928,뱀과 사다리 게임,"뱀과 사다리 게임을 즐겨 하는 큐브러버는 어느 날 궁금한 점이 생겼다.주사위를 조작해 내가 원하는 수가 나오게 만들 수 있다면, 최소 몇 번만에 도착점에 도착할 수 있을까?게임은 정육면체 주사위를 사용하며, 주사위의 각 면에는 1부터 6까지 수가 하나씩 적혀있다. 게임은 크기가 10×10이고, 총 100개의 칸으로 나누어져 있는 보드판에서 진행된다. 보드판에는 1부터 100까지 수가 하나씩 순서대로 적혀져 있다.플레이어는 주사위를 굴려 나온 수만큼 이동해야 한다. 예를 들어, 플레이어가 i번 칸에 있고, 주사위를 굴려 나온 수가 4라면, i+4번 칸으로 이동해야 한다. 만약 주사위를 굴린 결과가 100번 칸을 넘어간다면 이동할 수 없다. 도착한 칸이 사다리면, 사다리를 타고 위로 올라간다. 뱀이 있는 칸에 도착하면, 뱀을 따라서 내려가게 된다. 즉, 사다리를 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 크고, 뱀을 이용해 이동한 칸의 번호는 원래 있던 칸의 번호보다 작아진다.게임의 목표는 1번 칸에서 시작해서 100번 칸에 도착하는 것이다.게임판의 상태가 주어졌을 때, 100번 칸에 도착하기 위해 주사위를 굴려야 하는 횟수의 최솟값을 구해보자.100번 칸에 도착하기 위해 주사위를 최소 몇 번 굴려야 하는지 출력한다.",11.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.9299654960632326,16928
/problem/12886,돌 그룹,"오늘 강호는 돌을 이용해 재미있는 게임을 하려고 한다. 먼저, 돌은 세 개의 그룹으로 나누어져 있으며 각각의 그룹에는 돌이 A, B, C개가 있다. 강호는 모든 그룹에 있는 돌의 개수를 같게 만들려고 한다.강호는 돌을 단계별로 움직이며, 각 단계는 다음과 같이 이루어져 있다.크기가 같지 않은 두 그룹을 고른다. 그 다음, 돌의 개수가 작은 쪽을 X, 큰 쪽을 Y라고 정한다. 그 다음, X에 있는 돌의 개수를 X+X개로, Y에 있는 돌의 개수를 Y-X개로 만든다.A, B, C가 주어졌을 때, 강호가 돌을 같은 개수로 만들 수 있으면 1을, 아니면 0을 출력하는 프로그램을 작성하시오.돌을 같은 개수로 만들 수 있으면 1을, 아니면 0을 출력한다.",12.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.925720036029816,12886
/problem/27453,귀엽기만 한 게 아닌 한별 양,"당신은 엄청난 불행 체질을 갖고 태어났다. 다행히 당신에게는 불행 체질을 받아내 주는 여자친구 한별이가 있다. 한별이는 운동신경이 매우 뛰어나 당신에게 닥치는 불상사들을 막아내주곤 한다. 하지만 그런 한별이에게도 한계가 있기에, 연속해서 너무 많은 불상사들이 생기는 경우에는 당신을 온전하게 지켜주지 못하게 된다.현재 당신과 한별이는 학교에서 집으로 귀가하고 있다. 마을은 $N\times M$ 형태의 격자 모양이며, 당신과 한별이는 격자에서 상하좌우로 인접한 칸으로만 이동할 수 있다. 단, 일부 칸에는 벽이 있어 이동할 수 없다. 또, 당신은 한별이에게 길치처럼 보이고 싶지 않기 때문에, 바로 직전에 방문한 칸으로 돌아가는 행동은 하지 않는다.오늘은 한별이가 당신의 집으로 놀러 가기로 한 날이기 때문에, 집으로 최대한 빨리 가려고 한다. 당신은 십수 년간의 경험을 바탕으로 마을의 각 좌표마다 일어나는 불상사의 개수를 미리 알아차릴 수 있다. 만약 가장 최근 지나온 $3$ 개 이하 칸에 있는 불상사의 개수 합이 $K$ 개를 넘으면, 한별이도 당신을 지켜주지 못해 부상을 입게 된다. 또, 당신의 불행 체질은 정말 엄청나기 때문에, 방문한 칸에 다시 방문하더라도 매번 같은 개수의 불상사가 다시 일어나게 된다. 과연 당신은 부상을 입지 않고 안전하게 귀가할 수 있을까?학교에서 집으로 안전하게 이동할 수 있을 때, 가능한 경로 중 최단 거리를 출력하시오. 만약 안전하게 귀가하지 못한다면 -1을 출력한다.",15.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.924783229827881,27453
/problem/16441,아기돼지와 늑대,"산으로 둘러싸인 고리분지에 사는 아기돼지 삼형제는 엄마돼지로부터 독립하여 새 집을 지으려 합니다.고리분지는 N × M 크기의 2차원 격자로 나타낼 수 있고 각 칸의 지형은 초원, 빙판, 산 중 하나입니다.고리분지에는 돼지가족들 뿐만 아니라 늑대들도 살고 있습니다. 늑대는 상하좌우 인접한 칸 중 산이 아닌 칸으로 이동할 수 있습니다. 만약 이동한 칸이 빙판이라면 초원을 밟거나 산에 부딪칠 때까지 이동한 방향으로 미끄러집니다. 산에 부딪친 경우 늑대는 빙판 위에 가만히 서있을 수 있고 다시 다른 방향으로 이동할 수 있습니다.게으른 아기돼지들은 지푸라기로 집을 지을 예정이기 때문에 늑대가 집이 있는 칸에 도착하기만 한다면 손쉽게 침입할 수 있습니다. 고리분지에 사는 늑대들이 도달할 수 없고 지형이 초원인 칸을 '안전한 곳'이라고 부릅니다. 게으른 아기돼지들을 위해 고리분지의 지도가 주어지면 지도 위에 모든 안전한 곳의 위치를 표시해주세요.입력으로 주어진 지도를 출력하되 아기돼지가 살 수 있는 초원은 문자 'P'로 대체하여 출력합니다.",13.0,"너비 우선 탐색,그래프 이론,그래프 탐색,",1.9225462675094607,16441
