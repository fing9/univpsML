내용링크,title,problem,level,분류,유사도,number
/problem/28278,스택 2,"정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.명령은 총 다섯 가지이다.1 X: 정수 X를 스택에 넣는다. (1 ≤ X ≤ 100,000)2: 스택에 정수가 있다면 맨 위의 정수를 빼고 출력한다. 없다면 -1을 대신 출력한다.3: 스택에 들어있는 정수의 개수를 출력한다.4: 스택이 비어있으면 1, 아니면 0을 출력한다.5: 스택에 정수가 있다면 맨 위의 정수를 출력한다. 없다면 -1을 대신 출력한다.출력을 요구하는 명령이 주어질 때마다 명령의 결과를 한 줄에 하나씩 출력한다.",7.0,"자료 구조,스택,",기준,28278
/problem/12789,도키도키 간식드리미,"인하대학교 학생회에서는 중간, 기말고사 때마다 시험 공부에 지친 학우들을 위해 간식을 나눠주는 간식 드리미 행사를 실시한다. 승환이는 시험 기간이 될 때마다 간식을 받을 생각에 두근두근 설레서 시험 공부에 집중을 못 한다. 이번 중간고사에서도 역시 승환이는 설레는 가슴을 안고 간식을 받기 위해 미리 공지된 장소에 시간 맞춰 도착했다. 그런데 이게 무슨 날벼락인가! 그 곳에는 이미 모든 학생들이 모여있었고, 승환이는 마지막 번호표를 받게 되었다. 설상가상으로 몇몇 양심에 털이 난 학생들이 새치기를 거듭한 끝에 대기열의 순서마저 엉망이 되고 말았다. 간식을 나눠주고 있던 인규는 학우들의 터져 나오는 불만에 번호표 순서로만 간식을 줄 수 있다고 말했다. 그제야 학생들이 순서대로 줄을 서려고 했지만 공간이 너무 협소해서 마음대로 이동할 수 없었다. 다행히도 대기열의 왼쪽에는 1열로 설 수 있는 공간이 존재하여 이 공간을 잘 이용하면 모두가 순서대로 간식을 받을 수 있을지도 모른다. 자칫 간식을 못 받게 될지도 모른다는 위기감을 느낀 승환이는 자신의 컴퓨터 알고리즘적 지식을 활용해 과연 모든 사람들이 순서대로 간식을 받을 수 있는지 확인하는 프로그램을 만들기로 했다. 만약 불가능 하다면 승환이는 이번 중간고사를 망치게 될 것 이고 가능하다면 힘을 얻어 중간고사를 잘 볼 수 있을지도 모른다.사람들은 현재 1열로 줄을 서있고, 맨 앞의 사람만 이동이 가능하다. 인규는 번호표 순서대로만 통과할 수 있는 라인을 만들어 두었다. 이 라인과 대기열의 맨 앞 사람 사이에는 한 사람씩 1열이 들어갈 수 있는 공간이 있다. 현재 대기열의 사람들은 이 공간으로 올 수 있지만 반대는 불가능하다. 승환이를 도와 프로그램을 완성하라.현재 간식 배부 공간을 그림으로 나타내면 다음과 같다.위 예제는 다음 그림과 같이 움직였을 때 모두가 순서대로 간식을 받을 수 있다..승환이가 무사히 간식을 받을 수 있으면 ""Nice""(따옴표는 제외)를 출력하고 그렇지 않다면 ""Sad""(따옴표는 제외)를 출력한다.",8.0,"자료 구조,스택,",1.918492078781128,12789
/problem/6198,옥상 정원 꾸미기,"도시에는 N개의 빌딩이 있다.빌딩 관리인들은 매우 성실 하기 때문에, 다른 빌딩의 옥상 정원을 벤치마킹 하고 싶어한다.i번째 빌딩의 키가 hi이고, 모든 빌딩은 일렬로 서 있고 오른쪽으로만 볼 수 있다.i번째 빌딩 관리인이 볼 수 있는 다른 빌딩의 옥상 정원은 i+1, i+2, .... , N이다.그런데 자신이 위치한 빌딩보다 높거나 같은 빌딩이 있으면 그 다음에 있는 모든 빌딩의 옥상은 보지 못한다.예) N=6, H = {10, 3, 7, 4, 12, 2}인 경우             =  =           =  =     -     =  =     =     =        -> 관리인이 보는 방향 =  -  =  =  =    =  =  =  =  =  = 10  3  7  4  12 2     -> 빌딩의 높이[1][2][3][4][5][6]    -> 빌딩의 번호1번 관리인은 2, 3, 4번 빌딩의 옥상을 확인할 수 있다.2번 관리인은 다른 빌딩의 옥상을 확인할 수 없다.3번 관리인은 4번 빌딩의 옥상을 확인할 수 있다.4번 관리인은 다른 빌딩의 옥상을 확인할 수 없다.5번 관리인은 6번 빌딩의 옥상을 확인할 수 있다.6번 관리인은 마지막이므로 다른 빌딩의 옥상을 확인할 수 없다.따라서, 관리인들이 옥상정원을 확인할 수 있는 총 수는 3 + 0 + 1 + 0 + 1 + 0 = 5이다.",11.0,"자료 구조,스택,",1.918059527873993,6198
/problem/10828,스택,"정수를 저장하는 스택을 구현한 다음, 입력으로 주어지는 명령을 처리하는 프로그램을 작성하시오.명령은 총 다섯 가지이다.push X: 정수 X를 스택에 넣는 연산이다.pop: 스택에서 가장 위에 있는 정수를 빼고, 그 수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.size: 스택에 들어있는 정수의 개수를 출력한다.empty: 스택이 비어있으면 1, 아니면 0을 출력한다.top: 스택의 가장 위에 있는 정수를 출력한다. 만약 스택에 들어있는 정수가 없는 경우에는 -1을 출력한다.출력해야하는 명령이 주어질 때마다, 한 줄에 하나씩 출력한다.",7.0,"자료 구조,구현,스택,",1.9168668342558473,10828
/problem/10799,쇠막대기,"여러 개의 쇠막대기를 레이저로 절단하려고 한다. 효율적인 작업을 위해서 쇠막대기를 아래에서 위로 겹쳐 놓고, 레이저를 위에서 수직으로 발사하여 쇠막대기들을 자른다. 쇠막대기와 레이저의 배치는 다음 조건을 만족한다.쇠막대기는 자신보다 긴 쇠막대기 위에만 놓일 수 있다. - 쇠막대기를 다른 쇠막대기 위에 놓는 경우 완전히 포함되도록 놓되, 끝점은 겹치지 않도록 놓는다.각 쇠막대기를 자르는 레이저는 적어도 하나 존재한다.레이저는 어떤 쇠막대기의 양 끝점과도 겹치지 않는다. 아래 그림은 위 조건을 만족하는 예를 보여준다. 수평으로 그려진 굵은 실선은 쇠막대기이고, 점은 레이저의 위치, 수직으로 그려진 점선 화살표는 레이저의 발사 방향이다.이러한 레이저와 쇠막대기의 배치는 다음과 같이 괄호를 이용하여 왼쪽부터 순서대로 표현할 수 있다.레이저는 여는 괄호와 닫는 괄호의 인접한 쌍 ‘( ) ’ 으로 표현된다. 또한, 모든 ‘( ) ’는 반드시 레이저를 표현한다.쇠막대기의 왼쪽 끝은 여는 괄호 ‘ ( ’ 로, 오른쪽 끝은 닫힌 괄호 ‘) ’ 로 표현된다. 위 예의 괄호 표현은 그림 위에 주어져 있다.쇠막대기는 레이저에 의해 몇 개의 조각으로 잘려지는데, 위 예에서 가장 위에 있는 두 개의 쇠막대기는 각각 3개와 2개의 조각으로 잘려지고, 이와 같은 방식으로 주어진 쇠막대기들은 총 17개의 조각으로 잘려진다. 쇠막대기와 레이저의 배치를 나타내는 괄호 표현이 주어졌을 때, 잘려진 쇠막대기 조각의 총 개수를 구하는 프로그램을 작성하시오.잘려진 조각의 총 개수를 나타내는 정수를 한 줄에 출력한다.",9.0,"자료 구조,스택,",1.9153209328651428,10799
/problem/1863,스카이라인 쉬운거,"도시에서 태양이 질 때에 보이는 건물들의 윤곽을 스카이라인이라고 한다. 스카이라인만을 보고서 도시에 세워진 건물이 몇 채인지 알아 낼 수 있을까? 건물은 모두 직사각형 모양으로 밋밋하게 생겼다고 가정한다.정확히 건물이 몇 개 있는지 알아내는 것은 대부분의 경우에 불가능하고, 건물이 최소한 몇 채 인지 알아내는 것은 가능해 보인다. 이를 알아내는 프로그램을 작성해 보자.첫 줄에 최소 건물 개수를 출력한다.",12.0,"자료 구조,스택,",1.9148277044296265,1863
/problem/1935,후위 표기식2,"후위 표기식과 각 피연산자에 대응하는 값들이 주어져 있을 때, 그 식을 계산하는 프로그램을 작성하시오.계산 결과를 소숫점 둘째 자리까지 출력한다.",8.0,"자료 구조,스택,",1.90414696931839,1935
/problem/6051,시간 여행,"모범생 현수는 코딩하는 시간을 늘리기 위해 타임 머신을 구매 했다. 현수는 정상적으로 문제를 코딩하거나 (타임 머신을 사용하지 않고), 과거의 임의의 지점으로 시간여행 할 수 있다.  미래로 시간 여행 할 수 없으며, 과거로 가면 새로운 미래가 진행된다.현수는 자유롭게 문제를 풀거나 과거로 돌아가면서 자신이 푼 문제 목록을 기록한다. 과거로 돌아가면 과거 이전까지 풀었던 문제 목록만 남는다.현수는  기록 되어 있는 문제 목록 중 가장 최근에 푼 문제 번호를 알고 싶다. (가장 최근에 푼 문제가 없다면 -1을 출력)매 쿼리마다 문제 목록에 기록되어 있는 가장 최근에 푼 문제를 출력하는 프로그램을 작성하시오.현수는 개인의 타임라인 관점에서 연속적인 업데이트를 나타내는  N (1 <= N <= 80,000) 개의 쿼리 Qi(1...N) 를 제공한다.각 쿼리는 한 줄의 입력이다. 각 줄은 하나의 문자 c ( 'a', 's', 't' 중 하나)로 시작한다. c가 'a'또는 't' 이면 c 다음에 공백과 정수 K가 주어진다. (1 <= K <= 1,000,000)c가 'a' 이면 현수는 문제 번호가 K인 문제를 풀고 문제 목록에 기록 한다.c가 's' 이면 현수는 가장 최근에 작성한 문제 목록을 삭제한다.c가 't'이면, 현수는 K 번째 쿼리 직전까지 시간을 거슬러 올라 간다. 즉, 현수는 K-1번째 쿼리와 K번째 쿼리 사이로 시간 여행한다. (입력을 위해 예제 입력 참조). K 쿼리  바로 전에 있던 푼 문제 목록으로 되돌아 간다.이해를 돕기 위해 아래에 푼 문제 목록과 12개의 쿼리, 각 쿼리에 대한 출력결과가 주어진다.  Q#   쿼리     문제목록      출력         참조 1   a 5  -> [5]         => 5        5번 문제를 목록에 기록 2   a 3  -> [5,3]       => 3        3번 문제를  목록에 기록 3   a 7  -> [5,3,7]     => 7        7번 문제를 목록에 기록 4   s    -> [5,3]       => 3        가장 최근 기록한 7를 목록에서 삭제 5   t 2  -> [5]         => 5        2번째 쿼리 직전으로 되돌아감 6   a 2  -> [5,2]       => 2        2번 문제를 목록에 기록 7   t 4  -> [5,3,7]     => 7        4번째 쿼리 직전으로 되돌아감 8   a 4  -> [5,3,7,4]   => 4        4번 문제를 목록에 기록 9   s    -> [5,3,7]     => 7        가장 최근 기록한 4를 목록에서 삭제10   t 7  -> [5,2]       => 2        7번째 쿼리 직전으로 되돌아감11   s    -> [5]         => 5        가장 최근 기록한 2를 목록에서 삭제12   s    -> []          => -1       가장 최근 기록한 5를 목록에서 삭제1부터 N번째 줄 : Qi 처리 후 목록에 기록 되어 있는 가장 최근에 푼 문제를 출력하시오 (가장 최근에 푼 문제가 없으면 -1).",14.0,"자료 구조,스택,",1.901781678199768,6051
/problem/3986,좋은 단어,"이번 계절학기에 심리학 개론을 수강 중인 평석이는 오늘 자정까지 보고서를 제출해야 한다. 보고서 작성이 너무 지루했던 평석이는 노트북에 엎드려서 꾸벅꾸벅 졸다가 제출 마감 1시간 전에 깨고 말았다. 안타깝게도 자는 동안 키보드가 잘못 눌려서 보고서의 모든 글자가 A와 B로 바뀌어 버렸다! 그래서 평석이는 보고서 작성을 때려치우고 보고서에서 '좋은 단어'나 세보기로 마음 먹었다.평석이는 단어 위로 아치형 곡선을 그어 같은 글자끼리(A는 A끼리, B는 B끼리) 쌍을 짓기로 하였다. 만약 선끼리 교차하지 않으면서 각 글자를 정확히 한 개의 다른 위치에 있는 같은 글자와 짝 지을수 있다면, 그 단어는 '좋은 단어'이다. 평석이가 '좋은 단어' 개수를 세는 것을 도와주자.첫째 줄에 좋은 단어의 수를 출력한다.",7.0,"자료 구조,스택,",1.8983711004257202,3986
/problem/15815,천재 수학자 성필,평행 세계의 성필은 숫자와 연산자를 만든 당대 최고의 수학자이다. 그리고 놀랍게도 이 숫자와 연산자는 현재 우리가 사용하는 것과 같다. 하지만 수식은 연산자가 피연산자 가운데 위치하는 우리와는 다르게 연산자가 피연산자 뒤에 위치한다고 한다.우리 세계의 식을 성필의 식으로 바꾸는 방법을 간단히 설명하자면 이렇다. 우선 주어진 식을 연산자의 우선순위에 따라 괄호로 묶어준다. 그런 다음에 괄호 안의 연산자를 괄호의 오른쪽으로 옮겨주면 된다.예를 들어 a+b*c는 (a+(b*c))의 식과 같게 된다. 그다음에 안에 있는 괄호의 연산자 *를 괄호 밖으로 꺼내게 되면 a+bc*가 된다. 마지막으로 또 +를 괄호의 오른쪽으로 고치면 abc*+가 되게 된다.천재 수학자 성필은 자신이 만든 이런 간단한 식조차 1초 안에 계산하지 못하는 사람들을 위하여 답을 구해주는 프로그램을 개발하려고 했지만 아쉽게도 성필의 세계에는 프로그래밍 언어가 없다. 프로그래밍을 할 수 있는 우리가 성필을 위해 평행세계의 식을 계산하는 프로그램을 만들어주자.입력으로 주어진 성필의 수식의 답을 첫째 줄에 출력한다.,8.0,"자료 구조,스택,",1.8877356052398682,15815
/problem/10773,제로,"나코더 기장 재민이는 동아리 회식을 준비하기 위해서 장부를 관리하는 중이다.재현이는 재민이를 도와서 돈을 관리하는 중인데, 애석하게도 항상 정신없는 재현이는 돈을 실수로 잘못 부르는 사고를 치기 일쑤였다.재현이는 잘못된 수를 부를 때마다 0을 외쳐서, 가장 최근에 재민이가 쓴 수를 지우게 시킨다.재민이는 이렇게 모든 수를 받아 적은 후 그 수의 합을 알고 싶어 한다. 재민이를 도와주자!재민이가 최종적으로 적어 낸 수의 합을 출력한다. 최종적으로 적어낸 수의 합은 231-1보다 작거나 같은 정수이다.",7.0,"자료 구조,구현,스택,",기준,10773
/problem/17952,과제는 끝나지 않아!,"성애는 이번 학기에 전공을 정말 많이 듣는다. 이로 인해 거의 매일을 과제를 하면서 보내고 있다. 그런데도 과제가 줄어들 기미가 보이지 않는데, 바로 분단위로 과제가 추가되고 있기 때문이다. 다행히 과제 제출 기한은 학기가 끝날 때까지이다. 너무나도 많은 과제를 하다가 미쳐버린 성애는 아래와 같은 규칙으로 과제를 해 나가고 있다.과제는 가장 최근에 나온 순서대로 한다. 또한 과제를 받으면 바로 시작한다.과제를 하던 도중 새로운 과제가 나온다면, 하던 과제를 중단하고 새로운 과제를 진행한다.새로운 과제가 끝났다면, 이전에 하던 과제를 이전에 하던 부분부터 이어서 한다. (성애는 기억력이 좋기 때문에 아무리 긴 시간이 지나도 본인이 하던 부분을 기억할 수 있다.)성애는 과제를 받자마자 이 과제가 몇 분이 걸릴지 정확하게 알 수 있고, 성애가 제출한 과제는 무조건 만점을 받는다.성애는 이번 학기에 자기가 받을 과제 점수를 예상해보고 싶다. 하지만 과제 점수를 예상하는 지금도 과제가 추가되고 있기에 여유를 부릴 수가 없다. 여러분이 성애가 받을 과제 점수를 구해주자!성애가 받을 과제 점수를 출력한다.",8.0,"자료 구조,구현,스택,",1.8817435503005984,17952
/problem/25497,기술 연계마스터 임스,"임스는 연계 기술을 사용하는 게임을 플레이 중에 있다. 연계 기술은 사전 기술과 본 기술의 두 개의 개별 기술을 순서대로 사용해야만 정상적으로 사용 가능한 기술을 말한다.하나의 사전 기술은 하나의 본 기술과만 연계해서 사용할 수 있으며, 연계할 사전 기술 없이 본 기술을 사용했을 경우에는 게임의 스크립트가 꼬여서 이후 사용하는 기술들이 정상적으로 발동되지 않는다. 그렇지만 반드시 사전 기술을 사용한 직후에 본 기술을 사용할 필요는 없으며, 중간에 다른 기술을 사용하여도 연계는 정상적으로 이루어진다.임스가 사용할 수 있는 기술에는 $1$~$9$, $L$, $R$, $S$, $K$가 있다. $1$~$9$는 연계 없이 사용할 수 있는 기술이고, $L$은 $R$의 사전 기술, $S$은 $K$의 사전 기술이다.임스가 정해진 순서대로 $N$개의 기술을 사용할 때, 기술이 몇 번이나 정상적으로 발동하는지를 구해보자.단, 연계 기술은 사전 기술과 본 기술 모두 정상적으로 발동되었을 때만 하나의 기술이 발동된 것으로 친다.임스가 정상적으로 기술을 사용한 총 횟수를 출력한다.",6.0,"자료 구조,구현,스택,",1.879314184188843,25497
/problem/17608,막대기,"아래 그림처럼 높이만 다르고 (같은 높이의 막대기가 있을 수 있음) 모양이 같은 막대기를 일렬로 세운 후, 왼쪽부터 차례로 번호를 붙인다. 각 막대기의 높이는 그림에서 보인 것처럼 순서대로 6, 9, 7, 6, 4, 6 이다. 일렬로 세워진 막대기를 오른쪽에서 보면 보이는 막대기가 있고 보이지 않는 막대기가 있다. 즉, 지금 보이는 막대기보다 뒤에 있고 높이가 높은 것이 보이게 된다. 예를 들어, 그림과 같은 경우엔 3개(6번, 3번, 2번)의 막대기가 보인다.N개의 막대기에 대한 높이 정보가 주어질 때, 오른쪽에서 보아서 몇 개가 보이는지를 알아내는 프로그램을 작성하려고 한다.오른쪽에서 N개의 막대기를 보았을 때, 보이는 막대기의 개수를 출력한다.",4.0,"자료 구조,구현,스택,",1.8660804033279421,17608
/problem/15926,현욱은 괄호왕이야!!,"여는 괄호 ‘(’와 닫는 괄호 ‘)’로 구성된 문자열에서 아래의 조건을 만족하는 문자열을 올바른 괄호 문자열이라고 부른다.() 는 올바른 괄호 문자열이다어떤 문자열 x가 올바른 괄호 문자열이라면, (x)도 올바른 괄호 문자열이다.어떤 문자열 x와 y가 올바른 괄호 문자열이라면, xy도 올바른 괄호 문자열이다.현욱은 친구로부터 생일 선물로 굉장히 긴 괄호 문자열을 받았다(도대체 왜 이런 걸 선물하는걸까?). 하지만 현욱은 올바른 괄호 문자열이 아니면 굉장히 싫어하기 때문에, 받은 괄호 문자열에서 연속한 일부분을 잘라서 올바른 괄호 문자열을 만들려고 한다. 그리고 이왕이면 긴 문자열이 좋으니 현욱은 부분 구간을 최대한 길게 잘라내려고 한다. 현욱을 도와 주어진 괄호 문자열에서 위의 조건을 만족하는 가장 긴 부분 문자열의 길이를 계산하는 프로그램을 작성해보자.주어진 문자열에서 길이가 가장 길면서 올바른 괄호 문자열인 부분 문자열의 길이를 출력한다. 올바른 괄호 문자열인 부분 문자열을 찾을 수 없는 경우 0을 출력한다.",13.0,"자료 구조,스택,",1.8324304176298707,15926
/problem/3345,괄호,"올바른 괄호 문자열을 다음과 같이 정의한다.()와 []는 올바른 괄호 문자열이다.A가 올바른 괄호 문자열이라면, (A)와 [A]도 올바른 괄호 문자열이다.A와 B가 올바른 괄호 문자열이라면, 두 문자열을 이어 붙인 AB도 올바른 괄호문자열이다.적어도 한 쌍의 대괄호([와 그것에 대응하는 ])를 포함하고 있는 올바른 괄호 문자열이 있을 때, 모든 대괄호를 (로 바꾼 문자열을 부서진 괄호 문자열이라 한다.예를 들어, ((와 ((((()))는 부서진 괄호 문자열이다. 첫 번째 문자열에서 올바른 괄호 문자열인 []를 얻을 수 있다. 두 번째 문자열은 다음과 같은 4가지 올바른 괄호 문자열을 얻을 수 있다. []((())), ([](())), (([]())), ((([]))). 부서진 괄호 문자열이 주어졌을 때, 여기서 얻을 수 있는 올바른 괄호 문자열의 개수를 구하는 프로그램을 작성하시오.첫째 줄에 입력으로 주어진 부서진 괄호 문자열에서 얻을 수 있는 올바른 괄호 문자열의 개수를 1,000,000,009로 나눈 나머지를 출력한다.",18.0,"다이나믹 프로그래밍,",기준,3345
/problem/3012,올바른 괄호 문자열,"여는 괄호와 닫는 괄호로만 이루어져 있으면서, 다음 규칙을 지키는 문자열을 올바른 괄호 문자열이라고 한다.빈 문자열은 올바른 괄호 문자열이다.A가 올바른 괄호 문자열이라면, (A), [A], {A}도 올바른 괄호 문자열이다.A와 B가 올바른 괄호 문자열이라면, AB도 올바른 괄호 문자열이다.예를 들어, [({})], [](){}, [{}]()[{}]는 올바른 괄호 문자열이다. 하지만, [({{)[, []({)}, [{}])([{}]는 올바른 괄호 문자열이 아니다.상근이는 책상 서랍에서 올바른 괄호 문자열을 적은 종이를 찾았다. 이 종이는 오래되었기 때문에, 일부 문자는 알아 볼 수 없었다.알아볼 수 없는 문자를 적절히 괄호로 바꿔서 만들 수 있는 올바른 괄호 문자열의 수를 구하는 프로그램을 작성하시오.첫째 줄에 만들 수 있는 올바른 괄호 문자열의 수를 출력한다. 개수가 다섯 자리를 넘어가는 경우에는 마지막 다섯 자리만 출력한다.",19.0,"다이나믹 프로그래밍,",1.9279700517654421,3012
/problem/17271,리그 오브 레전설 (Small),"규환이는 리그 오브 레전설이라는 게임을 좋아한다. 이 게임에서는 N초의 시간 동안 싸움을 하는데, 규환이가 플레이하는 캐릭터는 A, B 두 가지 스킬을 사용할 수 있다.  A 스킬의 시전 시간은 1초고, B 스킬의 시전 시간은 M초이다. 규환이는 다양한 스킬 조합을 원하기 때문에 가능한 모든 스킬 조합을 알아보고 싶어 한다. 단, 시전 시간 동안은 다른 스킬을 사용할 수 없으며, 스킬을 안 쓰고 있는 시간은 없어야 한다.예를 들어, N이 4초이고, M이 2초이면 가능한 스킬 조합은 AAAA, AAB, ABA, BAA, BB로 5가지가 가능하다.가능한 조합의 수를 1,000,000,007로 나눈 나머지 값을 출력한다.",9.0,"다이나믹 프로그래밍,",1.9253460168838503,17271
/problem/4198,열차정렬,"에린은 엔지니어이자, 기차를 운전하는 기관사입니다. 또한 그녀는 각 열차를 구성하는 차량을 배열하는 일도 합니다. 그녀는 차량들을 정렬할 때, 열차의 전면에 가장 무거운 차량을 놓고, 후미로 갈수록 중량이 감소하는 순서로 차량을 넣는 것을 좋아합니다.불행하게도, 차량을 배열하는 일은 쉽지 않습니다. 기존에 구성된 열차에 다른 차량을 끼워넣는 일은 비실용적이어서 하지 않기에, 한 차량은 오로지 열차의 전면 혹은 후미에만 추가하는 것이 가능합니다.차량들은 미리 준비된 순서에 따라 역에 도착합니다. 에린은 각 차량이 기차역에 도착할 때, 전면 혹은 후미에 차량을 추가하거나, 차량을 열차에 추가하는 것을 거부할 수 있습니다. 에린이 최종적으로 만든 열차는 가능한 길어야(많은 차량으로 구성되어야)하지만, 그 과정에서 열차는 에린이 배열하고자하는 정렬 순서에 맞아야 합니다.각 차량이 역에 도착하는 순서대로 차량들의 중량이 주어질 때, 에린이 만들 수 있는 가장 긴 열차배열의 길이(=차량의 수)는 얼마입니까?에린이 만들 수 있는 가장 긴 열차의 길이를 출력하세요.",15.0,"다이나믹 프로그래밍,",1.9228504896163943,4198
/problem/2335,농부,"여러 개의 정원과 여러 개의 이랑(일렬로 나무나 곡식을 심는 길쭉한 길)을 소유한 한 농부가 있다. 정원의 경계는 사이프러스 나무로 둘러싸여 있으며, 각 이랑에도 사이프러스 나무가 심어져 있다. 또한 정원과 이랑 모두, 두 사이프러스 나무 사이에는 올리브 나무가 한 그루 심어져 있다. 이런 식으로 농부의 모든 사이프러스 나무는 정원을 둘러싸거나 이랑을 따라 심어져 있으며, 사이프러스 나무 두 그루 사이에는 반드시 올리브 나무가 한 그루 끼여 있다.그러던 어느 날, 농부는 심한 병에 걸려 임종을 앞두게 되었다. 숨을 거두기 며칠 전, 그는 맏아들에게 이렇게 말했다. ""내 정원과 이랑에 심어진 사이프러스 나무들을 아무 거나 Q 그루 골라라. 그러면 그 나무들과, 두 나무 사이에 심겨져 있는 올리브 나무까지 모두 네게 주겠다.""아버지의 유언에 따라 아들은 정원 경계나 이랑에서 연속하는 구간을 하나 이상 선택하여 사이프러스 나무를 최대 Q 그루까지 얻을 수 있고, 그 사이에 있는 올리브 나무들도 얻을 수 있다. 아들은 올리브를 매우 좋아하기 때문에 올리브 나무를 가장 많이 얻을 수 있는 구간을 선택하고 싶어 한다.정원 1 (13그루)정원 2 (4그루)정원 3 (8그루)이랑 1 (4그루)이랑 2 (8그루)이랑 3 (6그루)농부에게 정원과 이랑이 세 개씩 있고, 사이프러스 나무가 각 곳에 위의 그림과 같이 있다고 가정하자. (사이프러스 나무 사이에 있는 올리브 나무는 편의상 표기하지 않았다) 그리고 Q=17그루의 사이프러스 나무를 물려받을 수 있다고 하자. 그렇다면 아들은 정원 1과 2에 있는 사이프러스 나무만을 모두 선택하면 된다. 정원은 이랑과는 달리 고리를 이루고 있기 때문에, 그 안에 있는 17그루의 올리브 나무를 모두 물려받을 수 있기 때문이다.밭과 이랑에 있는 나무 수와 물려받을 수 있는 나무의 수를 입력으로 받아, 아들이 물려받을 수 있는 올리브 나무의 최대 수를 구하는 프로그램을 작성하시오.아들이 덤으로 받을 수 있는 올리브 나무의 최대 그루 수를 출력한다.",13.0,"다이나믹 프로그래밍,",1.9162880182266238,2335
/problem/1099,알 수 없는 문장,"형택이와 그의 친구들은 자꾸 다른 사람들이 대화를 엿듣는 것이 짜증났다. 따라서, 새로운 언어를 만들었다.이 언어에는 단어가 N개 있다. 그리고 이 언어의 문장은 단어를 공백없이 붙여쓴 것이다. 이 문장에서 각 단어는 0번 또는 그 이상 나타날 수 있다. 이 언어가 형택스러운 이유는 (특별한 이유는) 단어에 쓰여 있는 문자의 순서를 바꿔도 되기 때문이다. 이때, 원래 단어의 위치와 다른 위치에 있는 문자의 개수 만큼이 그 순서를 바꾼 단어를 만드는 비용이다. 예를 들어, abc란 단어가 있을 때, abc는 비용 0으로 만들 수 있고, acb, cba, bac는 비용 2로 바꿀 수 있고, bca, cab는 비용 3으로 바꿀 수 있다.따라서, 한 문장을 여러 가지 방법으로 해석할 수 있다. 이때 비용의 최솟값을 구하는 프로그램을 작성하시오.첫째 줄에 문제의 정답을 출력한다. 만약 문장을 해석할 수 없다면 -1을 출력한다.",13.0,"다이나믹 프로그래밍,",1.9137747287750246,1099
/problem/20367,3 Slot Matching,"무수히 넓은 우주에서는 한 국가의 영역을 결정하기 위해, 특이한 땅따먹기 게임을 한다고 전해진다. 이 게임은 N개의 막대쌍과 3개의 슬롯을 가지고 진행된다. 막대쌍은 위아래로 차례로 쌓여있으며, 맨 위의 막대쌍을 제외한 다른 막대기는 건드릴 수 없다.참가자는 아래 2가지 중 하나를 선택하여 행동하는 것을 원하는 만큼 반복할 수 있다.맨 위에 있는 막대쌍 하나를 가져와 비어있는 슬롯에 보관한다.슬롯에 보관되어 있는 막대쌍 두 개를 꺼내어, 각 막대기를 변으로 하는 직사각형을 만들고 그 직사각형으로 둘러쌓인 공간을 영역으로 인정받는다.그렇게 만들어진 모든 직사각형 영역의 넓이의 합이 그 국가의 면적이 된다. 맨 위에 있는 막대쌍을 슬롯에 넣지 않고 버리거나, 슬롯에 있는 막대쌍을 임의로 버릴 수 없다. 모든 행동은 주어진 선택지 두 가지 중 하나여야 한다.이번에는 희권국의 영역을 결정할 차례이다. 희권이가 N개의 막대쌍의 순서와 길이를 전부 알고 있다고 할 때, 희권국이 인정받을 수 있는 영역의 총면적의 최댓값은 얼마일까?희권국이 인정받을 수 있는 영역의 총면적의 최댓값을 나타내는 정수를 출력하시오.",16.0,"다이나믹 프로그래밍,",1.9135851263999941,20367
/problem/6116,케이크,"나코더 회원들은 재민이의 생일을 축하하기 위해, 열심히 생일 케이크를 만들고 있다.케이크를 만들기 위해서 현재 길이 Wi, 높이 1인 빵조각이 1 ~ N 순서대로 만들어지고 있다. 나코더 회원들은 이 빵조각들을 모두 쌓아서 (버리면 안 된다) 층층이 케이크를 만들고자 한다.케이크는 여러 층으로 구성될 수 있는데, 한 층의 길이는 그 층에 있는 빵조각의 길이의 합이며, 위에 있는 층의 길이가 아래에 있는 층의 길이보다 클 수 없다. (그러면, 케익이 무너지고 말 것이다!)또한, 나중에 만들어진 빵조각은 전에 만들어진 빵조각보다 낮은 층에 올라갈 수 없다.이를 만족하는 선에서 최대한의 높이로 케익을 쌓고자 할때, 과연 몇층까지 쌓을 수 있을까?가장 높은 케이크의 크기를 출력하라.",20.0,"다이나믹 프로그래밍,",1.9133428335189822,6116
/problem/16399,드라이브,"기섭이는 여자친구와 여행을 하기 위해 운전면허를 따고 새 차를 샀다. 하지만, 그녀한테 차였다. 우울한 기섭이는 기분을 풀기 위해 드라이브를 나가려고 한다.기섭이의 집에서 드라이브 목적지까지 총 거리를 D km라고 하자. 기섭이가 산 차량은 연료 용량이 C 리터이고, 연비가 E (L/1 km) 로 정해져 있어, 집에서 목적지까지 한 번에 도달하지 못 할 수 있다. 다행히 목적지와 집 사이에는 각 주유소마다 S1, S2, …, SN(km) 거리만큼 떨어진 N개의 주유소가 존재한다.(단, S1은 첫 번째 주유소와 집 사이의 거리). 각 주유소에서 파는 기름의 가격은 주유소마다 다를 수 있다.차를 사느라 돈을 많이 쓴 기섭이는 최소한의 비용으로 목적지까지 가려고 한다. 기섭이를 위해 목적지까지 가기 위한 최소비용을 구해주자.기섭이가 집에서 출발할 때 연료는 가득 차 있다고 한다.목적지까지 가는데 필요한 기름값의 최소비용을 출력한다.",16.0,"다이나믹 프로그래밍,",1.9132320880889895,16399
/problem/12762,롤러코스터,"롤러코스터의 하이라이트는 내리막을 쭉 내려와서 다시 올라오는 순간일 것이다. 롤러코스터 설계자인 영창이는 이런 하이라이트 구간을 가장 좋아한다.영창이는 하이라이트 구간이 길수록 재미있는 롤러코스터이고, 재밌을수록 이용객이 많을 것으로 생각했다.새로 짓기엔 경제적 부담이 큰 영창이는 철골 기둥만 남은 중고 롤러코스터를 사서 개조하기로 했다.그런데 이 구간에서 얼마나 긴 하이라이트 구간이 나올지를 모를 지경이던 영창이는 열혈 프로그래머 승균이에게 도움을 청하고자 한다.우선 영창이는 개조하고자 하는 구간에 있는 각 기둥의 높이를 수치화했다. 이를 통해 하이라이트 구간을 만들려고 한다.하지만 기둥을 옮기는 비용이 무척 비싸서 세워진 기둥을 최대한으로 남기는 방식으로 공사를 진행하려 한다.예를 들면, 어떤 구간에 기둥의 높이들이 4 3 5 1 4 2 3 이라면, 높이가 5인 세 번째 기둥과 4인 다섯 번째 기둥을 제거한다면, 4, 3, 1, 2, 3인 기둥만 남아서 가장 긴 하이라이트 구간을 만들 수 있다.하이라이트 구간으로 만들기 위해 최대한으로 남길 수 있는 기둥의 개수를 구하는 프로그램을 작성하시오.단, 하이라이트 구간에 다시 올라오는 구간은 없을 수 있다. 그리고 롤러코스터의 진행 방향은 공사가 끝난 후 결정된다.매끄러운 경사를 위해 연속적으로 높이가 같은 기둥은 없어야 하며, 하이라이트 구간이 나올 수 없는 경우에는 가장 높은 기둥만 남긴다.하이라이트 구간으로 만들기 위해 최대한으로 남길 수 있는 기둥의 개수를 출력한다.",12.0,"다이나믹 프로그래밍,",1.9127140641212466,12762
/problem/4949,균형잡힌 세상,"세계는 균형이 잘 잡혀있어야 한다. 양과 음, 빛과 어둠 그리고 왼쪽 괄호와 오른쪽 괄호처럼 말이다.정민이의 임무는 어떤 문자열이 주어졌을 때, 괄호들의 균형이 잘 맞춰져 있는지 판단하는 프로그램을 짜는 것이다.문자열에 포함되는 괄호는 소괄호(""()"") 와 대괄호(""[]"")로 2종류이고, 문자열이 균형을 이루는 조건은 아래와 같다.모든 왼쪽 소괄호(""("")는 오른쪽 소괄호("")"")와만 짝을 이뤄야 한다.모든 왼쪽 대괄호(""["")는 오른쪽 대괄호(""]"")와만 짝을 이뤄야 한다.모든 오른쪽 괄호들은 자신과 짝을 이룰 수 있는 왼쪽 괄호가 존재한다.모든 괄호들의 짝은 1:1 매칭만 가능하다. 즉, 괄호 하나가 둘 이상의 괄호와 짝지어지지 않는다.짝을 이루는 두 괄호가 있을 때, 그 사이에 있는 문자열도 균형이 잡혀야 한다.정민이를 도와 문자열이 주어졌을 때 균형잡힌 문자열인지 아닌지를 판단해보자.각 줄마다 해당 문자열이 균형을 이루고 있으면 ""yes""를, 아니면 ""no""를 출력한다.",7.0,"자료 구조,스택,문자열,",기준,4949
/problem/27497,알파벳 블록,스타는 알파벳 블록을 일렬로 조립하여 문자열을 만드는 게임을 만들었다. 각 블록에는 문자 하나가 적혀 있으며 게임에는 각각 다음 기능을 수행하는 세 개의 버튼이 있다.문자열 맨 뒤에 블록 추가문자열 맨 앞에 블록 추가문자열을 구성하는 블록 중 가장 나중에 추가된 블록 제거게임은 처음에 빈 문자열로 시작하며 빈 문자열일 때 문자열을 구성하는 블록 중 가장 나중에 추가된 블록을 제거하는 버튼을 누를 경우 아무런 동작도 하지 않는다. 버튼을 누른 횟수와 누른 버튼이 순서대로 주어질 때 완성된 문자열을 구하여라.완성된 문자열을 출력한다. 완성된 문자열이 빈 문자열인 경우 0을 출력한다.,9.0,"자료 구조,덱,스택,문자열,",1.8942149877548218,27497
/problem/9935,문자열 폭발,"상근이는 문자열에 폭발 문자열을 심어 놓았다. 폭발 문자열이 폭발하면 그 문자는 문자열에서 사라지며, 남은 문자열은 합쳐지게 된다.폭발은 다음과 같은 과정으로 진행된다.문자열이 폭발 문자열을 포함하고 있는 경우에, 모든 폭발 문자열이 폭발하게 된다. 남은 문자열을 순서대로 이어 붙여 새로운 문자열을 만든다.새로 생긴 문자열에 폭발 문자열이 포함되어 있을 수도 있다.폭발은 폭발 문자열이 문자열에 없을 때까지 계속된다.상근이는 모든 폭발이 끝난 후에 어떤 문자열이 남는지 구해보려고 한다. 남아있는 문자가 없는 경우가 있다. 이때는 ""FRULA""를 출력한다.폭발 문자열은 같은 문자를 두 개 이상 포함하지 않는다.첫째 줄에 모든 폭발이 끝난 후 남은 문자열을 출력한다.",12.0,"자료 구조,스택,문자열,",1.8745301961898804,9935
/problem/18241,문자열 게임,"문자열 게임이 있다. 게임의 진행 방식은 아래와 같다.알파벳 소문자로 이루어진 문자열 W가 주어진다.알파벳 소문자로 이루어진 문자열 S가 주어진다.문자열 S에서 문자열 W를 모두 제거하는 사람이 승리한다.병서는 문자열 W를 모두 제거하기 위해 프로그램을 만들려고 한다.병서가 구상한 프로그램은 아래의 명령 중 주어진 명령을 수행하는 작업을 N번 반복한다.L : 문자열 S의 왼쪽에서부터 처음으로 등장하는 문자열 W를 찾아, S에서 해당 부분문자열을 제거한다.R : 문자열 S의 오른쪽에서부터 처음으로 등장하는 문자열 W를 찾아, S에서 해당 부분문자열을 제거한다.명령을 수행할 때, 제거해야 하는 문자열 W가 없다면 명령을 실패하고, 아무 일도 일어나지 않는다.병서를 위해 N개의 명령에 따라 문자열 S에서 문자열 W를 제거하는 프로그램을 제작해주자!첫 번째 줄에 성공한 명령의 개수를, 두 번째 줄에 프로그램을 실행한 후의 문자열 S를 출력한다.",18.0,"자료 구조,덱,구현,스택,문자열,",1.8715047194583356,18241
/problem/3111,검열,"김상근은 창영마을에서의 권력을 유지하기 위해 신문을 검열하려고 한다.상근이는 텍스트 T에서 A라는 단어를 다음과 같은 알고리즘을 이용해서 모두 없애려고 한다.T에 A가 없으면 알고리즘을 종료한다.T에서 처음 등장하는 A를 찾은 뒤, 삭제한다.T에 A가 없으면 알고리즘을 종료한다.T에서 마지막으로 등장하는 A를 찾은 뒤, 삭제한다.1번으로 돌아간다.상근이는 마을을 지배해야하기 때문에, 검열을 할 시간이 없다. 상근이의 검열을 대신해주는 프로그램을 작성하시오.검열을 한 이후의 텍스트를 출력한다.",17.0,"자료 구조,덱,구현,스택,문자열,",1.8410726143939435,3111
/problem/17413,단어 뒤집기 2,"문자열 S가 주어졌을 때, 이 문자열에서 단어만 뒤집으려고 한다.먼저, 문자열 S는 아래와과 같은 규칙을 지킨다.알파벳 소문자('a'-'z'), 숫자('0'-'9'), 공백(' '), 특수 문자('<', '>')로만 이루어져 있다.문자열의 시작과 끝은 공백이 아니다.'<'와 '>'가 문자열에 있는 경우 번갈아가면서 등장하며, '<'이 먼저 등장한다. 또, 두 문자의 개수는 같다.태그는 '<'로 시작해서 '>'로 끝나는 길이가 3 이상인 부분 문자열이고, '<'와 '>' 사이에는 알파벳 소문자와 공백만 있다. 단어는 알파벳 소문자와 숫자로 이루어진 부분 문자열이고, 연속하는 두 단어는 공백 하나로 구분한다. 태그는 단어가 아니며, 태그와 단어 사이에는 공백이 없다.첫째 줄에 문자열 S의 단어를 뒤집어서 출력한다.",8.0,"자료 구조,구현,스택,문자열,",1.8360332204921186,17413
/problem/11899,괄호 끼워넣기,"심심한 승현이는 너무 심심한 나머지 올바른 괄호열을 가지고 놀고 있었습니다.(()(()))()()그러다가 어쩌다 보니 괄호열을 부러뜨렸습니다.(()    ((    )))()    ()크게 낙담한 승현이는 노력해 보았지만, 대부분이 부러져 버려 단 한 부분만 재사용할 수 있다는 것을 깨닫게 되었습니다.)))()승현이는 이 괄호열을 가지고 놀려고 했으나 올바른 괄호열이 아니기 때문에 행복하지 않았습니다. 이를 보던 지학이는 승현이에게 “그러면 앞과 뒤에 적절하게 괄호를 붙이면 올바른 괄호열이 되지 않을까?”라고 했고, 승현이는 조금 생각한 뒤 그렇게 하기로 했습니다. 예를 들어, 위의 올바르지 않은 괄호열의 경우 앞에 여는 괄호 3개를 붙이면 올바른 괄호열이 됩니다.((()))()그러나 괄호열을 사서 붙이는 데에는 돈이 들고 많이 붙일수록 놀기가 불편해지기 때문에, 승현이는 가능한 한 괄호열을 적게 추가하려고 합니다.승현이가 망가뜨리고 사용 가능한 올바르지 않은 괄호열이 주어질 때, 올바른 괄호열으로 만들기 위해 앞과 뒤에 붙여야 할 괄호의 최소 개수를 구하는 프로그램을 작성하세요.첫 번째 줄에 S를 올바른 괄호열으로 만들기 위해 앞과 뒤에 붙여야 할 괄호의 최소 개수를 출력합니다. 불가능한 경우는 주어지지 않습니다.",8.0,"자료 구조,스택,문자열,",1.8147096037864685,11899
/problem/3015,오아시스 재결합,"오아시스의 재결합 공연에 N명이 한 줄로 서서 기다리고 있다.	이 역사적인 순간을 맞이하기 위해 줄에서서 기다리고 있던 백준이는 갑자기 자기가 볼 수 있는 사람의 수가 궁금해 졌다.	두 사람 A와 B가 서로 볼 수 있으려면, 두 사람 사이에 A 또는 B보다 키가 큰 사람이 없어야 한다.	줄에 서있는 사람의 키가 주어졌을 때, 서로 볼 수 있는 쌍의 수를 구하는 프로그램을 작성하시오.	서로 볼 수 있는 쌍의 수를 출력한다.",16.0,"자료 구조,스택,",1.7986748589036274,3015
