내용링크,제목,문제,level,분류,유사도
/problem/27433,팩토리얼 2,"0보다 크거나 같은 정수 N이 주어진다. 이때, N!을 출력하는 프로그램을 작성하시오.첫째 줄에 N!을 출력한다.",1.0,"사칙연산,수학,",기준
/problem/27439,팩토리얼 4,"0보다 크거나 같은 정수 N이 주어진다. 이때, N!을 출력하는 프로그램을 작성하시오.첫째 줄에 N!을 출력한다.",14.0,"사칙연산,수학,",2.0
/problem/6376,e 계산,"e는\[e=\sum_{i=0}^{n} {\frac{1}{i!}}\]이다. 여기서 n은 무한대이다.매우 작은 n에 대해서, e의 근사값을 구해보자.아래 결과와 같은 형식으로 e의 근사값을 n = 0부터 9까지 출력한다. ",4.0,"사칙연산,수학,",1.798025369644165
/problem/2097,조약돌,"당신은 N개의 조약돌을 가지고 있다. 이 조약돌을 좌표평면의 격자점 위에 아무렇게나 떨어뜨렸다. 격자점이란, x좌표와 y좌표 모두가 정수인 지점을 말한다. 이를테면 (1, 1)이나 (0, -9)는 격자점이며, (-2, 3.5)이나 (π, 7.14)는 격자점이 아니다.모든 조약돌을 포함하는 가장 작은 직사각형을 생각할 수 있다. 예를 들어 세 개의 조약돌을 (2,4), (4, 8), (5,5)에 떨어뜨렸다면, 이 세 조약돌을 모두 포함하는 가장 작은 직사각형은 가로 3, 세로 4인 직사각형이다. 이 경우 직사각형의 둘레는 14가 된다. 직사각형의 가로와 세로 길이는 반드시 1 이상이어야 한다.조약돌의 개수 N이 주어졌을 때, 조약돌을 좌표평면의 격자점에 적절히 떨어뜨려서 모든 조약돌을 포함하는 직사각형의 둘레를 최소로 하는 프로그램을 작성하시오.첫째 줄에 최소 둘레를 출력한다.",6.0,"사칙연산,수학,",1.7940202951431274
/problem/11024,더하기 4,"수 N개가 주어졌을 때, N개의 합을 구하는 프로그램을 작성하시오.각 테스트 케이스마다 입력받은 수 N개의 합을 한 줄에 하나씩 입력받은 순서대로 출력한다.",3.0,"사칙연산,수학,",1.779309868812561
/problem/2163,초콜릿 자르기,"정화는 N×M 크기의 초콜릿을 하나 가지고 있다. 초콜릿은 금이 가 있는 모양을 하고 있으며, 그 금에 의해 N×M개의 조각으로 나눠질 수 있다.초콜릿의 크기가 너무 크다고 생각한 그녀는 초콜릿을 친구들과 나눠 먹기로 했다. 이를 위해서 정화는 초콜릿을 계속 쪼개서 총 N×M개의 조각으로 쪼개려고 한다. 초콜릿을 쪼갤 때에는 초콜릿 조각을 하나 들고, 적당한 위치에서 초콜릿을 쪼갠다. 초콜릿을 쪼갤 때에는 금이 가 있는 위치에서만 쪼갤 수 있다. 이와 같이 초콜릿을 쪼개면 초콜릿은 두 개의 조각으로 나눠지게 된다. 이제 다시 이 중에서 초콜릿 조각을 하나 들고, 쪼개는 과정을 반복하면 된다.초콜릿을 쪼개다보면 초콜릿이 녹을 수 있기 때문에, 정화는 가급적이면 초콜릿을 쪼개는 횟수를 최소로 하려 한다. 초콜릿의 크기가 주어졌을 때, 이를 1×1 크기의 초콜릿으로 쪼개기 위한 최소 쪼개기 횟수를 구하는 프로그램을 작성하시오.첫째 줄에 답을 출력한다.",5.0,"사칙연산,수학,",1.7337566018104553
/problem/28061,레몬 따기,"성우는 숲에서 레몬을 따와야 한다. 숲은 하나의 수직선으로 표현할 수 있고, 여기에는 레몬 나무 \(N\)그루가 \(x=1\)부터 \(x=N\)까지 일정한 간격으로 자라 있다. 성우는 현재 \(x=0\)에 있으며, 집은 \(x=N+1\)에 있다. \(x=i\)에 위치한 나무에는 \(a_i\)개의 레몬이 자라 있다. 성우는 집에 돌아갈 때까지 매번 다음 중 하나를 선택하여 행동한다.채집: 나무에 자라있는 레몬을 모두 딴다. 이 행동은 최대 한 번 할 수 있다.이동: 현재 위치가 \(x=i\)라면, \(x=i+1\)로 이동한다.하지만 레몬을 담을 보따리에는 구멍이 뚫려 있었다. 성우가 이동(행동 2)할 때마다, 보따리에 레몬이 담겨 있다면 보따리에 담긴 레몬이 \(1\)개 빠져나오고, 이는 다시 주울 수 없다. 성우가 집에 들고 갈 수 있는 레몬의 최대 개수를 구해주자!성우가 집에 들고 갈 수 있는 레몬의 최대 개수를 출력한다.",3.0,"사칙연산,수학,",1.72734797000885
/problem/13458,시험 감독,"총 N개의 시험장이 있고, 각각의 시험장마다 응시자들이 있다. i번 시험장에 있는 응시자의 수는 Ai명이다.감독관은 총감독관과 부감독관으로 두 종류가 있다. 총감독관은 한 시험장에서 감시할 수 있는 응시자의 수가 B명이고, 부감독관은 한 시험장에서 감시할 수 있는 응시자의 수가 C명이다.각각의 시험장에 총감독관은 오직 1명만 있어야 하고, 부감독관은 여러 명 있어도 된다.각 시험장마다 응시생들을 모두 감시해야 한다. 이때, 필요한 감독관 수의 최솟값을 구하는 프로그램을 작성하시오.각 시험장마다 응시생을 모두 감독하기 위해 필요한 감독관의 최소 수를 출력한다.",4.0,"사칙연산,수학,",1.7269583940505981
/problem/14652,나는 행복합니다~,"“나는 행복합니다~ 한화라서 행복합니다~”행복한 이 노래 가사! 그렇다. 욱제는 한화 이글스의 열렬한 이다. 욱제는 여름방학을 맞아 치킨과 맥주를 챙겨 야구장을 방문했다! 하지만 이게 웬걸? 치맥에 정신이 팔린 욱제는 그만 자신의 관중석 위치가 담긴 티켓을 잃어버리고 말았다. 욱제가 유일하게 기억하는 것이라고는 자신의 관중석 번호 K뿐이다.당신은 한화 이글스의 감독이다. 열혈인 욱제의 방문에 깊은 감동을 받은 당신은 욱제가 잃어버린 자리를 찾아주려고 한다. 오늘 경기가 펼쳐지는 잠실구장은 세로 길이가 N, 가로 길이가 M인 N≤M 크기의 관중석을 가지고 있다. 관중석의 왼쪽 위는 (0, 0), 오른쪽 아래는 (N-1, M-1)으로 표시된다. 각 관중석에는 번호가 아래 그림처럼 매겨져있다. (0, 0)에서부터 0번으로 시작하여 오른쪽으로, 끝에 다다르면 그 아래에서 또 오른쪽으로 숫자가 증가해나가는 식이다.당신은 관중석의 크기와 욱제 자리의 번호를 알고 있다. 욱제가 잃어버린 자리는 어디일까? 자리를 찾아서 욱제에게 알려주도록 하자!욱제의 잃어버린 자리를 찾아서, 잃어버린 자리의 좌표 (n, m)를 하나의 공백을 사이에 두고 숫자만 출력한다.",1.0,"사칙연산,수학,",1.7220337390899658
/problem/4504,배수 찾기,"정수 n(0 < n < 1000)과 수의 목록이 주어졌을 때, 목록에 들어있는 수가 n의 배수인지 아닌지를 구하는 프로그램을 작성하시오.목록에 있는 수가 n의 배수인지 아닌지를 구한 뒤 예제 출력처럼 출력한다.",3.0,"사칙연산,수학,",1.7103744745254517
/problem/10870,피보나치 수 5,"피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.n=17일때 까지 피보나치 수를 써보면 다음과 같다.0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.첫째 줄에 n번째 피보나치 수를 출력한다.",4.0,"구현,수학,",기준
/problem/2747,피보나치 수,"피보나치 수는 0과 1로 시작한다. 0번째 피보나치 수는 0이고, 1번째 피보나치 수는 1이다. 그 다음 2번째 부터는 바로 앞 두 피보나치 수의 합이 된다.이를 식으로 써보면 Fn = Fn-1 + Fn-2 (n ≥ 2)가 된다.n=17일때 까지 피보나치 수를 써보면 다음과 같다.0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597n이 주어졌을 때, n번째 피보나치 수를 구하는 프로그램을 작성하시오.첫째 줄에 n번째 피보나치 수를 출력한다.",4.0,"구현,수학,",2.0
/problem/15876,Binary Counting,"’이진수’라는 술 게임이 있다. 이 게임은 참가자들이 돌아가면서 0부터 시작하여 1씩 숫자를 세는데, 각 숫자를 이진법으로 표현하여 앞자리부터 한 자리씩 말해야 한다는 규칙이다.예를 들어, 0 부터 7 까지의 정수를 이진법으로 표현하면 0→1→10→11→100→101→110→111 이므로, 참가자들은 돌아가면서 0→1→1→0→1→1→1→0→0→1→0→1→1→1→0→1→1→1 를 말하게 된다.숫자를 잘 못 세는 진수는 술 게임으로 이진수 게임을 하게 될 때가 가장 무섭다고 한다. 이진수 게임을 하는 진수가 자신의 차례가 되었을 때 말해야 하는 숫자를 계산해주는 프로그램을 작성해보자.진수의 차례가 돌아올 때 말해야 하는 숫자 다섯 개를 띄어쓰기로 구분하여 한 줄에 출력한다.",6.0,"구현,수학,",1.8497573137283325
/problem/8320,직사각형을 만드는 방법,"상근이는 변의 길이가 1인 정사각형 n개를 가지고 있다. 이 정사각형을 이용해서 만들 수 있는 직사각형의 개수는 총 몇 개일까?두 직사각형 A와 B가 있을 때, A를 이동, 회전시켜서 B를 만들 수 없으면, 두 직사각형은 다르다고 한다. 직사각형을 만들 때, 정사각형을 변형시키거나, 한 정사각형 위에 다른 정사각형을 놓을 수 없다. 또, 직사각형은 정사각형으로 꽉 차있어야 한다.만들 수 있는 직사각형의 개수를 출력한다.",4.0,"구현,수학,",1.8477712869644165
/problem/1568,새,"N마리의 새가 나무에 앉아있고, 자연수를 배우기 원한다. 새들은 1부터 모든 자연수를 오름차순으로 노래한다. 어떤 숫자 K를 노래할 때, K마리의 새가 나무에서 하늘을 향해 날아간다. 만약, 현재 나무에 앉아있는 새의 수가 지금 불러야 하는 수 보다 작을 때는, 1부터 게임을 다시 시작한다.나무에 앉아 있는 새의 수 N이 주어질 때, 하나의 수를 노래하는데 1초가 걸린다고 하면, 모든 새가 날아가기까지 총 몇 초가 걸리는지 출력하는 프로그램을 작성하시오.첫째 줄에 정답을 출력한다.",4.0,"구현,수학,",1.8462453484535217
/problem/15917,노솔브 방지문제야!!,"여러분은 Q개의 쿼리를 수행해야 합니다. 수행해야 하는 쿼리는 다음과 같습니다.어떤 수 a를 2의 거듭제곱 꼴로 나타낼 수 있는가?각 쿼리마다, 답이 Yes이면 1을, 그렇지 않으면 0을 출력합니다.",3.0,"구현,수학,",1.8334599733352661
/problem/2155,삼각형의 최단 경로,"위의 그림과 같은 삼각형이 있다. 작은 삼각형들은 1부터 시작해서 위와 같은 규칙으로 번호가 쭉 매겨져 있다. 이와 같은 그림에서, A가 적혀 있는 삼각형에서 B가 적혀 있는 삼각형으로 이동하려 한다.한 삼각형에서 다른 삼각형으로 이동할 때에는 삼각형들의 변을 통해서만 움직일 수 있으며, 꼭짓점을 통해서는 다른 삼각형으로 이동할 수 없다. 또한 삼각형의 밖으로 이동할 수도 없다. 이와 같이 이동을 할 때, 도중에 지나는 변의 개수가 그 경로의 길이가 된다.A와 B가 주어졌을 때, 가장 짧은 경로의 길이를 구하는 프로그램을 작성하시오.첫째 줄에 답을 출력한다.",12.0,"구현,수학,",1.8332015872001648
/problem/3152,예쁜 숫자,"p는 2보다 큰 정수이다. 다음과 같은 규칙으로 무한 이진 트리의 각 노드에 정수인 숫자가 매겨진다.루트 노드에는 1을 매긴다.노드에 x가 매겨져 있다면 해당 노드의 왼쪽 자식 노드에는 p * x, 오른쪽 자식 노드에는 p * x + 1이 매겨진다.예를 들어 p = 3 일때 트리의 시작 부분은 다음과 같을 것이다.어떤 숫자는 무한 이진 트리 내의 서로 다른 두 노드에 매겨진 두 숫자의 합으로 표현 할 수 있는 방법이 한 가지면 ""예쁜 숫자""로 분류된다. 주어진 p로 만든 무한 이진 트리 내에서  n1, n2, n3, n4가 ""예쁜""지 출력하는 프로그램을 작성하라.한 줄에 차례로 n1, n2, n3, n4가 예쁘면 1을, 아니면 0을 출력한다.",7.0,"구현,수학,",1.8269941806793213
/problem/15738,뒤집기,"N개의 수로 이루어진 배열 A가 있다. 배열의 인덱스는 1부터 시작한다. 배열에 연산을 총 M번 적용하려고 한다. 이때, 가장 처음에 K번째에 있던 수가 모든 연산이 종료된 후 몇 번째 위치로 이동하는지 구하는 프로그램을 작성하시오.배열에 적용할 수 있는 연산은 정수 i 하나로 이루어져 있다.i가 양의 정수인 경우에는 배열 A의 처음 i개의 순서를 뒤집는 것이고, i가 음의 정수인 경우에는 마지막 -i개의 순서를 뒤집는 것이다.예를 들어, N = 5이고, A = [1, 3, 2, 4, 5]인 경우에 연산 3을 적용하면, 배열 A는 [2, 3, 1, 4, 5]가 된다. 여기에 연산 -4를 적용하면, 뒤의 4개를 순서를 뒤집어 [2, 5, 4, 1, 3]이 된다. 가장 처음에 1번째 위치에 있던 수는 4번째 위치로 이동하게 되고, 3번째 위치에 있던 수는 1번째 위치로 이동하게 된다.첫째 줄에 K번째 수가 연산 M번이 완료된 후에 몇 번째 위치로 이동했는지 출력한다.",5.0,"구현,수학,",1.8216983675956726
/problem/1790,수 이어 쓰기 2,"1부터 N까지의 수를 이어서 쓰면 다음과 같이 새로운 하나의 수를 얻을 수 있다.1234567891011121314151617181920212223...이렇게 만들어진 새로운 수에서, 앞에서 k번째 자리 숫자가 어떤 숫자인지 구하는 프로그램을 작성하시오.첫째 줄에 앞에서 k번째 자리 숫자를 출력한다. 수의 길이가 k보다 작아서 k번째 자리 숫자가 없는 경우는 -1을 출력한다.",11.0,"구현,수학,",1.8109607100486755
/problem/25501,재귀의 귀재,"정휘는 후배들이 재귀 함수를 잘 다루는 재귀의 귀재인지 알아보기 위해 재귀 함수와 관련된 문제를 출제하기로 했다.팰린드롬이란, 앞에서부터 읽었을 때와 뒤에서부터 읽었을 때가 같은 문자열을 말한다. 팰린드롬의 예시로 AAA, ABBA, ABABA 등이 있고, 팰린드롬이 아닌 문자열의 예시로 ABCA, PALINDROME 등이 있다.어떤 문자열이 팰린드롬인지 판별하는 문제는 재귀 함수를 이용해 쉽게 해결할 수 있다. 아래 코드의 isPalindrome 함수는 주어진 문자열이 팰린드롬이면 1, 팰린드롬이 아니면 0을 반환하는 함수다.#include <stdio.h>#include <string.h>int recursion(const char *s, int l, int r){    if(l >= r) return 1;    else if(s[l] != s[r]) return 0;    else return recursion(s, l+1, r-1);}int isPalindrome(const char *s){    return recursion(s, 0, strlen(s)-1);}int main(){    printf(""ABBA: %d\n"", isPalindrome(""ABBA"")); // 1    printf(""ABC: %d\n"", isPalindrome(""ABC""));   // 0}정휘는 위에 작성된 isPalindrome 함수를 이용하여 어떤 문자열이 팰린드롬인지 여부를 판단하려고 한다.구체적으로는, 문자열 $S$를 isPalindrome 함수의 인자로 전달하여 팰린드롬 여부를 반환값으로 알아낼 것이다. 더불어 판별하는 과정에서 recursion 함수를 몇 번 호출하는지 셀 것이다.정휘를 따라 여러분도 함수의 반환값과 recursion 함수의 호출 횟수를 구해보자.각 테스트케이스마다, isPalindrome 함수의 반환값과 recursion 함수의 호출 횟수를 한 줄에 공백으로 구분하여 출력한다.",4.0,"구현,재귀,문자열,",기준
/problem/24443,알고리즘 수업 - 선택 알고리즘 4,"오늘도 서준이는 선택 알고리즘 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 서로 다른 양의 정수가 규칙 없이 저장된 배열 A가 있다. 최악의 경우 선형 시간 선택 알고리즘으로 배열 A에서 K 번째 작은 원소를 찾아서 우리 서준이를 도와주자. 총 Q 개의 쿼리가 주어지고 다음 두 종류의 쿼리를 수행해보자.1 i j k : Ai, Ai+1, ... , Aj에서 k번째 작은 원소를 출력한다.2 i j : Ai와 Aj를 교환한다.크기가 N인 배열에 대한 최악의 경우 선형 시간 선택 알고리즘 의사 코드는 다음과 같다.linear_select(A[], p, r, k) { # A[p..r]에서 k번째 작은 원소를 찾는다.    1) 원소의 총수가 5개 이하이면 k번째 원소를 찾고 알고리즘을 끝낸다.    2) 전체 원소를 5개씩의 원소를 가진 ⌈n / 5⌉ 개의 그룹으로 나눈다.       (원소의 총수가 5의 배수가 이니면 이 중 한 그룹은 5개 미만이 된다.)    3) 각 그룹에서 중앙값(원소가 5개이면 3번째 원소)을 찾는다.       원소의 총수가 홀수이면 중앙값이 하나이므로 문제가 없고,       원소의 총수가 짝수이면 두 중앙값 중 임의로 선택한다.       이렇게 찾은 중앙값들을 m1, m2, ..., m⌈n / 5⌉이라 하자.    4) m1, m2, ..., m⌈n / 5⌉들의 중앙값 M을 재귀적으로 구한다.       마찬가지로 원소의 총수가 짝수이면 두 중앙값 중 임의로 선택한다.    5) M을 기준원소로 삼아 전체 원소를 분할한다. (M보다 작거나 같은 것은 M의 왼쪽에, M보다 큰 것은 M의 오른쪽에 오도록 한다.)    6) 분할된 두 그룹 중 적합한 쪽을 선택해 단계 1) ~ 6)을 재귀적으로 반복한다.}1번 쿼리의 결과를 모두 출력한다.",11.0,"구현,재귀,",1.773019295589104
/problem/10993,별 찍기 - 18,예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.첫째 줄부터 차례대로 별을 출력한다.,12.0,"구현,재귀,",1.7699892338673022
/problem/10997,별 찍기 - 22,예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.첫째 줄부터 차례대로 별을 출력한다.,9.0,"구현,재귀,",1.7699892338673022
/problem/10994,별 찍기 - 19,예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.첫째 줄부터 차례대로 별을 출력한다.,7.0,"구현,재귀,",1.768378239528313
/problem/23304,아카라카,"아카라카!아카라카(아라)칭 아카라카(아라)쵸 아카라카(아라) 칭칭쵸쵸쵸 랄랄라 시스붐바 연세 선수 라플라헤이 연세 야!AKARAKA(아카라카)는 컴퓨터 과학적 관점으로 바라봤을 때, 튜링도 기립 박수를 치고 갈 가히 최고의 구호라 할 수 있다. AKARAKA는 그 자체로도 팰린드롬이고, 접두사이자 접미사인 AKA가 또한 팰린드롬이기 때문이다.신촌에서는 AKARAKA같은 특성을 가진 팰린드롬을, 아카라카 팰린드롬이라 아래와 같이 정의한다.문자열 $S$가 팰린드롬이다. 팰린드롬이란 거꾸로 뒤집어 읽어도 같은 문자열을 뜻한다.문자열 $S$의 길이를 $|S|$라 할 때, $\lfloor\frac{|S|}{2}\rfloor$ 길이의 접두사와 접미사가 모두 아카라카 팰린드롬이다. 만약 $|S| = 1$이면, $S$는 아카라카 팰린드롬이다.임의의 문자열이 주어졌을 때, 그 문자열이 아카라카 팰린드롬인지 알아보자. 만약 알아내지 못하면, 졸업할 때까지 아카라카를 못 갈지도 모른다!주어진 문자열 $S$가 아카라카 팰린드롬이라면, AKARAKA를 출력한다.",9.0,"재귀,문자열,",1.7625030118078073
/problem/16505,별,출력 예제를 보고 별 찍는 규칙을 유추하여 별을 찍어 보자.별 찍는 규칙에 따라 별을 출력한다.,9.0,"구현,재귀,",1.7458094176212695
/problem/6576,쿼드 트리,"고대 아즈텍 문명의 유적지에서 보물을 찾던 한신이는 긴 문장이 적혀있는 파피루스 두루마리를 우연히 발견하게 되었다. 그 종이의 문장들은 B 와 W 그리고 Q처럼 생긴 3가지의 다른 문자로만 이루어져있었다.암호학을 조금이나마 배웠던 한신이는 이 코드가 3000년전에 만들어진 아주 유명한 쿼드 트리 암호 구조라는 것을 알게되었다.쿼드 트리 암호화를 이용하면 비밀스러운 그림이나 사진 (보물지도 같은)등을 다음과 방식을 이용하여 암호화 할수 있다. 만약에 그림 전체가 검은색이라면 B로, 만약 흰색이라면 W로 변환하고 검은부분과 흰부분이 같이 있다면 그림을 Qxxxx형식으로 x를 4개의 부분으로 재귀적으로 쪼개서 변환한다. (왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래 순으로) 아즈텍 문명은 모든 그림은 2차 형식의 n*n 픽셀로 되어 있으며 이때 n은 2의 제곱수이며 완벽한 쿼드 트리 구조로만 구성되어 있다.예를들어 2*2 체스판을 암호화 하면 QWBBW로 나타낼 수 있으며, 4*4 체스판은 QQWBBWQWBBWQWBBWQWBBW으로 나타낼 수 있다.자! 이제 우리 한신이가 이 쿼드 트리 문자열을 XBM 형식의 파일로 만들수 있도록 해독하는 프로그램을 작성해주시기 바랍니다.",10.0,"재귀,",1.7102821951263916
/problem/11729,하노이 탑 이동 순서,"세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.아래 그림은 원판이 5개인 경우의 예시이다.첫째 줄에 옮긴 횟수 K를 출력한다.",10.0,"재귀,",1.6939039116257202
/problem/2448,별 찍기 - 11,예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.첫째 줄부터 N번째 줄까지 별을 출력한다.,12.0,"재귀,",1.675403166329242
/problem/2447,별 찍기 - 10,"재귀적인 패턴으로 별을 찍어 보자. N이 3의 거듭제곱(3, 9, 27, ...)이라고 할 때, 크기 N의 패턴은 N×N 정사각형 모양이다.크기 3의 패턴은 가운데에 공백이 있고, 가운데를 제외한 모든 칸에 별이 하나씩 있는 패턴이다.**** ****N이 3보다 클 경우, 크기 N의 패턴은 공백으로 채워진 가운데의 (N/3)×(N/3) 정사각형을 크기 N/3의 패턴으로 둘러싼 형태이다. 예를 들어 크기 27의 패턴은 예제 출력 1과 같다.첫째 줄부터 N번째 줄까지 별을 출력한다.",11.0,"분할 정복,재귀,",기준
/problem/4779,칸토어 집합,"칸토어 집합은 0과 1사이의 실수로 이루어진 집합으로, 구간 [0, 1]에서 시작해서 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만든다.	전체 집합이 유한이라고 가정하고, 다음과 같은 과정을 통해서 칸토어 집합의 근사를 만들어보자.	1. -가 3N개 있는 문자열에서 시작한다.	2. 문자열을 3등분 한 뒤, 가운데 문자열을 공백으로 바꾼다. 이렇게 하면, 선(문자열) 2개가 남는다.	3. 이제 각 선(문자열)을 3등분 하고, 가운데 문자열을 공백으로 바꾼다. 이 과정은 모든 선의 길이가 1일때 까지 계속 한다.	예를 들어, N=3인 경우, 길이가 27인 문자열로 시작한다.---------------------------	여기서 가운데 문자열을 공백으로 바꾼다.---------         ---------	남은 두 선의 가운데 문자열을 공백으로 바꾼다.---   ---         ---   ---	한번 더- -   - -         - -   - -	모든 선의 길이가 1이면 멈춘다. N이 주어졌을 때, 마지막 과정이 끝난 후 결과를 출력하는 프로그램을 작성하시오.	입력으로 주어진 N에 대해서, 해당하는 칸토어 집합의 근사를 출력한다.",8.0,"분할 정복,재귀,",1.8035237789154055
/problem/1780,종이의 개수,"N×N크기의 행렬로 표현되는 종이가 있다. 종이의 각 칸에는 -1, 0, 1 중 하나가 저장되어 있다. 우리는 이 행렬을 다음과 같은 규칙에 따라 적절한 크기로 자르려고 한다.만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다.(1)이 아닌 경우에는 종이를 같은 크기의 종이 9개로 자르고, 각각의 잘린 종이에 대해서 (1)의 과정을 반복한다.이와 같이 종이를 잘랐을 때, -1로만 채워진 종이의 개수, 0으로만 채워진 종이의 개수, 1로만 채워진 종이의 개수를 구해내는 프로그램을 작성하시오.첫째 줄에 -1로만 채워진 종이의 개수를, 둘째 줄에 0으로만 채워진 종이의 개수를, 셋째 줄에 1로만 채워진 종이의 개수를 출력한다.",9.0,"분할 정복,재귀,",1.7500675916671755
/problem/1074,Z,"한수는 크기가 2N × 2N인 2차원 배열을 Z모양으로 탐색하려고 한다. 예를 들어, 2×2배열을 왼쪽 위칸, 오른쪽 위칸, 왼쪽 아래칸, 오른쪽 아래칸 순서대로 방문하면 Z모양이다.N > 1인 경우, 배열을 크기가 2N-1 × 2N-1로 4등분 한 후에 재귀적으로 순서대로 방문한다.다음 예는 22 × 22 크기의 배열을 방문한 순서이다.N이 주어졌을 때, r행 c열을 몇 번째로 방문하는지 출력하는 프로그램을 작성하시오.다음은 N=3일 때의 예이다.r행 c열을 몇 번째로 방문했는지 출력한다.",10.0,"분할 정복,재귀,",1.668889403343201
/problem/2630,색종이 만들기,"아래 <그림 1>과 같이 여러개의 정사각형칸들로 이루어진 정사각형 모양의 종이가 주어져 있고, 각 정사각형들은 하얀색으로 칠해져 있거나 파란색으로 칠해져 있다. 주어진 종이를 일정한 규칙에 따라 잘라서 다양한 크기를 가진 정사각형 모양의 하얀색 또는 파란색 색종이를 만들려고 한다.전체 종이의 크기가 N×N(N=2k, k는 1 이상 7 이하의 자연수) 이라면 종이를 자르는 규칙은 다음과 같다.전체 종이가 모두 같은 색으로 칠해져 있지 않으면 가로와 세로로 중간 부분을 잘라서 <그림 2>의 I, II, III, IV와 같이 똑같은 크기의 네 개의 N/2 × N/2색종이로 나눈다. 나누어진 종이 I, II, III, IV 각각에 대해서도 앞에서와 마찬가지로 모두 같은 색으로 칠해져 있지 않으면 같은 방법으로 똑같은 크기의 네 개의 색종이로 나눈다. 이와 같은 과정을 잘라진 종이가 모두 하얀색 또는 모두 파란색으로 칠해져 있거나, 하나의 정사각형 칸이 되어 더 이상 자를 수 없을 때까지 반복한다.위와 같은 규칙에 따라 잘랐을 때 <그림 3>은 <그림 1>의 종이를 처음 나눈 후의 상태를, <그림 4>는 두 번째 나눈 후의 상태를, <그림 5>는 최종적으로 만들어진 다양한 크기의 9장의 하얀색 색종이와 7장의 파란색 색종이를 보여주고 있다.입력으로 주어진 종이의 한 변의 길이 N과 각 정사각형칸의 색(하얀색 또는 파란색)이 주어질 때 잘라진 하얀색 색종이와 파란색 색종이의 개수를 구하는 프로그램을 작성하시오.첫째 줄에는 잘라진 햐얀색 색종이의 개수를 출력하고, 둘째 줄에는 파란색 색종이의 개수를 출력한다.",9.0,"분할 정복,재귀,",1.6597082614898684
/problem/5405,프랙탈 거리,"민혁이가 심시티 게임에서 플레이하고 있는 도시는 교통 정체가 상당히 심하다. 교통 정체는 게임을 플레이 할 수 없을 정도로 심해졌고, 민혁이는 엄청난 짜증을 느꼈다. 따라서, 민혁이는 새 도시를 시작하기로 결심했다.이전 도시에서 교통 정체의 가장 큰 원인은 교차로였다. 교차로를 아무리 잘 설계해도, 게임 상의 AI 문제로 교통 정체는 피할 수 없는 선택이다. 교통 정체를 피하기 위해서는 교차로가 없는 도로를 만들면 된다. 어떻게 교차로 없이 도시의 모든 곳을 방문할 수 있을까? 민혁이는 인터넷에서 열심히 살펴보다가 힐베르트 곡선을 찾았다. 힐베르트 곡선을 이용하면, 교차로 없이 도시를 만들 수 있을 것이다.첫 번째 힐베르트 곡선은 컵(왼쪽 그림에 나와있는 ㄷ자) 하나로 이루어져 있다. 두 번째 힐베르트 곡선은 구역을 네 개의 정사각형으로 나누고, 각각의 정사각형에 컵을 채운 다음에 네 컵을 직선으로 연결한 것이다.힐베르트 곡선에 대한 설명은 4645번에 잘 나와 있기 때문에, 이 문제를 참고하면 된다.모든 모퉁이에는 집이 하나씩 있고, 순서대로 번호가 매겨져 있다. 가장 왼쪽 위에 있는 집이 1번이고, 인접한 두 집 사이의 거리는 10이다.몇 번째 힐베르트 곡선인지와 두 집의 번호가 주어졌을 때, 두 집 사이의 거리를 구하는 프로그램을 작성하시오. 모든 주민은 헬리콥터를 가지고 있어서, 도로를 이용하지 않고 하늘을 날아서 이동한다. 헬리콥터의 이륙과 착륙하는데 필요한 거리는 무시하며, 항상 최단거리를 이용한다.각 테스트 케이스에 대해서, 입력으로 주어진 두 집의 거리를 가까운 정수로 반올림해서 출력한다.",13.0,"분할 정복,재귀,",1.6565188169479372
/problem/1588,수열,"세준이는 가장 처음에 수 하나만 가지고 있는 수열을 가지고 있다. 매 초마다 1은 132로 바뀌고, 2는 211로 바뀌고, 3은 232로 바뀐다. 이런 변환은 매 초마다 동시에 일어난다. N초 후에 Left번째 수부터 Right번째 수 중에 1의 개수, 2의 개수, 3의 개수를 구하는 프로그램을 작성하시오. (Left와 Right를 셀 때, 가장 처음 수를 0번째 수, 그 다음 수를 1번째 수로 센다.)예를 들어, 가장 처음 수가 1고, N=2이고, Left = 2, Right = 6이라고 하면, 2초 후에는 132232211이 될 것이다. 따라서 Left부터 Right까지 부분 수열은 22322이다. 따라서, 1의 개수는 0, 2의 개수는 4, 3의 개수는 1이다.첫째 줄에 1의 개수, 2의 개수, 3의 개수를 공백으로 구분하여 출력한다.",15.0,"분할 정복,재귀,",1.6535814404487612
/problem/2263,트리의 순회,"n개의 정점을 갖는 이진 트리의 정점에 1부터 n까지의 번호가 중복 없이 매겨져 있다. 이와 같은 이진 트리의 인오더와 포스트오더가 주어졌을 때, 프리오더를 구하는 프로그램을 작성하시오.첫째 줄에 프리오더를 출력한다.",15.0,"분할 정복,재귀,트리,",1.6258146640198032
/problem/1030,프렉탈 평면,"프렉탈 평면은 다음과 같이 커진다. 시간 0에서 프렉탈은 흰색 정사각형 하나이다. 단위 시간(1)이 진행될 때마다 N×N개의 크기가 동일한 단위 정사각형으로 나누어진다. 만약 나누어진 정사각형이 흰색이라면 가운데 K×K 정사각형이 검정색으로 채워진다. N과 K는 둘 다 홀수이거나, 둘 다 짝수이다.예를 들어, N=3, K=1이라면, 시간 1에 3×3 정사각형이 된다. 가운데 정사각형은 검정색이고, 나머지는 흰색이 된다. 시간 2때 9×9 정사각형이 되고, 17개는 검정이고, 나머지는 흰색이다.s, N, K, R1, R2, C1, C2가 주어질 때, 시간 s일 때, R1행 C1열부터 R2행 C2열까지의 모습을 출력하는 프로그램을 작성하시오.첫째 줄에 문제의 정답을 출력한다. 첫째 줄에 R1행의 모습을 출력하고 이런 식으로 총 R2-R1+1개의 줄에 출력하면 된다. 각 행의 모습을 출력할 때, C1열부터 C2열까지 차례대로 흰색이면 숫자 '0' 검정이면 숫자 '1'을 출력한다. 숫자 사이에 공백을 넣으면 안 된다.",13.0,"분할 정복,구현,재귀,",1.6171971856076417
/problem/18222,투에-모스 문자열,"0과 1로 이루어진 길이가 무한한 문자열 X가 있다. 이 문자열은 다음과 같은 과정으로 만들어진다.X는 맨 처음에 ""0""으로 시작한다. X에서 0을 1로, 1을 0으로 뒤바꾼 문자열 X'을 만든다.X의 뒤에 X'를 붙인 문자열을 X로 다시 정의한다. 2~3의 과정을 무한히 반복한다.즉, X는 처음에 ""0""으로 시작하여 ""01""이 되고, ""0110""이 되고, ""01101001""이 되고, ⋯ 의 과정을 거쳐 다음과 같이 나타내어진다.    ""011010011001011010010110011010011001011001101001⋯⋯""자연수 k가 주어졌을 때 X의 k번째에는 무슨 문자가 오는지 구하여라.첫 번째 줄에 k번째에 오는 문자를 출력하라.",9.0,"분할 정복,재귀,",1.5877039432525637
/problem/23250,하노이 탑 K,"세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.이 작업을 수행하는 필요한 이동 순서 중에서 K번째를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.아래 그림은 원판이 5개인 경우의 예시이다.첫째 줄에 K번째 수행 과정을 의미하는 두 정수 A B를 빈칸을 사이에 두고 출력한다. 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다.",12.0,"수학,재귀,",1.920957487018482
/problem/19601,이진 삼진 탐색 놀이 3,"오늘도 서준이는 아빠와 함께 알고리즘 놀이를 하고 있다. 서준이는 이진 탐색, 아빠는 삼진 탐색 놀이를 하고 있다.서로 다른 정수가 오름차순으로 정렬된 크기가 N인 배열 A가 있다. 이진 탐색, 삼진 탐색으로 배열 A의 i번째 원소 Ai를 찾을 때, Ai를 찾기 전에 참조해야 하는 배열 A의 원소 개수를 각각 Bi , Ti 라고 하자. 서준이는 아빠로 부터 Bi , Ti 최대값을 공백을 사이에 두고 한줄에 출력하는 Q개의 질의를 받았다. n과 Q가 커서 괴로워 하는 우리 서준이를 도와주자.크기가 N인 배열에서 이진 탐색 알고리즘 의사 코드는 다음과 같다.binary_search(A[0..N-1], value, left, right) {    mid = (left + right) / 2    if (A[mid] == value)        return mid    else if (value < A[mid])        return binary_search(A, value, left, mid - 1)    else        return binary_search(A, value, mid + 1, right)}크기가 N인 배열에서 삼진 탐색 알고리즘 의사 코드는 다음과 같다.ternary_search(A[0..N-1], value, left, right) {    left_third = left + (right - left) / 3    right_third = right - (right - left) / 3    if (A[left_third] == value)         return left_third    else if (A[right_third] == value)        return right_third    else if (value < A[left_third])        return ternary_search(A, value, left, left_third - 1)    else if (value < A[right_third])        return ternary_search(A, value, left_third + 1, right_third - 1)    else        return ternary_search(A, value, right_third + 1, right)}첫번째 쿼리부터 Q번째 쿼리까지 각각의 쿼리 결과를 한줄씩 출력한다.",12.0,"수학,재귀,",1.8010047487334173
/problem/24060,알고리즘 수업 - 병합 정렬 1,"오늘도 서준이는 병합 정렬 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 서로 다른 양의 정수가 저장된 배열 A가 있다. 병합 정렬로 배열 A를 오름차순 정렬할 경우 배열 A에 K 번째 저장되는 수를 구해서 우리 서준이를 도와주자.크기가 N인 배열에 대한 병합 정렬 의사 코드는 다음과 같다.merge_sort(A[p..r]) { # A[p..r]을 오름차순 정렬한다.    if (p < r) then {        q <- ⌊(p + r) / 2⌋;       # q는 p, r의 중간 지점        merge_sort(A, p, q);      # 전반부 정렬        merge_sort(A, q + 1, r);  # 후반부 정렬        merge(A, p, q, r);        # 병합    }}# A[p..q]와 A[q+1..r]을 병합하여 A[p..r]을 오름차순 정렬된 상태로 만든다.# A[p..q]와 A[q+1..r]은 이미 오름차순으로 정렬되어 있다.merge(A[], p, q, r) {    i <- p; j <- q + 1; t <- 1;    while (i ≤ q and j ≤ r) {        if (A[i] ≤ A[j])        then tmp[t++] <- A[i++]; # tmp[t] <- A[i]; t++; i++;        else tmp[t++] <- A[j++]; # tmp[t] <- A[j]; t++; j++;    }    while (i ≤ q)  # 왼쪽 배열 부분이 남은 경우        tmp[t++] <- A[i++];    while (j ≤ r)  # 오른쪽 배열 부분이 남은 경우        tmp[t++] <- A[j++];    i <- p; t <- 1;    while (i ≤ r)  # 결과를 A[p..r]에 저장        A[i++] <- tmp[t++]; }배열 A에 K 번째 저장 되는 수를 출력한다. 저장 횟수가 K 보다 작으면 -1을 출력한다.",8.0,"구현,재귀,정렬,",기준
/problem/24061,알고리즘 수업 - 병합 정렬 2,"오늘도 서준이는 병합 정렬 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 서로 다른 양의 정수가 저장된 배열 A가 있다. 병합 정렬로 배열 A를 오름차순 정렬할 경우 배열 A의 원소가 K 번 변경된 직후의 배열 A를 출력해 보자.크기가 N인 배열에 대한 병합 정렬 의사 코드는 다음과 같다.merge_sort(A[p..r]) { # A[p..r]을 오름차순 정렬한다.    if (p < r) then {        q <- ⌊(p + r) / 2⌋;       # q는 p, r의 중간 지점        merge_sort(A, p, q);      # 전반부 정렬        merge_sort(A, q + 1, r);  # 후반부 정렬        merge(A, p, q, r);        # 병합    }}# A[p..q]와 A[q+1..r]을 병합하여 A[p..r]을 오름차순 정렬된 상태로 만든다.# A[p..q]와 A[q+1..r]은 이미 오름차순으로 정렬되어 있다.merge(A[], p, q, r) {    i <- p; j <- q + 1; t <- 1;    while (i ≤ q and j ≤ r) {        if (A[i] ≤ A[j])        then tmp[t++] <- A[i++]; # tmp[t] <- A[i]; t++; i++;        else tmp[t++] <- A[j++]; # tmp[t] <- A[j]; t++; j++;    }    while (i ≤ q)  # 왼쪽 배열 부분이 남은 경우        tmp[t++] <- A[i++];    while (j ≤ r)  # 오른쪽 배열 부분이 남은 경우        tmp[t++] <- A[j++];    i <- p; t <- 1;    while (i ≤ r)  # 결과를 A[p..r]에 저장        A[i++] <- tmp[t++]; }배열 A에 K 번 변경이 발생한 직후의 배열 A를 한 줄에 출력한다. 변경 횟수가 K 보다 작으면 -1을 출력한다.",7.0,"구현,정렬,",1.616928409488261
