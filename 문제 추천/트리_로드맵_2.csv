내용링크,title,problem,level,분류,유사도,number
/problem/11725,트리의 부모 찾기,"루트 없는 트리가 주어진다. 이때, 트리의 루트를 1이라고 정했을 때, 각 노드의 부모를 구하는 프로그램을 작성하시오.첫째 줄부터 N-1개의 줄에 각 노드의 부모 노드 번호를 2번 노드부터 순서대로 출력한다.",9.0,"그래프 이론,그래프 탐색,트리,너비 우선 탐색,깊이 우선 탐색,",기준,11725
/problem/5547,일루미네이션,"부유한 집안의 상속자 상근이네 집은 그림과 같이 1미터의 정육각형이 붙어있는 상태이다. 크리스마스가 다가오기 때문에, 여자친구에게 잘 보이기 위해 상근이는 건물의 벽면을 조명으로 장식하려고 한다. 외부에 보이지 않는 부분에 조명을 장식하는 것은 낭비라고 생각했기 때문에, 밖에서 보이는 부분만 장식하려고 한다.위의 그림은 상공에서 본 상근이네 집의 건물 배치이다. 정육각형 안의 숫자는 좌표를 나타낸다. 여기서 회색 정육각형은 건물의 위치이고, 흰색은 건물이 없는 곳이다. 위에서 붉은 색 선으로 표시된 부분이 밖에서 보이는 벽이고, 이 벽에 조명을 장식할 것이다. 벽의 총 길이는 64미터이다.상근이네 집의 건물 위치 지도가 주어졌을 때, 조명을 장식할 벽면의 길이의 합을 구하는 프로그램을 작성하시오. 지도의 바깥은 자유롭게 왕래 할 수 있는 곳이고, 인접한 건물 사이는 통과할 수 없다.조명을 장식하는 벽면의 길이의 합을 출력한다.",12.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.8631547370776174,5547
/problem/2310,어드벤처 게임,"어드벤처 게임을 하던 중, 1부터 n까지의 번호가 붙은 방을 지나가야 하는 마법의 미로를 마주쳤다. 각 방 안에는 번호가 붙은 문이 있을 수 있고, 각 문은 해당하는 번호의 방으로 통한다. 방 안에는 레프리콘이나 트롤이 있을 수도 있다.레프리콘이 있는 방에 들어가면 레프리콘은 모험가의 소지금이 일정 양 이하로 떨어지지 않게 채워준다. 레프리콘은 모험가의 소지금이 일정량 미만일 때에는 그만한 양이 되도록 금화를 채워주고, 소지금이 일정량 이상일 때에는 그대로 둔다. 트롤이 있는 방에 들어가려면 일정량의 통행료를 지불해야 한다. 이는 맨 처음에 모험가가 1번 방에서 시작하려 할 때에도 마찬가지이다.모험가는 소지금이 0인 상태에서 출발한다. 과연 모험가는 1번 방에서 출발해서 n번 방에 도착할 수 있을까?출력은 각 미로마다 한 줄씩으로 이루어진다. 각 줄에는 1번 방에서 n번 방까지 갈 수 있는지를 ""Yes"" 또는 ""No""로 출력한다.",12.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.8550925532206533,2310
/problem/2667,단지번호붙이기,"<그림 1>과 같이 정사각형 모양의 지도가 있다. 1은 집이 있는 곳을, 0은 집이 없는 곳을 나타낸다. 철수는 이 지도를 가지고 연결된 집의 모임인 단지를 정의하고, 단지에 번호를 붙이려 한다. 여기서 연결되었다는 것은 어떤 집이 좌우, 혹은 아래위로 다른 집이 있는 경우를 말한다. 대각선상에 집이 있는 경우는 연결된 것이 아니다. <그림 2>는 <그림 1>을 단지별로 번호를 붙인 것이다. 지도를 입력하여 단지수를 출력하고, 각 단지에 속하는 집의 수를 오름차순으로 정렬하여 출력하는 프로그램을 작성하시오.첫 번째 줄에는 총 단지수를 출력하시오. 그리고 각 단지내 집의 수를 오름차순으로 정렬하여 한 줄에 하나씩 출력하시오.",10.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.8238140622004506,2667
/problem/25516,거리가 k이하인 트리 노드에서 사과 수확하기,n개의 정점과 n - 1개의 간선으로 구성된 트리 T가 있다. 정점 번호는 0부터 n - 1까지이고 0번 정점이 루트이다. 모든 간선의 길이는 1이다. 트리 T의 각 정점에는 사과가 0개 또는 1개 놓여있다. 루트 노드에서 거리가 k이하인 노드에 있는 사과를 수확하려고 한다. 수확할 수 있는 사과 개수를 출력하자.첫 번째 줄에 수확할 수 있는 사과 개수를 출력한다.,9.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,트리,",1.8213033080101015,25516
/problem/19581,두 번째 트리의 지름,"트리에 N개의 정점이 있고, 각 정점 별로 1부터 N까지의 번호가 붙어있다.트리에서 가장 먼 두 정점 간의 거리를 트리의 지름이라고 한다. 트리의 지름을 구하는 문제는 너무 많기 때문에 우리는 두 번째 트리의 지름을 구하려고 한다.두 번째 트리의 지름은 무엇이냐? 바로 두 번째로 가장 먼 두 정점 간의 거리를 의미한다. (두 번째 트리의 지름은 트리의 지름과 같을 수 있다.)바로 두 번째 트리의 지름을 구해보자.첫째 줄에 두 번째 트리의 지름을 출력한다.",15.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,트리,",1.8181943517511343,19581
/problem/16174,점프왕 쩰리 (Large),"‘쩰리’는 점프하는 것을 좋아하는 젤리다. 단순히 점프하는 것에 지루함을 느낀 ‘쩰리’는 새로운 점프 게임을 해보고 싶어 한다. 새로운 점프 게임의 조건은 다음과 같다.‘쩰리’는 가로와 세로의 칸 수가 같은 정사각형의 구역 내부에서만 움직일 수 있다. ‘쩰리’가 정사각형 구역의 외부로 나가는 경우엔 바닥으로 떨어져 즉시 게임에서 패배하게 된다.‘쩰리’의 출발점은 항상 정사각형의 가장 왼쪽, 가장 위의 칸이다. 다른 출발점에서는 출발하지 않는다.‘쩰리’가 이동 가능한 방향은 오른쪽과 아래 뿐이다. 위쪽과 왼쪽으로는 이동할 수 없다.‘쩰리’가 가장 오른쪽, 가장 아래 칸에 도달하는 순간, 그 즉시 ‘쩰리’의 승리로 게임은 종료된다.‘쩰리’가 한 번에 이동할 수 있는 칸의 수는, 현재 밟고 있는 칸에 쓰여 있는 수 만큼이다. 칸에 쓰여 있는 수 초과나 그 미만으로 이동할 수 없다.새로운 게임이 맘에 든 ‘쩰리’는, 계속 게임을 진행해 마침내 최종 단계에 도달했다. 하지만, 게임을 진행하는 구역이 너무 넓어져버린 나머지, 이 게임에서 이길 수 있는지 없는지 가늠할 수 없어졌다. ‘쩰리’는 유능한 프로그래머인 당신에게 주어진 구역에서 승리할 수 있는 지 알아봐 달라고 부탁했다. ‘쩰리’를 도와 주어진 게임 구역에서 끝 점(오른쪽 맨 아래 칸)까지 도달할 수 있는지를 알아보자!‘쩰리’가 끝 점에 도달할 수 있으면 “HaruHaru”(인용부호 없이), 도달할 수 없으면 “Hing” (인용부호 없이)을 한 줄에 출력합니다.",10.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.8170864859446523,16174
/problem/17077,고양이 우선 탐색,"택희는 어느 날 눈을 떠 보니 어떤 트리 위의 1번 정점에 놓여 있었다. 이 트리에는 택희 외에도, 고양이가 몇 마리 있을 수 있다.이 트리에서는 매초마다 아래와 같은 일이 순서대로 한 번씩 일어난다.모든 고양이들이, 가만히 있거나, 인접한 다른 정점으로 한 번 이동한다. 각 고양이들은 독립적으로 움직인다.택희가 인접한 정점 중 하나로 한 번 이동한다. 택희는 가만히 있을 수 없다.택희는 그래프의 특성을 파악한 후, 아래와 같은 탐색 전략을 세웠다. 처음에 택희는 1이 적혀 있는 수첩과 펜을 들고 1번 정점 위에 서 있다.현재 정점에 인접한 다른 정점들 중에 아직 수첩에 기록되지 않은 정점들의 집합을 V라고 하자.	만약 V가 비어 있는 집합이라면, 현재 정점에 인접한 정점 중 수첩에 적힌 지가 가장 오래 된 정점으로 되돌아간다.만약 V 안에 고양이가 있는 정점이 있다면, 그러한 정점들 중 번호가 가장 작은 정점으로 간다.만약 그러한 정점이 없다면, 그냥 V 안에서 번호가 가장 작은 정점으로 간다.도착한 정점의 번호가 수첩에 적혀 있지 않다면 도착한 정점의 번호를 수첩에 기록한다.수첩에 N개의 정수가 적힐 때까지 (1,2)를 반복한다. (1,2)를 한 번 반복하는 데에는 1초가 걸린다.탐색 과정에서, 고양이들, 또는 고양이들과 택희는 동일한 정점 위에 있게 될 수도 있다.택희는 무사히 탐색을 마친 뒤 수첩에 적힌 N개의 정수를 바라보았다. 그 순간 알람이 울렸고, 택희는 꿈에서 깨어나게 되었다.택희는 꿈에서 본 N개의 정수를 기억하고 있으며, 트리의 구조 또한 정확히 기억하고 있다.택희는 이러한 탐색을 가능하게 하는 최소 고양이의 수와, 각 고양이들의 시작점이 어디였는지가 궁금해졌다. 택희를 위해, 고양이가 가능한 최소한의 수만 트리 위에 있었을 때, 가능한 고양이들의 시작점의 집합의 개수를 세어 주도록 하자.시작점의 집합이란, 고양이 수만큼의 길이를 갖는 배열로, 각 고양이가 서 있는 정점 번호를 비내림차순으로 나열한 것을 말한다. 이 배열에서 서로 다른 원소가 하나 이상 있을 경우 서로 다른 집합인 것으로 센다.고양이가 최소한의 수만 있었을 때, 고양이들의 가능한 서로 다른 시작점 집합의 수를 109+7로 나눈 나머지를 출력한다.",22.0,"애드 혹,너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,트리,",1.8166811657925528,17077
/problem/2606,바이러스,"신종 바이러스인 웜 바이러스는 네트워크를 통해 전파된다. 한 컴퓨터가 웜 바이러스에 걸리면 그 컴퓨터와 네트워크 상에서 연결되어 있는 모든 컴퓨터는 웜 바이러스에 걸리게 된다.예를 들어 7대의 컴퓨터가 <그림 1>과 같이 네트워크 상에서 연결되어 있다고 하자. 1번 컴퓨터가 웜 바이러스에 걸리면 웜 바이러스는 2번과 5번 컴퓨터를 거쳐 3번과 6번 컴퓨터까지 전파되어 2, 3, 5, 6 네 대의 컴퓨터는 웜 바이러스에 걸리게 된다. 하지만 4번과 7번 컴퓨터는 1번 컴퓨터와 네트워크상에서 연결되어 있지 않기 때문에 영향을 받지 않는다.어느 날 1번 컴퓨터가 웜 바이러스에 걸렸다. 컴퓨터의 수와 네트워크 상에서 서로 연결되어 있는 정보가 주어질 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 출력하는 프로그램을 작성하시오.1번 컴퓨터가 웜 바이러스에 걸렸을 때, 1번 컴퓨터를 통해 웜 바이러스에 걸리게 되는 컴퓨터의 수를 첫째 줄에 출력한다.",8.0,"그래프 이론,그래프 탐색,너비 우선 탐색,깊이 우선 탐색,",1.8082710185870168,2606
/problem/25032,Young Zebra,"요즘 젊은 얼룩말 사이에서는, 가죽의 흑백 무늬를 새롭게 바꾸는 수술이 대인기다. 젊은 얼룩말인 정우도 이 수술로 가죽의 무늬를 바꾸는 것에 관심이 많다.이 수술을 받기 전에 수술을 받는 얼룩말이 원하는 크기의 흑백 패턴을 준비 해야 하고, 수술은 이 패턴을 무한히 이어 붙인 것을 기준으로 한다. 예를 들어, $2 \times 3$크기의 패턴과 이 패턴을 이어 붙인 그림이다.그림 1: $2 \times 3$크기의 패턴그림 2 : 위의 패턴을 무한히 이어 붙인 것의 일부. 빨간 직사각형은 위의 패턴을 나타내며, 뒤틀림 없이 그대로 맞춰서 이어 붙인다.격자는 시술할 때 없어지므로 이상하게 시술이 될 것 같다는 걱정은 하지 않으셔도 됩니다.정우는 먼저 패턴을 정한 후, 무한히 이어 붙여보는 것을 해보려고 한다. 이 때, 중요한 것은 무한히 이어 붙인 다음 각 칸이 이루는 연결 성분의 크기이다. 이것은 미관상 매우 중요한 문제다. 만약 색이 같은 두 칸이 상하좌우로 붙어있다면 그 두 칸은 같은 연결 성분에 들어가는 것이다.그림 2에서 각 칸이 속한 연결 성분의 크기를 구해보면, 검은색 칸이 속한 연결 성분의 크기는 모두 $24$이고, 흰색 칸이 속한 연결 성분에는 무한히 많은 칸이 포함된다. 즉, 크기가 무한대이다. 주어진 패턴을 무한히 이어 붙인 다음 각 칸이 속한 연결 성분의 크기를 구하는 프로그램을 작성하라.총 $N$개의 줄에 걸쳐 정답을 출력한다. $i$번째 줄에는 $M$개의 수가 공백 하나로 구분되어 출력되어야 하고, 그 중 $j$번째 수는 입력에서 $i$번째 행 $j$번째 열에 주어진 칸이 속한 연결 성분의 크기여야 한다. 만약 그 크기가 무한히 크다면 -1로 출력해야 한다.",18.0,"너비 우선 탐색,깊이 우선 탐색,그래프 이론,그래프 탐색,",1.8066912570818898,25032
/problem/1167,트리의 지름,"트리의 지름이란, 트리에서 임의의 두 점 사이의 거리 중 가장 긴 것을 말한다. 트리의 지름을 구하는 프로그램을 작성하시오.첫째 줄에 트리의 지름을 출력한다.",14.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,트리,",기준,1167
/problem/19542,전단지 돌리기,"현민이는 트리 모양의 길 위에서 오토바이를 타고 전단지를 돌리려고 한다. 현민이의 목표는 케니소프트에서 출발하여 모든 노드에 전단지를 돌리고, 다시 케니소프트로 돌아오는 것이다. 현민이는 힘이 좋기 때문에 현재 노드에서 거리가 $D$ 이하인 모든 노드에 전단지를 돌릴 수 있다.날씨가 매우 덥기 때문에, 현민이는 최소한만 이동해서 목표를 달성하고 싶다! 현민이를 위해 현민이가 이동해야 하는 총 거리를 구해주자.현민이가 목표를 완수하기 위해 이동해야 하는 최소 거리를 출력하여라.",13.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,트리,",1.9538075923919678,19542
/problem/14678,어그로 끌린 영선,"영우는 운동장에 크게 ‘트리’ 그림을 그려 놓으며 공부를 하고 있었다. ‘트리’ 란, 사이클이 없는 그래프를 뜻한다. 우연히 지나가던 영선이는 트리의 정점 크기가 정확히 자신의 발 사이즈와 일치 하는 것을 알게 되었고, 그걸 본 영우는 영선이에게 게임을 제안했다. 게임의 방식은 다음과 같다.영선이가 임의의 한 정점에서 시작해서 왼 발, 오른 발을 번갈아 걷다가 더 이상 갈 수 없을 때까지 게임을 진행한다. 영선이는 왼 쪽 발을 디딘 채로 시작한다. 더 이상 진행할 수 없을 때 정점을 밟고 있는 발이 왼 발이면 영선이가 이기고, 오른 발이면 영우가 이긴다. 단, 영선이가 한 번 밟은 정점은 영선이의 발자국으로 인해 운동장에서 지워진다.영선이는 운동장이 너무 커서 트리에 대한 정보를 하나도 모르기 때문에, 게임을 시작 할 정점을 찍어야 한다. 자신이 불리하다고 생각한 영선이가 게임을 하지 않으려고 하자, 영우는 영선이에게 “어떤 점 x에서 영선이가 이기는 경우의 수”를 알려주며 어그로를 끌어보려고 한다. 최대한 큰 값을 얘기하고 싶은 영우를 위해 트리 정보를 다 알고있는 여러분이 계산해주자. 예를 들어 운동장에 다음과 같은 트리 그림이 그려져 있었다고 하자.1번에서 왼 발을 디딘 채로 시작해서 영선이가 이길 수 있는 경우의 수는 2다.(1왼 -> 2오 -> 4왼) (1왼 ->2오 -> 5왼)2번에서 왼 발을 디딘 채로 시작해서 영선이가 이길 수 있는 경우의 수는 1이다.(2왼 -> 1오 -> 3왼)프로그램의 출력은 표준 출력으로 한다. 경우의 수가 최대인 위치에서의 경우의 수를 출력한다.",14.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,트리,",1.9378929138183594,14678
/problem/15900,나무 탈출,"평소에 사이가 좋지 않던 성원이와 형석이가 드디어 제대로 한 판 붙으려고 한다. 성원이와 형석이 둘과 모두 똑같이 친한 인섭이가 대결 종목을 정해 가져왔다. 바로 '나무 탈출' 이라는 보드게임이다.'나무 탈출' 은 N개의 정점이 있는 트리 모양으로 생긴 게임판과 몇 개의 게임말로 이루어진다. 트리의 각 정점에는 1번부터 N번까지 번호가 붙어있다. 1번 정점은 '루트 노드' 라고 불리며, 이 루트 노드를 중심으로 정점 간에 부모-자식 관계가 만들어진다. 자식이 없는 노드는 '리프 노드' 라고 불린다.이 게임은 두 사람이 번갈아 가면서 게임판에 놓여있는 게임말을 움직이는 게임이다. 처음에는 트리의 모든 리프 노드에 게임말이 하나씩 놓여있는 채로 시작한다. 어떤 사람의 차례가 오면, 그 사람은 현재 존재하는 게임말 중 아무거나 하나를 골라 그 말이 놓여있던 노드의 부모 노드로 옮긴다. 이 과정에서 한 노드에 여러 개의 게임말이 놓이게 될 수도 있다. 이렇게 옮긴 후에 만약 그 게임말이 루트 노드에 도착했다면 그 게임말을 즉시 제거한다. 모든 과정을 마치면 다음 사람에게 차례를 넘긴다. 이런 식으로 계속 진행하다가 게임말이 게임판에 존재하지 않아 고를 수 없는 사람이 지게 된다.성원이를 얕본 형석이는 쿨하게 이 게임의 선을 성원이에게 줘버렸다. 따라서 성원이가 먼저 시작하고 형석이가 나중에 시작한다. 그동안 형석이와 대결을 하면 매번 지기만 했던 성원이는 마음속에 분노가 가득 쌓였다. 이번 대결에서는 반드시 이겨서 형석이의 코를 꺾어주고 싶다. 그래서 게임을 시작하기 전에 게임판의 모양만 보고 이 게임을 이길 수 있을지 미리 알아보고 싶어졌다. 성원이가 이 게임을 이길 수 있을지 없을지를 알려주는 프로그램을 만들어 성원이를 도와주자.성원이가 최선을 다했을 때 이 게임을 이길 수 있으면 Yes, 아니면 No를 출력한다.",10.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,트리,",1.9221307039260864,15900
/problem/20924,트리의 기둥과 가지,"시청 공무원 마이크로는 과장으로부터 시에 있는 나무의 기둥의 길이와 가장 긴 가지의 길이를 파악하라는 업무 지시를 받았다.마이크로는 ICPC Sinchon Winter Algorithm Camp에서 배운 트리 자료 구조를 이용하면 이 작업을 좀 더 수월하게 할 수 있으리라 판단했다. 마이크로는 트리의 기둥과 가지를 분류하기 위해 기가 노드를 추가로 정의하였다.기가 노드는 루트 노드에서 순회를 시작했을 때, 처음으로 자식 노드가 $2$개 이상인 노드다. 기둥-가지를 줄여 기가 노드라 이름 붙였다. 위 그림에서 기가 노드는 $4$번 노드다.단, 위 그림과 같이 리프 노드가 단 $1$개인 경우 리프 노드가 동시에 기가 노드가 된다.또한, 위 그림과 같이 루트 노드가 동시에 기가 노드인 경우도 가능하다.트리의 기둥은 루트 노드에서부터 기가 노드까지다. 위 그림에서 기둥은 $1-2-3-4$ 이다.	기둥의 길이는 기둥의 간선 길이의 합인 $1 + 2 + 3 = 6$ 이 된다.트리의 가지는 기가 노드에서부터 임의의 리프 노드까지다. 위 그림에서 가지는 $4-5-6-7$, $4-5-8$, $4-9$, $4-10-11$, $4-10-12$ 총 $5$개가 있다.	가지의 길이는 가지의 간선 길이의 합이다. 다행히도 가장 긴 가지의 길이 하나만 기재하면 된다. $4-10-12$ 가지가 간선 길이의 합 $3 + 3 = 6$ 으로 가장 긴 가지이다.마이크로는 시의 나무를 트리 자료 구조로 옮겼다. 그런데 과장이 마이크로에게 또 다른 업무를 지시했다! 너무 바쁜 마이크로를 대신해 트리의 기둥과 가장 긴 가지의 길이를 측정하자.나무의 기둥의 길이와 가장 긴 가지의 길이를 출력한다.",12.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,트리,",1.9178486466407776,20924
/problem/1595,북쪽나라의 도로,"두 도시 사이에 도로를 만드는 일은 매우 비싸다. 때문에 북쪽나라는 특정 도시를 두 번 이상 지나가지 않고서 임의의 두 도시간을 이동하는 경로가 유일하도록 도로가 설계되어 있다.또한 북쪽나라의 모든 도시는 다른 모든 도시로 이동할 수 있다고 한다. 이때, 거리가 가장 먼 두 도시 사이의 거리를 출력하는 것이 당신의 임무이다.북쪽나라에는 최대 10,000개의 도시가 있을 수 있고, 도시는 1 부터 숫자로 이름이 매겨져 있다.가장 거리가 먼 두 도시간의 거리를 나타내는 정수 하나를 출력하면 된다.",12.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,트리,",1.9066529870033264,1595
/problem/2250,트리의 높이와 너비,"이진트리를 다음의 규칙에 따라 행과 열에 번호가 붙어있는 격자 모양의 틀 속에 그리려고 한다. 이때 다음의 규칙에 따라 그리려고 한다.이진트리에서 같은 레벨(level)에 있는 노드는 같은 행에 위치한다.한 열에는 한 노드만 존재한다.임의의 노드의 왼쪽 부트리(left subtree)에 있는 노드들은 해당 노드보다 왼쪽의 열에 위치하고, 오른쪽 부트리(right subtree)에 있는 노드들은 해당 노드보다 오른쪽의 열에 위치한다.노드가 배치된 가장 왼쪽 열과 오른쪽 열 사이엔 아무 노드도 없이 비어있는 열은 없다.이와 같은 규칙에 따라 이진트리를 그릴 때 각 레벨의 너비는 그 레벨에 할당된 노드 중 가장 오른쪽에 위치한 노드의 열 번호에서 가장 왼쪽에 위치한 노드의 열 번호를 뺀 값 더하기 1로 정의한다. 트리의 레벨은 가장 위쪽에 있는 루트 노드가 1이고 아래로 1씩 증가한다.아래 그림은 어떤 이진트리를 위의 규칙에 따라 그려 본 것이다. 첫 번째 레벨의 너비는 1, 두 번째 레벨의 너비는 13, 3번째, 4번째 레벨의 너비는 각각 18이고, 5번째 레벨의 너비는 13이며, 그리고 6번째 레벨의 너비는 12이다.우리는 주어진 이진트리를 위의 규칙에 따라 그릴 때에 너비가 가장 넓은 레벨과 그 레벨의 너비를 계산하려고 한다. 위의 그림의 예에서 너비가 가장 넓은 레벨은 3번째와 4번째로 그 너비는 18이다. 너비가 가장 넓은 레벨이 두 개 이상 있을 때는 번호가 작은 레벨을 답으로 한다. 그러므로 이 예에 대한 답은 레벨은 3이고, 너비는 18이다.임의의 이진트리가 입력으로 주어질 때 너비가 가장 넓은 레벨과 그 레벨의 너비를 출력하는 프로그램을 작성하시오첫째 줄에 너비가 가장 넓은 레벨과 그 레벨의 너비를 순서대로 출력한다. 너비가 가장 넓은 레벨이 두 개 이상 있을 때에는 번호가 작은 레벨을 출력한다.",14.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,트리,",1.898971676826477,2250
/problem/9466,텀 프로젝트,"이번 가을학기에 '문제 해결' 강의를 신청한 학생들은 텀 프로젝트를 수행해야 한다. 프로젝트 팀원 수에는 제한이 없다. 심지어 모든 학생들이 동일한 팀의 팀원인 경우와 같이 한 팀만 있을 수도 있다. 프로젝트 팀을 구성하기 위해, 모든 학생들은 프로젝트를 함께하고 싶은 학생을 선택해야 한다. (단, 단 한 명만 선택할 수 있다.) 혼자 하고 싶어하는 학생은 자기 자신을 선택하는 것도 가능하다.학생들이(s1, s2, ..., sr)이라 할 때, r=1이고 s1이 s1을 선택하는 경우나, s1이 s2를 선택하고, s2가 s3를 선택하고,..., sr-1이 sr을 선택하고, sr이 s1을 선택하는 경우에만 한 팀이 될 수 있다.예를 들어, 한 반에 7명의 학생이 있다고 하자. 학생들을 1번부터 7번으로 표현할 때, 선택의 결과는 다음과 같다.12345673137346위의 결과를 통해 (3)과 (4, 7, 6)이 팀을 이룰 수 있다. 1, 2, 5는 어느 팀에도 속하지 않는다.주어진 선택의 결과를 보고 어느 프로젝트 팀에도 속하지 않는 학생들의 수를 계산하는 프로그램을 작성하라.각 테스트 케이스마다 한 줄에 출력하고, 각 줄에는 프로젝트 팀에 속하지 못한 학생들의 수를 나타내면 된다.",13.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,",1.897977261856396,9466
/problem/12896,스크루지 민호,구두쇠로 유명한 스크루지 민호가 다스리는 천나라가 있다. 천나라에는 N 개의 도시들이 있는데 각각의 도시들 사이에는 양방향 도로로 이어져 있다. 민호는 도시를 세울 때 최소한의 비용만을 들이고 싶어서 N - 1 개의 도로를 이용해 모든 도시들 사이에는 단 한개의 경로만이 존재하도록 도시를 세웠다.도시를 세울 당시에 소방서를 여러개 건설하는 것이 아까웠던 스쿠르지 민호는 단 하나의 도시에 소방서를  건설하기로 했다. 하지만 최소한의 양심이 있어서인지 소방서는 최적의 위치가 될 수 있는 도시에 건설하기로 했다. 최적의 위치라는 것은 소방서에서 소방차가 출동해 다른 도시에 도착을 할 때 이동해야 하는 거리중의 최대가 최소가 되는 지점을 의미한다. 편의상 같은 도시 내에서 이동하는 거리는 없다고 생각하며 한 도시에서 다른 도시로 연결된 도로는 거리가 1이라고 생각한다.천나라에 있는 도시의 수와 도로들의 연결 상태가 주어질 때 최적의 위치에 설치된 소방서에서 소방차가 출동해 다른 도시에 도착할 때 이동해야하는 거리들 중 최대 거리를 구하는 프로그램을 작성하자.첫째 줄에 최적의 위치에 설치된 소방서에서 소방차가 출동해 다른 도시에 도착할 때까지 이동해야하는 거리들 중 최댓값을 출력한다.,14.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,트리,",1.8871359825134277,12896
/problem/1991,트리 순회,"이진 트리를 입력받아 전위 순회(preorder traversal), 중위 순회(inorder traversal), 후위 순회(postorder traversal)한 결과를 출력하는 프로그램을 작성하시오.예를 들어 위와 같은 이진 트리가 입력되면,전위 순회한 결과 : ABDCEFG // (루트) (왼쪽 자식) (오른쪽 자식)중위 순회한 결과 : DBAECFG // (왼쪽 자식) (루트) (오른쪽 자식)후위 순회한 결과 : DBEGFCA // (왼쪽 자식) (오른쪽 자식) (루트)가 된다.첫째 줄에 전위 순회, 둘째 줄에 중위 순회, 셋째 줄에 후위 순회한 결과를 출력한다. 각 줄에 N개의 알파벳을 공백 없이 출력하면 된다.",10.0,"재귀,트리,",기준,1991
/problem/4257,프리오더 포스트오더,"이진 트리를 인오더(in-order)와 포스트오더(post-order)로 순회한 결과가 주어졌을 때, 프리오더(pre-order)로 순회한 결과를 찾을 수 있다. 또, 인오더와 포리오더로 순회한 결과가 주어졌을 때, 포스트오더로 순회한 결과도 쉽게 찾을 수 있다. 하지만, 프리오더와 포스트오더로 순회한 결과가 주어졌을 때는, 인오더로 순회한 결과를 구할 수 없다.	아래 이진 트리 4개를 보자.	위의 트리는 같은 프리오더와 포스트오더를 갖는 트리이다. 이러한 현상은 이진 트리에서만 나타나는 것이 아니고, 모든 m진 트리(자식이 최대 m개인 트리)에서 나타난다.	m진 트리를 프리오더와 포스트오더로 순회한 결과가 주어졌을 때, 이러한 순회 결과를 갖는 트리의 개수를 출력하는 프로그램을 작성하시오.	각 테스트 케이스에 대해서, 입력으로 주어진 프리오더와 포스트오더 순회 결과를 갖는 m진트리의 개수를 출력한다. 이 결과는 항상 부호있는 32비트 정수 범위이다. 입력으로 주어진 결과를 이용해서 트리를 적어도 하나는 만들 수 있다.",13.0,"조합론,수학,재귀,트리,",1.4285894344338217,4257
/problem/2448,별 찍기 - 11,예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.첫째 줄부터 N번째 줄까지 별을 출력한다.,12.0,"재귀,",1.3863114735758182,2448
/problem/11729,하노이 탑 이동 순서,"세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.이 작업을 수행하는데 필요한 이동 순서를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.아래 그림은 원판이 5개인 경우의 예시이다.첫째 줄에 옮긴 횟수 K를 출력한다.",10.0,"재귀,",1.3818313500559207,11729
/problem/6576,쿼드 트리,"고대 아즈텍 문명의 유적지에서 보물을 찾던 한신이는 긴 문장이 적혀있는 파피루스 두루마리를 우연히 발견하게 되었다. 그 종이의 문장들은 B 와 W 그리고 Q처럼 생긴 3가지의 다른 문자로만 이루어져있었다.암호학을 조금이나마 배웠던 한신이는 이 코드가 3000년전에 만들어진 아주 유명한 쿼드 트리 암호 구조라는 것을 알게되었다.쿼드 트리 암호화를 이용하면 비밀스러운 그림이나 사진 (보물지도 같은)등을 다음과 방식을 이용하여 암호화 할수 있다. 만약에 그림 전체가 검은색이라면 B로, 만약 흰색이라면 W로 변환하고 검은부분과 흰부분이 같이 있다면 그림을 Qxxxx형식으로 x를 4개의 부분으로 재귀적으로 쪼개서 변환한다. (왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래 순으로) 아즈텍 문명은 모든 그림은 2차 형식의 n*n 픽셀로 되어 있으며 이때 n은 2의 제곱수이며 완벽한 쿼드 트리 구조로만 구성되어 있다.예를들어 2*2 체스판을 암호화 하면 QWBBW로 나타낼 수 있으며, 4*4 체스판은 QQWBBWQWBBWQWBBWQWBBW으로 나타낼 수 있다.자! 이제 우리 한신이가 이 쿼드 트리 문자열을 XBM 형식의 파일로 만들수 있도록 해독하는 프로그램을 작성해주시기 바랍니다.",10.0,"재귀,",1.3766939065134403,6576
/problem/9934,완전 이진 트리,"상근이는 슬로베니아의 도시 Donji Andrijevci를 여행하고 있다. 이 도시의 도로는 깊이가 K인 완전 이진 트리를 이루고 있다. 깊이가 K인 완전 이진 트리는 총 2K-1개의 노드로 이루어져 있다. (아래 그림) 각 노드에는 그 곳에 위치한 빌딩의 번호가 붙여져 있다. 또, 가장 마지막 레벨을 제외한 모든 집은 왼쪽 자식과 오른쪽 자식을 갖는다.깊이가 2와 3인 완전 이진 트리상근이는 도시에 있는 모든 빌딩에 들어갔고, 들어간 순서대로 번호를 종이에 적어 놓았다. 한국으로 돌아온 상근이는 도시가 어떻게 생겼는지 그림을 그려보려고 하였으나, 정확하게 기억이 나지 않아 실패했다. 하지만, 어떤 순서로 도시를 방문했는지 기억해냈다.가장 처음에 상근이는 트리의 루트에 있는 빌딩 앞에 서있다.현재 빌딩의 왼쪽 자식에 있는 빌딩에 아직 들어가지 않았다면, 왼쪽 자식으로 이동한다.현재 있는 노드가 왼쪽 자식을 가지고 있지 않거나 왼쪽 자식에 있는 빌딩을 이미 들어갔다면, 현재 노드에 있는 빌딩을 들어가고 종이에 번호를 적는다.현재 빌딩을 이미 들어갔다 온 상태이고, 오른쪽 자식을 가지고 있는 경우에는 오른쪽 자식으로 이동한다.현재 빌딩과 왼쪽, 오른쪽 자식에 있는 빌딩을 모두 방문했다면, 부모 노드로 이동한다.왼쪽 그림에 나와있는 마을이라면, 상근이는 2-1-3 순서대로 빌딩을 들어갔을 것이고, 오른쪽 그림의 경우에는 1-6-4-3-5-2-7 순서로 들어갔을 것이다. 상근이가 종이에 적은 순서가 모두 주어졌을 때, 각 레벨에 있는 빌딩의 번호를 구하는 프로그램을 작성하시오.총 K개의 줄에 걸쳐서 정답을 출력한다. i번째 줄에는 레벨이 i인 빌딩의 번호를 출력한다. 출력은 왼쪽에서부터 오른쪽 순서대로 출력한다.",10.0,"재귀,트리,",1.3649572730064394,9934
/problem/1646,피이보나치 트리,"0번째와 1번째 피이보나치 트리는 단일 노드로 이루어져 있다. 1보다 큰 모든 i번째 피이보나치 트리는 다음과 같은 방법을 통해 만들 수 있다.새로운 노드 r을 만든다. 이 노드는 i번째 피이보나치 트리의 루트가 된다.(i-1)번째와 (i-2)번째 피이보나치 트리를 만든다.(i-2)번째 피이보나치 트리를 노드 r의 왼쪽 부분 트리로 만든다.(i-1)번째 피이보나치 트리를 노드 r의 오른쪽 부분 트리로 만든다.피이보나치 트리의 정점의 개수는 정말 빠르게 증가한다. 예를 들어, 50번째 피이보나치 트리는 약 4×1010개의 정점을 가지고 있다.피이보나치 트리의 정점에 번호를 매기는 순서는 트리를 전위순회할 때 방문하는 순서대로 번호를 매긴다.예를 들어, 3번째 피이보나치 트리는 다음과 같다.N과 시작 위치와 도착 위치가 들어오면, N번째 피이보나치 트리에서 시작 위치에서 도착 위치로 가는 최단 경로를 구하는 프로그램을 작성하시오. 각 노드사이의 거리는 1이다.첫째 줄에 시작 위치부터 도착 위치로 가는 최단 경로를 찾는다. L은 왼쪽 자식으로 이동하는 것이고, R은 오른쪽 자식으로 이동하는 것이고, U는 부모로 이동하는 것이다.",15.0,"다이나믹 프로그래밍,재귀,트리,",1.361790787943026,1646
/problem/23250,하노이 탑 K,"세 개의 장대가 있고 첫 번째 장대에는 반경이 서로 다른 n개의 원판이 쌓여 있다. 각 원판은 반경이 큰 순서대로 쌓여있다. 이제 수도승들이 다음 규칙에 따라 첫 번째 장대에서 세 번째 장대로 옮기려 한다.한 번에 한 개의 원판만을 다른 탑으로 옮길 수 있다.쌓아 놓은 원판은 항상 위의 것이 아래의 것보다 작아야 한다.이 작업을 수행하는 필요한 이동 순서 중에서 K번째를 출력하는 프로그램을 작성하라. 단, 이동 횟수는 최소가 되어야 한다.아래 그림은 원판이 5개인 경우의 예시이다.첫째 줄에 K번째 수행 과정을 의미하는 두 정수 A B를 빈칸을 사이에 두고 출력한다. 이는 A번째 탑의 가장 위에 있는 원판을 B번째 탑의 가장 위로 옮긴다는 뜻이다.",12.0,"수학,재귀,",1.3133596391002764,23250
/problem/16505,별,출력 예제를 보고 별 찍는 규칙을 유추하여 별을 찍어 보자.별 찍는 규칙에 따라 별을 출력한다.,9.0,"구현,재귀,",1.3133450537172715,16505
/problem/10997,별 찍기 - 22,예제를 보고 규칙을 유추한 뒤에 별을 찍어 보세요.첫째 줄부터 차례대로 별을 출력한다.,9.0,"구현,재귀,",1.3064155369249741,10997
/problem/2263,트리의 순회,"n개의 정점을 갖는 이진 트리의 정점에 1부터 n까지의 번호가 중복 없이 매겨져 있다. 이와 같은 이진 트리의 인오더와 포스트오더가 주어졌을 때, 프리오더를 구하는 프로그램을 작성하시오.첫째 줄에 프리오더를 출력한다.",15.0,"분할 정복,재귀,트리,",기준,2263
/problem/4256,트리,"이진 트리는 매우 중요한 기본 자료 구조이다. 아래 그림은 루트 노드가 유일한 이진 트리이다. 모든 노드는 최대 2개의 자식 노드를 가질 수 있으며, 왼쪽 자식이 순서가 먼저이다. 노드 n개로 이루어진 이진 트리를 BT라고 하자. BT의 노드는 1부터 n까지 유일한 번호가 매겨져 있다.아래 그림에 나와있는 BT의 루트는 3번 노드이다. 1번 노드는 오른쪽 자식만 가지고 있고, 4와 7은 왼쪽 자식만 가지고 있다. 3과 6은 왼쪽과 오른쪽 자식을 모두 가지고 있다. 나머지 노드는 모두 자식이 없으며, 이러한 노드는 리프 노드라고 부른다.BT의 모든 노드를 순회하는 방법은 전위 순회(preorder), 중위 순회(inorder), 후위 순회(postorder)로 총 세 가지가 있다. 이 세 방법은 아래에 C 스타일의 의사 코드로 나와 있다. BT의 노드 v에 대해서, v.left는 왼쪽 자식, v.right는 오른쪽 자식을 나타낸다. v가 왼쪽 자식이 없으면 v.left는 ∅와 같고, 오른쪽 자식이 없으면 v.right는 ∅와 같다.BT를 전위 순회, 중위 순회한 결과가 주어진다. 즉, 위의 함수 중 preorder(root node of BT)와 inorder(root node of BT)를 호출해서 만든 리스트가 주어진다. 두 순회한 결과를 가지고 다시 BT를 만들 수 있다. BT의 전위, 중위 순회한 결과가 주어졌을 때, 후위 순회했을 때의 결과를 구하는 프로그램을 작성하시오.예를 들어, 위의 그림을 전위 순회하면 3,6,5,4,8,7,1,2, 중위 순회하면 5,6,8,4,3,1,2,7이 된다. 이를 이용해 후위 순회하면 5,8,4,6,2,1,7,3이 된다.각 테스트 케이스마다 후위 순회한 결과를 출력 한다.",14.0,"분할 정복,재귀,트리,",1.8776870965957644,4256
/problem/5405,프랙탈 거리,"민혁이가 심시티 게임에서 플레이하고 있는 도시는 교통 정체가 상당히 심하다. 교통 정체는 게임을 플레이 할 수 없을 정도로 심해졌고, 민혁이는 엄청난 짜증을 느꼈다. 따라서, 민혁이는 새 도시를 시작하기로 결심했다.이전 도시에서 교통 정체의 가장 큰 원인은 교차로였다. 교차로를 아무리 잘 설계해도, 게임 상의 AI 문제로 교통 정체는 피할 수 없는 선택이다. 교통 정체를 피하기 위해서는 교차로가 없는 도로를 만들면 된다. 어떻게 교차로 없이 도시의 모든 곳을 방문할 수 있을까? 민혁이는 인터넷에서 열심히 살펴보다가 힐베르트 곡선을 찾았다. 힐베르트 곡선을 이용하면, 교차로 없이 도시를 만들 수 있을 것이다.첫 번째 힐베르트 곡선은 컵(왼쪽 그림에 나와있는 ㄷ자) 하나로 이루어져 있다. 두 번째 힐베르트 곡선은 구역을 네 개의 정사각형으로 나누고, 각각의 정사각형에 컵을 채운 다음에 네 컵을 직선으로 연결한 것이다.힐베르트 곡선에 대한 설명은 4645번에 잘 나와 있기 때문에, 이 문제를 참고하면 된다.모든 모퉁이에는 집이 하나씩 있고, 순서대로 번호가 매겨져 있다. 가장 왼쪽 위에 있는 집이 1번이고, 인접한 두 집 사이의 거리는 10이다.몇 번째 힐베르트 곡선인지와 두 집의 번호가 주어졌을 때, 두 집 사이의 거리를 구하는 프로그램을 작성하시오. 모든 주민은 헬리콥터를 가지고 있어서, 도로를 이용하지 않고 하늘을 날아서 이동한다. 헬리콥터의 이륙과 착륙하는데 필요한 거리는 무시하며, 항상 최단거리를 이용한다.각 테스트 케이스에 대해서, 입력으로 주어진 두 집의 거리를 가까운 정수로 반올림해서 출력한다.",13.0,"분할 정복,재귀,",1.805455016745786,5405
/problem/1780,종이의 개수,"N×N크기의 행렬로 표현되는 종이가 있다. 종이의 각 칸에는 -1, 0, 1 중 하나가 저장되어 있다. 우리는 이 행렬을 다음과 같은 규칙에 따라 적절한 크기로 자르려고 한다.만약 종이가 모두 같은 수로 되어 있다면 이 종이를 그대로 사용한다.(1)이 아닌 경우에는 종이를 같은 크기의 종이 9개로 자르고, 각각의 잘린 종이에 대해서 (1)의 과정을 반복한다.이와 같이 종이를 잘랐을 때, -1로만 채워진 종이의 개수, 0으로만 채워진 종이의 개수, 1로만 채워진 종이의 개수를 구해내는 프로그램을 작성하시오.첫째 줄에 -1로만 채워진 종이의 개수를, 둘째 줄에 0으로만 채워진 종이의 개수를, 셋째 줄에 1로만 채워진 종이의 개수를 출력한다.",9.0,"분할 정복,재귀,",1.8020799633400242,1780
/problem/2630,색종이 만들기,"아래 <그림 1>과 같이 여러개의 정사각형칸들로 이루어진 정사각형 모양의 종이가 주어져 있고, 각 정사각형들은 하얀색으로 칠해져 있거나 파란색으로 칠해져 있다. 주어진 종이를 일정한 규칙에 따라 잘라서 다양한 크기를 가진 정사각형 모양의 하얀색 또는 파란색 색종이를 만들려고 한다.전체 종이의 크기가 N×N(N=2k, k는 1 이상 7 이하의 자연수) 이라면 종이를 자르는 규칙은 다음과 같다.전체 종이가 모두 같은 색으로 칠해져 있지 않으면 가로와 세로로 중간 부분을 잘라서 <그림 2>의 I, II, III, IV와 같이 똑같은 크기의 네 개의 N/2 × N/2색종이로 나눈다. 나누어진 종이 I, II, III, IV 각각에 대해서도 앞에서와 마찬가지로 모두 같은 색으로 칠해져 있지 않으면 같은 방법으로 똑같은 크기의 네 개의 색종이로 나눈다. 이와 같은 과정을 잘라진 종이가 모두 하얀색 또는 모두 파란색으로 칠해져 있거나, 하나의 정사각형 칸이 되어 더 이상 자를 수 없을 때까지 반복한다.위와 같은 규칙에 따라 잘랐을 때 <그림 3>은 <그림 1>의 종이를 처음 나눈 후의 상태를, <그림 4>는 두 번째 나눈 후의 상태를, <그림 5>는 최종적으로 만들어진 다양한 크기의 9장의 하얀색 색종이와 7장의 파란색 색종이를 보여주고 있다.입력으로 주어진 종이의 한 변의 길이 N과 각 정사각형칸의 색(하얀색 또는 파란색)이 주어질 때 잘라진 하얀색 색종이와 파란색 색종이의 개수를 구하는 프로그램을 작성하시오.첫째 줄에는 잘라진 햐얀색 색종이의 개수를 출력하고, 둘째 줄에는 파란색 색종이의 개수를 출력한다.",9.0,"분할 정복,재귀,",1.7887830015556614,2630
/problem/14601,샤워실 바닥 깔기 (Large),"오늘은 민규가 훈련소에 입소하는 날이다. 모든 행사를 마치고 생활관으로 돌아와서 쉬려는데 갑자기 교관이 들어오더니 민규의 이름을 부르는 것이 아닌가. 당황한 채로 따라갔더니 이번엔 김준서를 아느냐고 물어보았다. 그 녀석이 샤워실 바닥을 깔았는데, 배수구 위치까지 막아버렸다면서 같은 학교 출신인 민규가 다시 깔라는 것이었다.어떻게 타일을 깔지 고민하던 민규는 샤워실의 구조가 정사각형이면서 한 변의 길이가 2의 제곱수라는 사실을 알아냈다. 준서는 여기까지만 고려해서 2x2 크기의 타일로 바닥을 전부 채운 것 같은데, 문제는 이렇게 하면 배수구가 있어야 할 위치를 비울 수가 없다는 것이다. 이런저런 방법을 생각하다가 4칸을 차지하는 정사각형 타일 대신 3칸을 차지하는 ㄱ자 모양의 타일을 사용하면 될 것 같다는 느낌을 받았다.그런데 ㄱ자 타일을 어떻게 채워야 할까? 생각하다 지친 민규는 여러분에게 이 방법을 찾아달라고 부탁했다. 첫날부터 생활관에서 밤을 새우는 일이 없도록 여러분이 도와주자.각 타일마다 고유한 번호를 매긴 타일의 배치도를 출력한다. 각 타일의 번호에는 19000 이하의 자연수만을 사용해야 한다. 배수구가 있는 위치는 -1로 표시한다. 가능한 답 중 하나만 출력하면 된다.",16.0,"분할 정복,구현,재귀,",1.7875870278286383,14601
/problem/1030,프렉탈 평면,"프렉탈 평면은 다음과 같이 커진다. 시간 0에서 프렉탈은 흰색 정사각형 하나이다. 단위 시간(1)이 진행될 때마다 N×N개의 크기가 동일한 단위 정사각형으로 나누어진다. 만약 나누어진 정사각형이 흰색이라면 가운데 K×K 정사각형이 검정색으로 채워진다. N과 K는 둘 다 홀수이거나, 둘 다 짝수이다.예를 들어, N=3, K=1이라면, 시간 1에 3×3 정사각형이 된다. 가운데 정사각형은 검정색이고, 나머지는 흰색이 된다. 시간 2때 9×9 정사각형이 되고, 17개는 검정이고, 나머지는 흰색이다.s, N, K, R1, R2, C1, C2가 주어질 때, 시간 s일 때, R1행 C1열부터 R2행 C2열까지의 모습을 출력하는 프로그램을 작성하시오.첫째 줄에 문제의 정답을 출력한다. 첫째 줄에 R1행의 모습을 출력하고 이런 식으로 총 R2-R1+1개의 줄에 출력하면 된다. 각 행의 모습을 출력할 때, C1열부터 C2열까지 차례대로 흰색이면 숫자 '0' 검정이면 숫자 '1'을 출력한다. 숫자 사이에 공백을 넣으면 안 된다.",13.0,"분할 정복,구현,재귀,",1.7736660054134772,1030
/problem/4779,칸토어 집합,"칸토어 집합은 0과 1사이의 실수로 이루어진 집합으로, 구간 [0, 1]에서 시작해서 각 구간을 3등분하여 가운데 구간을 반복적으로 제외하는 방식으로 만든다.	전체 집합이 유한이라고 가정하고, 다음과 같은 과정을 통해서 칸토어 집합의 근사를 만들어보자.	1. -가 3N개 있는 문자열에서 시작한다.	2. 문자열을 3등분 한 뒤, 가운데 문자열을 공백으로 바꾼다. 이렇게 하면, 선(문자열) 2개가 남는다.	3. 이제 각 선(문자열)을 3등분 하고, 가운데 문자열을 공백으로 바꾼다. 이 과정은 모든 선의 길이가 1일때 까지 계속 한다.	예를 들어, N=3인 경우, 길이가 27인 문자열로 시작한다.---------------------------	여기서 가운데 문자열을 공백으로 바꾼다.---------         ---------	남은 두 선의 가운데 문자열을 공백으로 바꾼다.---   ---         ---   ---	한번 더- -   - -         - -   - -	모든 선의 길이가 1이면 멈춘다. N이 주어졌을 때, 마지막 과정이 끝난 후 결과를 출력하는 프로그램을 작성하시오.	입력으로 주어진 N에 대해서, 해당하는 칸토어 집합의 근사를 출력한다.",8.0,"분할 정복,재귀,",1.7090102907554905,4779
/problem/16974,레벨 햄버거,"상근날드에서 오랜만에 새로운 햄버거를 출시했다. 바로 레벨-L 버거이다. 레벨-L 버거는 다음과 같이 만든다.레벨-0 버거는 패티만으로 이루어져 있다.레벨-L 버거는 햄버거번, 레벨-(L-1) 버거, 패티, 레벨-(L-1)버거, 햄버거번으로 이루어져 있다. (L ≥ 1)예를 들어, 레벨-1 버거는 'BPPPB', 레벨-2 버거는 'BBPPPBPBPPPBB'와 같이 생겼다. (B는 햄버거번, P는 패티)상도가 상근날드에 방문해서 레벨-N 버거를 시켰다. 상도가 햄버거의 아래 X장을 먹었을 때, 먹은 패티는 몇 장일까? 한 장은 햄버거번 또는 패티 한 장이다.첫째 줄에 상도가 먹은 패티의 수를 출력한다.",10.0,"분할 정복,다이나믹 프로그래밍,재귀,",1.6912747958844676,16974
/problem/1992,쿼드트리,"흑백 영상을 압축하여 표현하는 데이터 구조로 쿼드 트리(Quad Tree)라는 방법이 있다. 흰 점을 나타내는 0과 검은 점을 나타내는 1로만 이루어진 영상(2차원 배열)에서 같은 숫자의 점들이 한 곳에 많이 몰려있으면, 쿼드 트리에서는 이를 압축하여 간단히 표현할 수 있다.주어진 영상이 모두 0으로만 되어 있으면 압축 결과는 ""0""이 되고, 모두 1로만 되어 있으면 압축 결과는 ""1""이 된다. 만약 0과 1이 섞여 있으면 전체를 한 번에 나타내지를 못하고, 왼쪽 위, 오른쪽 위, 왼쪽 아래, 오른쪽 아래, 이렇게 4개의 영상으로 나누어 압축하게 되며, 이 4개의 영역을 압축한 결과를 차례대로 괄호 안에 묶어서 표현한다위 그림에서 왼쪽의 영상은 오른쪽의 배열과 같이 숫자로 주어지며, 이 영상을 쿼드 트리 구조를 이용하여 압축하면 ""(0(0011)(0(0111)01)1)""로 표현된다.  N ×N 크기의 영상이 주어질 때, 이 영상을 압축한 결과를 출력하는 프로그램을 작성하시오.영상을 압축한 결과를 출력한다.",10.0,"분할 정복,재귀,",1.6863185640709202,1992
/problem/1539,이진 검색 트리,"P는 크기가 N인 배열이다. P에는 0보다 크거나 같고, N-1보다 작거나 같은 정수가 중복 없이 채워져 있다. 이진 검색 트리는 루트가 있는 이진 트리로, 각각의 노드에 정수 값이 저장되어 있는 트리이다. 이진 검색 트리를 P배열을 이용해서 만드는 법은 다음과 같다. 일단 root를 만들고 거기에 P[0]의 값을 넣은 후에 다음과 같은 과정을 거친다.for (int i=1; i<=n-1; i++) {    insert(root, P[i]);}여기서 insert함수는 다음과 같다.void insert(Vertex V, int X) {    if (x < V에 저장되어 있는 수) {        if (V가 왼쪽 자식이 있으면) {            insert(V의 왼쪽 자식, X);        } else {            V의 왼쪽 자식을 새로 만들고, 그 곳에 X를 저장함        }    } else {        if (V가 오른쪽 자식이 있으면) {            insert(V의 오른쪽 자식, X);        } else {            V의 오른쪽 자식을 새로 만들고, 그 곳에 X를 저장함        }    }}N과, 배열 P에 있는 수가 주어졌을 때, P로 이진 검색 트리를 만들었을 때, 모든 노드의 높이의 합을 출력하는 프로그램을 작성하시오. 트리의 높이는 루트에서 부터의 거리 + 1이다.주어진 P배열로 이진 검색 트리를 만들었을 때, 높이의 합을 출력한다. 이 값은 2^63보다 작다.",16.0,"자료 구조,트리,트리를 사용한 집합과 맵,",기준,1539
/problem/13303,장애물 경기,"평면 상에서 어떤 점의 위치를 나타내기 위해 좌표를 이용하면 매우 편리하다. <그림 1>에서 예로 보인 것처럼 기준점(이를 원점이라 부른다)에서 우측으로 거리가 4, 위로 거리가 3에 놓인 빨간 점의 좌표는 (4, 3)로 표시한다. 좌표를 이용하면 평면 상에 있는 어떤 점의 위치도 쉽게 나타낼 수 있다. 즉, 기준점에서 오른쪽으로 거리가 x, 위로 거리가 y에 놓인 점의 좌표는 (x, y)로 나타낸다. 기준점(원점)의 좌표는 (0, 0)이 된다. <그림 1>장애물이 설치된 넓은 들판에서 재미있는 달리기 시합이 벌어진다. 들판 곳곳에 수직방향(남북방향)으로 된 담장 모양의 장애물이 설치되어 있다. 선수는 출발지점에서 동쪽방향으로 달리기 시작하다가 장애물을 만나면 남쪽 또는 북쪽으로 달려 장애물을 피해가야 한다. 장애물 끝에 다다르면 다시 선수는 동쪽으로만 달릴 수 있다. 이 달리기의 목표는 결승선으로 지정된 (무한히 긴) 수직선에 가장 짧은 거리를 달려 도달하는 것이다. 달리기 시작 전에 모든 장애물에 대한 정보가 선수에게 주어진다. 즉, 어떤 크기의 장애물이 어느 위치에 놓여있는지에 대한 정보가 선수에게 주어지고, 선수는 장애물을 피해가면서 가장 짧은 거리를 달려 결승선에 도착해야 한다.선수의 출발지점 및 각 장애물 양 끝점의 위치는 (x, y) 좌표를 사용하여 표시한다. 모든 좌표 값은 정수로 주어지고, 출발지점의 x 좌표는 0이다. 각 장애물은 수직선분으로 볼 수 있고, 이때 양 끝점의 x 좌표는 동일하기 때문에 장애물에 대한 정보는 세 값 [x, yl, yh] (yl < yh)으로 나타낼 수 있다. 이 세 값은 장애물이 설치된 곳의 x 좌표와 양 끝점의 y 좌표를 나타낸다. x 좌표가 동일한 두 장애물이 겹치거나 또는 한 점에서 만나는 경우는 없다. 선수가 동쪽으로 달리다가 장애물의 끝 점을 만나면 계속 동쪽으로 달려간다. <그림 2>의 예를 보자. 출발지점이 (0, 43), 결승선의 x 좌표가 70이고, 4개의 수직 장애물에 대한 정보가 각각 [20, 30, 50], [30, 10, 38], [45, 35, 55], [55, 50, 70]인 경우, 최단의 이동경로는 점선으로 표시한 것처럼 (0, 43) → (20, 43) → (20, 50) → (45, 50) → (45, 55) → (55, 55) → (55, 50) → (70, 50)이 되고, 이때의 총 이동거리는 87이다. 또한 도착지 점의 y 좌표는 50이 된다.<그림 2><그림 3>의 예에선 서로 다른 최단경로가 다음과 같이 4개가 있다(0, 40) → (20, 40) → (20, 50) → (35, 50) → (35, 60) → (70, 60)(0, 40) → (20, 40) → (20, 50) → (35, 50) → (35, 40) → (70, 40)(0, 40) → (20, 40) → (20, 30) → (50, 30) → (50, 40) → (70, 40)(0, 40) → (20, 40) → (20, 30) → (50, 30) → (50, 20) → (70, 20)<그림 3><그림 3>에서 보인 경로 가운데 경로 ②와 경로 ③은 달리는 경로는 다르지만 도착지점은 동일하다.출발지점의 y 좌표, 결승선의 x 좌표, N개의 장애물에 대한 정보가 주어질 때 이동 규칙을 따르는 최단경로를 모두 찾은 후, 도착지점이 서로 다른 최단경로의 도착지점의 y 좌표 값을 오름차순으로 차례로 출력하는 프로그램을 작성하시오.표준 출력으로 첫 번째 줄에는 최단경로의 길이를 출력한다. 두 번째 줄엔 최단경로들의 서로 다른 도착지점의 개수 k와, k개의 도착지점의 y 좌표를 오름차순으로 차례로 출력한다. ",18.0,"자료 구조,트리를 사용한 집합과 맵,",1.7295227682939753,13303
/problem/10922,말,"만수르는 조상들과 마찬가지로 말을 키우는 것을 좋아한다. 그는 카자흐스탄에서 말을 제일 많이 갖고 있다. 그렇지만 꼭 항상 그랬던 것은 아닌데, N년 전에만 해도 만수르는 그저 젊은이일 뿐이어서 말이 한마리밖에 없었다. 만수르는 돈을 많이 벌어서 부자가 되고 싶었다.시간순으로 매 해를 0번 해부터 N-1번 해로 번호를 매기자. (즉, N-1번 해가 가장 최근이다.) 해마다 날씨는 말이 자라는데 영향을 미친다. 만수르가 기억하기로는, i번 해에 말의 마릿수가 늘어난 비율은 양의 정수 X[i]이다. 만약 i번 해 연초에 말이 h마리가 있었다면, 그 해 연말에는 말이 모두 h×X[i]마리가 된다.말은 매해 연말에만 팔 수 있다. 만수르가 기억하기로 i번 해의 말값은 양의 정수 Y[i]였다. 즉, 매해 연말에 갖고 있는 말 중 팔 수 있는 말의 수에는 제약이 없고, 말 한마리 값은 Y[i]로 모두 같다.만수르는 지난 N년 동안, 말을 파는 시기를 잘 정했다면 얼마나 많은 돈을 벌 수 있었을지가 궁금해졌다. 당신이 만수르를 방문했을 때 이 질문을 받게 되었다.저녁동안 만수르의 기억은 점점 정확해져서, 총 M번의 수정을 하게 된다. 수정을 한 번 할 때마다 X[i]의 값 중 하나, 또는 Y[i]의 값 중 하나가 바뀐다. 수정을 한 번 할 때마다 만수르는 말을 팔아 서 벌 수 있는 돈의 최댓값을 물어본다. 만수르가 수정할 때마다, 수정된 내용들은 누적된다. 즉, 만수르에게 대답할 때는 지금까지 만수르가 한 수정들을 모두 반영해야 한다. 한 X[i] 또는 Y[i]가 여러 번 수정되는 경우도 가능하다.만수르의 질문에 대한 답은 매우 큰 수일 수 있다. 큰 수를 다룰 때 생기는 문제를 피하기 위해서, 답을 109+7로 나눈 나머지를 알려주면 된다.N = 3년에 대해서 다음과 같은 정보가 주어졌다고 하자. 012X213Y341이 초기 정보를 가지고, 만수르는 1번 해 연말에 모든 말을 다 팔았다면 가장 많은 돈을 벌 수 있다. 전체 과정은 다음과 같다.처음에 만수르는 말이 한 마리 있다.0번 해 연말에 만수르는 1×X[0] = 2마리의 말이 있다.1번 해 연말에 만수르는 2×X[1] = 2마리의 말이 있다.이제 말 두 마리를 모두 팔 수 있다. 전체 이익은 2×Y[1] = 8이다.이제, M = 1번 수정을 하여 Y[1]이 2로 바뀌었다.수정 후의 정보는 다음과 같다. 012X213Y321이 경우, 최적해 중 하나는 한 마리를 0번 해 연말에 팔고 2번 해 연말에 세 마리를 파는 것이다. 전체 과정은 다음과 같다처음에 만수르는 말이 한 마리 있다.0번 해 연말에 만수르는 1×X[0] = 2마리의 말이 있다.이제 이 중 한 마리를 Y[0] = 3에 팔 수 있고, 한 마리가 남아 있다.1번 해 연말에 만수르는 1×X[1] = 1마리의 말이 있다.2번 해 연말에 만수르는 1×X[2] = 3마리의 말이 있다.이제 말 세 마리를 모두 3×Y[2] = 3에 팔 수 있다. 전체 이익은 3 + 3 = 6이다.N, X, Y와 수정된 내용의 리스트가 주어진다. 첫 번째 수정을 하기 전과, 매번 수정을 한 다음에 대해서 만수르가 말을 팔아서 벌 수 있는 돈의 최댓값을 109+7로 나눈 나머지를 구하라. 이를 위해서 함수 init, updateX, updateY를 구현해야 한다.init(N, X, Y) — 그레이더는 이 함수를 맨 처음 정확히 한 번 호출한다.	N: 전체 해 수X: 길이 N인 배열. 0 ≤ i ≤ N-1일 때, X[i]는 i번 해 연말에 말의 마릿수가 늘어난 비율이다.Y: 길이 N인 배열. 0 ≤ i ≤ N-1일 때, Y[i]는 i번 해 연말에 말 한마리의 값이다.X와 Y는 만수르가 처음에 준 값을 나타낸다. (수정을 하기 전의 값)init 함수가 종료한 후, 배열 X와 Y는 유효한 주소에 있으며, 원한다면 이 배열의 내용을 수정할 수 있다.이 함수는 X와 Y의 초기값을 가지고 만수르가 말을 팔아서 벌 수 있는 돈의 최댓값을 109+7로 나눈 나머지를 리턴해야 한다.updateX(pos, val)	pos: 0, ..., N-1 범위 내의 정수.val: X[pos]의 새로운 값.이 함수는 주어진 정보에 따라 수정을 한 후, 만수르가 말을 팔아서 벌 수 있는 돈의 최댓값을 109+7로 나눈 나머지를 리턴해야 한다.updateY(pos, val)	pos: 0, ..., N-1 범위 내의 정수.val: Y[pos]의 새로운 값.이 함수는 주어진 정보에 따라 수정을 한 후, 만수르가 말을 팔아서 벌 수 있는 돈의 최댓값을 109+7로 나눈 나머지를 리턴해야 한다.모든 X[i]와 Y[i]의 값은 항상 (즉, 처음에도, 매번 수정을 한 다음에도) 1이상 109이하를 만족한다.init을 호출한 후, 그레이더는 updateX와 updateY를 여러 번 호출할 것이다. updateX와 updateY의 전체 호출 회수는 M이다.처음 init의 리턴값을 출력하고, 차례로 updateX와 updateY의 모든 호출에 대한 리턴값을 출력한다.",20.0,"자료 구조,세그먼트 트리,트리를 사용한 집합과 맵,",1.6556885536423316,10922
/problem/28475,편광판,"편광판은 빛의 진동 방향을 바꾼다.빛이 현재 진동하는 방향과 수직한 편광판을 만나면 가로막힌다. 그렇지 않은 경우에는 편광판 방향으로 진동 방향을 바꾸면서 통과한다.여러 편광판들이 연속해서 있고, 각 편광판은 $45$도 단위로 조작할 수 있다.시작점과 끝점이 주어질 때, 시작점에서 빛을 쏴서 편광판을 모두 통과하여 끝점에 도달할 수 있는지 구하라.편광판을 통과하기 전의 빛은 모든 방향으로 진동하고 있다.$q_i=2$인 쿼리에 대해 순서대로, 빛이 편광판을 통과할 수 있다면 1, 아니면 0을 한 줄에 하나씩 출력한다.",15.0,"자료 구조,세그먼트 트리,트리를 사용한 집합과 맵,",1.6514864857903113,28475
/problem/24914,Split the SSHS,"서울의 명소 서울과학고등학교에는 1부터 N까지의 번호가 매겨진 건물이 N - 1 개의 길로 연결되어 있다. 단, 서울과학고등학교는 어떤 두 건물 사이도 연결된 길만을 이용하여 오갈 수 있다. 다음은 유효한 서울과학고등학교이다.정후는 서울과학고등학교를 여러 조각으로 분열시킨 후 서울과학고등학교를 지배할 계획을 세우고 있다. 서울과학고등학교의 각 길은 M 개의 색 중 정확히 하나의 색으로 칠해져 있으며, 정확히 하나의 조각에 속한다. 어떤 두 길이 하나의 건물을 공유하며 같은 색으로 칠해져 있다면 두 길은 연결되어 있다. 서로 연결된 길은 같은 조각에 속하고, 연결되지 않은 길은 다른 조각에 속하도록 조각을 나눈다. 다음 서울과학고등학교는 정확히 세 개의 조각으로 쪼개진다.정후는 서울과학고등학교에 심어놓은 스파이에게 명령하여 길에 색을 Q 번 새로 칠한다. 길을 새로 칠할 때마다 서울과학고등학교가 정확히 몇 개의 조각으로 분열하는지 정후에게 알려주자.단, 길의 색을 새로 칠할 때, 이전에 칠해져 있던 색과 같을 수 있음에 주의하라. 새로 칠한 길은 그 길에 다시 새로운 색이 칠해지지 않는 한 지워지지 않는다.Q 개의 줄에 걸쳐, i번째 줄에는 i번째로 주어진 명령을 처리한 뒤 조각의 개수를 나타내는 하나의 정수를 출력한다.",15.0,"자료 구조,해시를 사용한 집합과 맵,트리,트리를 사용한 집합과 맵,",1.6299239385111015,24914
/problem/2957,이진 탐색 트리,"이진 탐색 트리는 모든 노드가 많아야 2개의 자식 노드를 가지고 있는 트리이고, 각 노드에는 수가 하나씩 쓰여있다. 만약 어떤 노드에 쓰여 있는 수가 X라면, 그 노드의 왼쪽 서브트리에는 X보다 작은 수, 오른쪽 서브트리에는 X보다 큰 수만 저장되어 있어야 한다.1보다 크거나 같고, N보다 작거나 같은 수 N개가 한 번씩 등장하는 수열이 입력으로 주어진다. 이 수열을 이용해서 이진 탐색 트리를 만들려고 한다. 이제 배열의 첫 번째 수를 루트 노드로 놓고, 다른 나머지 수들을 순서대로 삽입하면서 이진 탐색 트리를 만들려고 한다. 즉, 첫 번째 수를 제외한 모든 수에 대해서 insert(X,root)를 실행하는 것과 같다. 그 함수는 다음과 같다. 이진 탐색 트리에 삽입하는 함수는 다음과 같다.insert(number X, node N)    카운터 C값을 1 증가시킨다    if X가 노드 N에 있는 수보다 작다면        if N의 왼쪽 자식이 없다면            X를 포함하는 새 노드를 만든 뒤, N의 왼쪽 자식으로 만든다        else            insert(X, N의 왼쪽 자식)    else (X가 노드 N에 있는 수보다 크다면)        if N의 오른쪽 자식이 없다면            X를 포함하는 새 노드를 만든 뒤, N의 오른쪽 자식으로 만들기        else            insert(X, N의 오른쪽 자식)각 수를 삽입한 후에 C의 값을 출력하는 프로그램을 작성하시오. 카운터 C의 값은 0으로 초기화되어 있다.N개의 줄에 각 수가 트리에 삽입된 후에 카운터 C값을 한 줄에 하나씩 출력한다.",16.0,"자료 구조,트리를 사용한 집합과 맵,",1.6262305415025935,2957
/problem/23883,알고리즘 수업 - 선택 정렬 3,"오늘도 서준이는 선택 정렬 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.N개의 서로 다른 양의 정수가 저장된 배열 A가 있다. 선택 정렬로 배열 A를 오름차순 정렬할 경우 K 번째 교환되는 수를 구하자.N이 매우 커서 시간 초과를 고민하고 있는 우리 서준이를 도와주자.크기가 N인 배열에 대한 선택 정렬 의사 코드는 다음과 같다.selection_sort(A[1..N]) { # A[1..N]을 오름차순 정렬한다.    for last <- N downto 2 {        A[1..last]중 가장 큰 수 A[i]를 찾는다        if (last != i) then A[last] <-> A[i]  # last와 i가 서로 다르면 A[last]와 A[i]를 교환    }}K 번째 교환되는 두 개의 수를 작은 수부터 한 줄에 출력한다. 교환 횟수가 K 보다 작으면 -1을 출력한다.",12.0,"자료 구조,정렬,트리를 사용한 집합과 맵,",1.6167079829325826,23883
/problem/20541,앨범정리,"지혜는 컴퓨터에 있는 사진들을 정리하기 위해 앨범정리 프로그램을 만들었다. 지혜가 만든  앨범정리 프로그램은 기본적으로 ""album"" 앨범이 존재하며 ""album"" 앨범은 절대로 삭제할 수 없다. 프로그램을 실행시키면 ""album"" 앨범부터 시작하여 명령어들을 통해 앨범 삭제/추가, 사진 삭제/추가, 현재앨범 이동 등을 할 수 있다. 앨범정리 프로그램은 다음과 같은 명령어 들로 구성 되어 있다. 수행할 명령어의 개수 $N$이 주어질 때 각 명령어 수행 후 문자열 출력이 필요한 명령어에 대해서 문자열을 출력한다.mkalb	명령어 수행후: 현재 앨범에 속해있는 앨범 중 동일한 이름을 가진 앨범이 존재하여 앨범이 생성되지 않았으면 ""duplicated album name""을 출력합니다. 그렇지 않다면 아무것도 출력하지 않습니다.mkalb $S$		현재 앨범에 $S$ 의 이름을 가진 앨범을 생성합니다.현재 앨범에 속해있는 앨범 중 동일한 이름을 가진 앨범이 존재하면 앨범을 생성하지 않습니다.rmalb	명령어 수행후: 삭제된 앨범의 개수와 사진의 개수를 공백으로 구분하여 출력합니다.rmalb $S$		현재 앨범에 속해있는 앨범 중 $S$ 의 이름을 가진 앨범이 존재한다면, 해당 앨범을 삭제합니다.삭제된 앨범에 속한 모든 앨범과 사진들 또한 삭제됩니다.rmalb -1		현재 앨범에 속해있는 앨범이 존재한다면, 이름이 사전순으로 가장 빠른 앨범을 삭제 합니다.삭제된 앨범에 속한 모든 앨범과 사진들 또한 삭제됩니다.rmalb 0		현재 앨범에 속해있는 모든 앨범을 삭제 합니다.삭제된 앨범에 속한 모든 앨범과 사진들 또한 삭제됩니다.rmalb 1		현재 앨범에 속해있는 앨범이 존재한다면, 이름이 사전순으로 가장 늦은 앨범을 삭제 합니다. 삭제된 앨범에 속한 모든 앨범과 사진들 또한 삭제됩니다.insert	명령어 수행후: 현재 앨범에 속해있는 사진 중에 동일한 이름을 가진 사진이 존재하여 사진이 삽입되지 않았으면 ""duplicated photo name""을 출력합니다. 그렇지 않다면 아무것도 출력하지 않습니다.insert $S$		현재 앨범에 $S$ 의 이름을 가진 사진을 삽입합니다.현재 앨범에 속해있는 사진 중 동일한 이름을 가진 사진이 존재하면 사진을 삽입하지 않습니다.delete	명령어 수행후: 삭제된 사진의 개수를 출력합니다.delete $S$		현재 앨범에 속해있는 사진 중 $S$ 의 이름을 가진 사진이 존재한다면, 해당 사진을 삭제합니다.delete -1		현재 앨범에 속해있는 사진이 존재한다면, 이름이 사전순으로 가장 빠른 사진을 삭제 합니다.delete 0		현재 앨범에 속해있는 모든 사진을 삭제합니다.delete 1		현재 앨범에 속해있는 사진이 존재한다면, 이름이 사전순으로 가장 늦은 사진을 삭제 합니다. ca	명령어 수행후: 현재 앨범 이름을 출력합니다.ca $S$		현재 앨범에 속해있는 앨범 중 $S$ 의 이름을 가진 앨범으로 이동합니다.현재 앨범에 속해있는 앨범 중 $S$ 의 이름을 가진 앨범이 없다면 현재 앨범에 머무릅니다.ca ..		현재 앨범의 상위 앨범으로 이동합니다.현재 앨범이 최상위 앨범인 ""album"" 앨범이라면 현재 앨범에 머무릅니다.ca /		최상위 앨범인 ""album"" 앨범으로 이동합니다.""A가 B에 속해있다""라는 것은 A의 바로 하위에 B가 있다는 것을 의미합니다. 만약 A가 B에 속해있고, B가 C에 속해있는 경우, A는 C에 속해 있는 것이 아닙니다.문제 본문에 나와있는 앨범정리 프로그램 명령어의 설명에 따라 적절한 문자열을 출력한다.",16.0,"자료 구조,해시를 사용한 집합과 맵,구현,문자열,트리,트리를 사용한 집합과 맵,",1.6101027690644907,20541
/problem/17230,문제집 만들기,"민규는 요즘 알고리즘 과외를 받고 있다. 민규에게는 매우 무서운 과외 선생님 준표가 있는데, 준표는 민규에게 매일 문제집을 한 권씩 만들어주려고 한다. 준표가 생각하기에 몇몇 문제는 민규가 처음부터 풀기엔 너무 어렵기 때문에 문제 간의 관계를 정리하여 표로 남겨두고자 한다.예를 들어, a번 문제를 풀기 위해 b번 문제를 먼저 풀어야 한다면 a b로 기술한다. 문제집을 만드는 중간에 생각이 바뀌면 준표는 표를 수정할 수 있으며, a번을 풀기 위해선 b번을 풀어야 하는 동시에 b번을 풀기 위해선 a번을 풀어야 하는 모순된 상황이 없도록 주의하며 작성한다.준표는 x번부터 y번까지의 문제들로 문제집을 만들었을 때 민규가 처음부터 끝까지 문제집을 전부 풀 수 있는지 알고 싶다. 하지만 준표는 APC 준비 때문에 너무 바빠서 이 작업을 할 시간이 없다. 바쁜 준표를 위해 프로그램을 작성해주자.1 x y 의 입력이 들어왔을 때, 민규가 현재 x번부터 y번까지의 문제들로 구성된 문제집을 전부 풀 수 있으면 ""YES"", 그렇지 않다면 ""NO""를 출력하라.",18.0,"자료 구조,해시를 사용한 집합과 맵,세그먼트 트리,트리를 사용한 집합과 맵,",1.6050611072426006,17230
/problem/22030,총 쏘기,"두 명이 같이 하는 인터넷 슈팅 게임이 있다. 이 게임은 폐허가 된 도시에서 빌딩들을 부수는 게임이다. 게임에서 바닥인 수평선 위에 $N$개의 빌딩이 왼쪽에서 오른쪽으로 서 있다. 빌딩은 왼쪽에서 오른쪽으로 순서대로 1부터 $N$의 정수로 나타낸다. 각 빌딩의 바닥으로부터의 높이는 수열 $A_i$ $(1 \le i \le N)$로 나타내고, $1$부터 $N$까지의 서로 다른 정수로 주어진다. 두 명의 플레이어는 모든 빌딩보다 왼쪽의 같은 위치에 있다. 시간 $i$($\ge 1$)에 두 명의 플레이어는 동시에 각 한발씩 총을 발사하고, 총알은 발사한 위치에서 수평으로 오른쪽으로 날아간다. 두 총알의 속도는 동일하다. 플레이어는 총알의 발사 높이를 바닥으로부터의 거리 $H$로 결정한다. $H$는 $1$이상 $N+1$이하의 정수이다. 두 플레이어는 동일한 발사 높이를 선택할 수 있다. 플레이어의 총알 발사 높이가 $H$인 경우, $A_i \ge H$를 만족하는 파괴되지 않은 가장 왼쪽의 빌딩이 이 총알로 파괴된다. 이 조건을 만족하는 빌딩이 없다면, 아무 일도 일어나지 않는다. 만약 두 플레이어가 발사한 총알에 대해 이 조건을 만족하는 빌딩이 동일하다면, (두 총알의 속도는 동일하기 때문에) 이 하나의 빌딩만 파괴된다. 특별히, 두 플레이어의 발사 높이가 같다면, 항상 하나의 빌딩만 파괴된다. 예를 들어, $A_1 = 2, A_2 = 1$이고, 처음에 두 플레이어가 모두 $H = 1$을 발사 높이로 결정하였다면, 이 두 총알로 빌딩 $1$만 파괴된다. 문제는 $N$개 빌딩들의 높이가 입력으로 주어질 때, 모든 빌딩을 파괴할 수 있는 최소 시간과 각 시간에 두 플레이어의 총알 발사 높이를 찾는 것이다.첫째 줄에 두 플레이어가 모든 빌딩을 파괴하기 위한 최소 시간 $T$를 출력한다.",30.0,"자료 구조,그래프 이론,세그먼트 트리,트리를 사용한 집합과 맵,",1.6039871242065293,22030
/problem/1068,트리,"트리에서 리프 노드란, 자식의 개수가 0인 노드를 말한다.트리가 주어졌을 때, 노드 하나를 지울 것이다. 그 때, 남은 트리에서 리프 노드의 개수를 구하는 프로그램을 작성하시오. 노드를 지우면 그 노드와 노드의 모든 자손이 트리에서 제거된다.예를 들어, 다음과 같은 트리가 있다고 하자.현재 리프 노드의 개수는 3개이다. (초록색 색칠된 노드) 이때, 1번을 지우면, 다음과 같이 변한다. 검정색으로 색칠된 노드가 트리에서 제거된 노드이다.이제 리프 노드의 개수는 1개이다.첫째 줄에 입력으로 주어진 트리에서 입력으로 주어진 노드를 지웠을 때, 리프 노드의 개수를 출력한다.",11.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,트리,",기준,1068
/problem/13005,행복한 나무,"어떤 나무가 있다. 이 나무는 우리가 익히 아는 자료구조인 트리와 같이 생겼는데, 1~N번까지 N개의 정점을 가지고 있다. 1번 정점을 루트로 하는 이 트리에는 각 노드와 간선에는 하나의 숫자가 쓰여져 있다. 민주는 알고리즘 캠프가 끝나고 휴양림을 갔다가 이 나무를 발견했다. 나무를 보던 민주는 문득 나무의 몇몇 정점이 슬퍼보였다. 민주는 알고리즘 캠프가 끝나서 너무 기쁘기 때문에, 몇몇 정점을 잘라 나무를 행복하게 만들어주고 싶다.어떤 정점 v가 슬프다는 것은 v아래의 부분트리(subtree)들 중 dist(v, u) > au를 만족하는 정점 u가 하나 이상 존재한다는 것이다. 이때 au는 정점 u에 쓰여있는 숫자이며, dist(v, u)는 v에서 u로 가는 경로에 존재하는 간선들에 적힌 숫자들의 합이다.민주는 키보드보다 무거운 물건은 들 수 없기 때문에, 정점을 자를 때에는 트리의 말단 정점(leaves)만 자를 수 있다. 트리의 말단 정점이란, 해당 정점으로부터 연결된 자식 정점이 존재하지 않는 정점을 말한다. 자세히 설명하자면 말단 정점과 연결된 정점은 해당 정점의 부모 정점밖에 없다. 즉, 연결된 정점이 하나밖에 없는 정점을 말단 노드라고 부를 수 있는데, 그 중 루트 정점은 트리를 구성하는 정점의 개수가 총 1개 -정점 노드밖에 존재하지 않을 때- 에만 말단 정점이라고 할 수 있다.민주는 이 복잡한 나무가 행복해질 때까지 정점 노드를 자르려고 한다. 이때 민주가 잘라야하는 정점의 최소 개수는 몇 개일까?아래 그림의 1)과 같은 나무가 있을 때, 이 나무에서 잘려나가는 정점들은 최소는 다음의 2) ~ 6)의 5개가 된다.한 줄에 나무가 행복해지기 위해 잘라야하는 말단 정점의 최소 개수를 출력하라.",16.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,트리,",1.8111466765403748,13005
