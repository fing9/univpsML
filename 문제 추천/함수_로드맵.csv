내용링크,제목,문제,정답 비율,문제번호,한글유무,level,분류,별칭
/problem/1003,피보나치 함수,"다음 소스는 N번째 피보나치 수를 구하는 C++ 함수이다.int fibonacci(int n) {    if (n == 0) {        printf(""0"");        return 0;    } else if (n == 1) {        printf(""1"");        return 1;    } else {        return fibonacci(n‐1) + fibonacci(n‐2);    }}fibonacci(3)을 호출하면 다음과 같은 일이 일어난다.fibonacci(3)은 fibonacci(2)와 fibonacci(1) (첫 번째 호출)을 호출한다.fibonacci(2)는 fibonacci(1) (두 번째 호출)과 fibonacci(0)을 호출한다.두 번째 호출한 fibonacci(1)은 1을 출력하고 1을 리턴한다.fibonacci(0)은 0을 출력하고, 0을 리턴한다.fibonacci(2)는 fibonacci(1)과 fibonacci(0)의 결과를 얻고, 1을 리턴한다.첫 번째 호출한 fibonacci(1)은 1을 출력하고, 1을 리턴한다.fibonacci(3)은 fibonacci(2)와 fibonacci(1)의 결과를 얻고, 2를 리턴한다.1은 2번 출력되고, 0은 1번 출력된다. N이 주어졌을 때, fibonacci(N)을 호출했을 때, 0과 1이 각각 몇 번 출력되는지 구하는 프로그램을 작성하시오.각 테스트 케이스마다 0이 출력되는 횟수와 1이 출력되는 횟수를 공백으로 구분해서 출력한다.",32.637%,1003,1,8.0,"다이나믹 프로그래밍,","동적계획법,동적 계획법,다이나믹프로그래밍,"
/problem/1026,보물,"옛날 옛적에 수학이 항상 큰 골칫거리였던 나라가 있었다. 이 나라의 국왕 김지민은 다음과 같은 문제를 내고 큰 상금을 걸었다.길이가 N인 정수 배열 A와 B가 있다. 다음과 같이 함수 S를 정의하자.S = A[0] × B[0] + ... + A[N-1] × B[N-1]S의 값을 가장 작게 만들기 위해 A의 수를 재배열하자. 단, B에 있는 수는 재배열하면 안 된다.S의 최솟값을 출력하는 프로그램을 작성하시오.첫째 줄에 S의 최솟값을 출력한다.",68.305%,1026,1,7.0,"그리디 알고리즘,수학,정렬,","탐욕법,"
/problem/1131,숫자,"자연수 N이 주어졌을 때, N의 각 자리수를 K제곱 한 후에 그 합을 구하는 함수를 SK(N)이라고 하자. 예를 들어, S2(65) = 62 + 52 = 61이다.이제 다음과 같은 수열을 하나 만들어보자. N, SK(N), SK(SK(N)), … 이때, A와 B와 K가 주어졌을 때, A보다 크거나 같고, B보다 작거나 같은 모든 N으로 각각 수열을 만들었을 때, 그 수열에서 가장 작은 수의 합을 구하는 프로그램을 작성하시오.첫째 줄에 문제의 정답을 출력한다.",32.143%,1131,1,16.0,"깊이 우선 탐색,다이나믹 프로그래밍,그래프 이론,그래프 탐색,","depth first,depthfirst,동적계획법,동적 계획법,다이나믹프로그래밍,그래프이론,bfs,dfs,"
/problem/1357,뒤집힌 덧셈,"어떤 수 X가 주어졌을 때, X의 모든 자리수가 역순이 된 수를 얻을 수 있다. Rev(X)를 X의 모든 자리수를 역순으로 만드는 함수라고 하자. 예를 들어, X=123일 때, Rev(X) = 321이다. 그리고, X=100일 때, Rev(X) = 1이다.두 양의 정수 X와 Y가 주어졌을 때, Rev(Rev(X) + Rev(Y))를 구하는 프로그램을 작성하시오첫째 줄에 문제의 정답을 출력한다.",52.659%,1357,1,5.0,"구현,문자열,","스트링,"
/problem/1386,f와 g,"$N$개의 정수 $a_1, a_2, \dots, a_N$이 주어진다. 함수 $f$와 $g$는 다음과 같이 정의한다.\[f(x,k) = (x + a_1)^k + (x + a_2)^k + \cdots + (x + a_N)^k\]\[g(t,k) = f(0,k) + f(1,k) + \cdots + f(t,k)\]두 정수 $T$와 $K$, 그리고 $N$개의 정수가 주어졌을때, $g(T,i)$를 $10^9+7$로 나눈 나머지를 구해보자. ($0 \le i \le k$)$g(T, 0), g(T, 1), \dots, g(T, K)$를 $10^9 +7$로 나눈 나머지를 공백 한 칸으로 구분해 출력한다.",4.255%,1386,1,25.0,"분할 정복,고속 푸리에 변환,수학,","dnc,푸리에변환,컨볼루션,convolution,"
/problem/1399,보물의 위치,"dig라는 함수를 다음과 같이 정의하자.dig(x) = x (0 ≤ x ≤ 9)dig(x) = dig(x의 모든 자리수의 합) (x ≥ 10)예를 들어, dig(49) = dig(13) = dig(4) = 4오민식은 아주 낡은 지도를 가지고 보물을 찾아 헤매는 사냥꾼의 두목이다. 낡은 지도에는 보물을 어떻게 찾아야 하는지가 나와 있다.지금 오민식은 북쪽을 보고 있고, 현재 좌표는 (0, 0)이다. 북쪽은 Y좌표가 증가하는 방향, 동쪽은 X좌표가 증가하는 방향이다.오민식은 다음과 같은 작업을 K번 반복하면 보물의 위치를 찾을 수 있다. 골드 넘버는 1부터 시작한다.dig(골드 넘버)만큼 앞으로 간다. 그리고 90도 오른쪽으로 회전한다.골드 넘버에 M을 곱한다.오민식의 마지막 위치. 즉, 보물의 위치를 출력하는 프로그램을 작성하시오.각각의 테스트 케이스에 대해 보물의 위치를 X Y 형태로 출력한다.",21.784%,1399,1,16.0,"애드 혹,수학,정수론,",
/problem/1407,2로 몇 번 나누어질까,"자연수 N이 주어지면, 자연수를 유지하면서 N을 2로 몇 번까지 나눌 수 있는지를 생각해 볼 수 있다. 즉, N의 모든 약수 중 2의 거듭제곱 꼴이면서 가장 큰 약수를 생각하는 것이다. 예를 들어 15의 경우는 2로 한 번도 나눌 수 없으므로 2^0 = 1이 해당되고, 40의 경우는 2로 세 번까지 나눌 수 있으므로 2^3 = 8이 해당된다. 이러한 약수를 함수값으로 가지는 함수 f(x)를 정의하자. 즉, f(15) = 1이고, f(40) = 8이다.두 자연수 A, B(A≤B)가 주어지면, A 이상 B 이하의 모든 자연수에 대해서, 그 자연수의 모든 약수 중 2의 거듭제곱 꼴이면서 가장 큰 약수들의 총 합을 구하는 프로그램을 작성하시오. 즉 아래와 같은 수식의 값을 구해야 한다.f(A) + f(A+1) + ... + f(B-1) + f(B)첫째 줄에 구하고자 하는 수를 출력한다.",42.136%,1407,1,12.0,"수학,",
/problem/1537,새로운 연산자,"양의 정수 N이 주어졌을 때, 다음과 같은 다섯 개의 함수를 정의 했다.Sum(N)은 N의 모든 자리수를 더한 값이다.Prod(N)은 N의 모든 자리수를 곱한 값이다.Prod3(N)은 N의 자리수중 가장 큰 3개를 곱한 값이다. 만약 N이 3자리보다 작다면 Prod3(N) = Prod(N)이다.Smallest(N)은 N의 가장 작은 자리수이다.First(N)은 N의 가장 맨 앞 자리수이다.세준이는 @라는 연산자를 정의 했다.X@Y = 5*Prod3(X) + First(X) * Sum(Y) + Smallest(Y)이다.Sum(47) = 4+7 = 11Prod(2322) = 2*3*2*2 = 24Prod3(2322) = 3*2*2 = 12Prod3(47) = Prod(47) = 4*7 = 28Smallest(427) = 2First(427) = 412034@217 = 5 * (4*3*2) + 1 * (2+1+7) + 1 = 131올바른 식은 다음과 같이 재귀적으로 정의 된다.X는 올바른 식이다.만약, A가 올바른 식이고, B가 올바른 식이라면, A@B도 올바른 식이다.위의 규칙에 의해서 생성되지 않은 식은 모두 올바르지 않은 식이다.X와 G가 주어졌을 때, X를 G로 만드는 올바른 식을 구하는 프로그램을 작성하시오. 만약 불가능하다면 -1을 출력한다.첫째 줄에 올바른 식에 들어가는 @의 최소 값을 출력한다.",25.641%,1537,1,16.0,"데이크스트라,그래프 이론,","다익,다익스트라,데이크스트라,그래프이론,"
/problem/1539,이진 검색 트리,"P는 크기가 N인 배열이다. P에는 0보다 크거나 같고, N-1보다 작거나 같은 정수가 중복 없이 채워져 있다. 이진 검색 트리는 루트가 있는 이진 트리로, 각각의 노드에 정수 값이 저장되어 있는 트리이다. 이진 검색 트리를 P배열을 이용해서 만드는 법은 다음과 같다. 일단 root를 만들고 거기에 P[0]의 값을 넣은 후에 다음과 같은 과정을 거친다.for (int i=1; i<=n-1; i++) {    insert(root, P[i]);}여기서 insert함수는 다음과 같다.void insert(Vertex V, int X) {    if (x < V에 저장되어 있는 수) {        if (V가 왼쪽 자식이 있으면) {            insert(V의 왼쪽 자식, X);        } else {            V의 왼쪽 자식을 새로 만들고, 그 곳에 X를 저장함        }    } else {        if (V가 오른쪽 자식이 있으면) {            insert(V의 오른쪽 자식, X);        } else {            V의 오른쪽 자식을 새로 만들고, 그 곳에 X를 저장함        }    }}N과, 배열 P에 있는 수가 주어졌을 때, P로 이진 검색 트리를 만들었을 때, 모든 노드의 높이의 합을 출력하는 프로그램을 작성하시오. 트리의 높이는 루트에서 부터의 거리 + 1이다.주어진 P배열로 이진 검색 트리를 만들었을 때, 높이의 합을 출력한다. 이 값은 2^63보다 작다.",34.270%,1539,1,16.0,"자료 구조,트리,트리를 사용한 집합과 맵,","자료구조,자구,trees,집합,맵,셋,딕셔너리,dictionary,map,set,bbst,트리,tree,"
/problem/1543,문서 검색,"세준이는 영어로만 이루어진 어떤 문서를 검색하는 함수를 만들려고 한다. 이 함수는 어떤 단어가 총 몇 번 등장하는지 세려고 한다. 그러나, 세준이의 함수는 중복되어 세는 것은 빼고 세야 한다. 예를 들어, 문서가 abababa이고, 그리고 찾으려는 단어가 ababa라면, 세준이의 이 함수는 이 단어를 0번부터 찾을 수 있고, 2번부터도 찾을 수 있다. 그러나 동시에 셀 수는 없다.세준이는 문서와 검색하려는 단어가 주어졌을 때, 그 단어가 최대 몇 번 중복되지 않게 등장하는지 구하는 프로그램을 작성하시오.첫째 줄에 중복되지 않게 최대 몇 번 등장하는지 출력한다.",43.461%,1543,1,6.0,"브루트포스 알고리즘,문자열,","완전탐색,완전 탐색,브루트포스,bruteforce,brute force,완탐,스트링,"
/problem/1596,영식함수,"적어도 두 자리 이상의 어떤 자연수 N이 있을 때, 영식함수 F는 다음과 같이 정의할 수 있다.F(N) = 서로 인접한 자리수의 숫자의 차이를 큰 자리수부터 차례대로 쓴 수.예를 들어, F(5913) = 482, F(1198) = 081 = 81, F(666) = 00 = 0 이다.영식이는 영식함수를 이용해서 수열을 하나 만들 수 있는데, N, F(N), F(F(N)), .... 와 같이 한자리 숫자가 나타날 때 까지 수열을 만들 수 있다. 마지막 한자리 숫자를 숫자 N의 지문이라고 부른다. 예를 들어, N=5913일 때 얻을 수 있는 수열은 5913, 482, 46, 2 이다. 5913의 지문은 2이다.어떤 숫자를 영식함수에 넣고 돌렸을 때, 지문이 7이 나오는 수를 행운의 수라고 한다.A보다 크거나 같고, B보다 작거나 같은 행운의 수의 개수를 구하는 프로그램을 작성하시오.A보다 크거나 같고, B보다 작거나 같은 행운의 수의 개수를 출력한다.",38.462%,1596,1,0.0,0,
/problem/1632,Line Fighter,"동물원에서 막 탈출한 원숭이 한 마리가 세상구경을 하고 있다. 그는 수학을 매우 좋아하는 원숭이였다. 그래서 그는 N개의 직선을 가지고 기발한 문제를 생각해냈다.문제는 이렇다. 좌표평면상에 N개의 직선과 상수 K가 주어진다. 직선은 모두 fi(x) = ai * x + bi의 꼴로 나타낼 수 있다. 그랬을 때 함수 g(x)를 {f1(x), f2(x), ..., fN(x)}의 중간값으로 정의하면, g(x) = K가 되는 x를 모두 찾는 문제이다.첫째 줄에 g(x) = K 인 x의 구간의 시작과 끝을 출력한다. 각 수는 소수점 넷째자리에서 반올림하여 출력한다. 만약 x가 무한대로 발산하는 경우, 양의 무한대는 +inf, 음의 무한대는 -inf 로 출력하면 된다. g(x) = K를 만족하는 x가 존재하지 않는다면 ""impossible""을 출력하면 된다. 답이 되는 구간이 1개 이하인 경우만 입력으로 들어온다.",15.152%,1632,1,19.0,"구현,수학,정렬,",
/problem/1651,숌 코드,"영식이는 민식이가 괴롭힐 때, 동생 하영이에게 문자메시지를 보내서 도움을 요청한다. 민식이는 영식이의 이러한 행동을 알아채고 영식이의 모든 문자메시지를 감시하기 시작했다. 영식이는 동생과의 문자메시지를 민식이에게 들키기 싫어서 무엇인가 비밀 코드를 만들고 싶어했다. 마침 영식이의 왼쪽, 왼쪽 자리에 앉아있는 다솜이가 새로운 문자열 인코딩 방법을 개발했다. 다솜이의 새로운 문자열 인코딩 방법으로 문자열을 코드로 변환한 것을 숌 코드라고 한다.숌 코드는 숌 코드 인코딩방법으로 문자를 코드로 바꾼다. 인코딩 방법은 알파벳의 집합 S가 주어졌을 때, 집합에 속하는 각 알파벳이 숌 코드에 일치하는 구조로 이루어져 있다. 이때, 어떤 알파벳과 코드를 연결시켜주는 함수를 이용한다고 생각하면 쉽다. 그리고, 코드는 항상 0과 1로만 이루어져 있다. 코드가 비어있을 수도 있다.예를 들어 S={a,b,c,d}이고, 알파벳을 코드로 바꿔주는 함수 f과 다음과 같이 정의되어있다고 할 수 있다. f(a) = 1, f(b) = 1010, f(c) = 01, f(d) = 10101함수 f 속에는 반드시 알파벳 한 글자만 들어가는 것이 아니라, 여러 문자가 계속해서 들어갈 수 있다. 이때, 함수는 주어진 문자열을 앞에서부터 차례대로 코드로 바꿔주어 이를 합치는 형식으로 작동한다. 따라서, 위의 예제에서 f(cac) = 01101이다.만약 어떤 코드를 두 개의 문자열로 해석할 수 있으면, 이 코드를 애매한 코드라고 한다. 영식이는 애매한 코드를 사용하지 않는다고 한다.만약 어떤 코드를 세 개 이상의 문자열로 해석할 수 있으면, 이 코드를 정말 애매한 코드라고 한다. 예를 들어, 위의 예제에서 애매한 코드는 10101이다. 10101은 ba, acc, d 로 해석할 수 있다.입력으로 코드가 주어진다. 코드는 0과 1로만 이루어져 있다. 영식이는 어떤 문자열 S를 숌 코드 인코딩 방법을 이용해서 코드로 바꾸려고 한다. 다솜이가 개발한 인코딩방법은 아직 불완전하다. 다솜이가 할 일은 영식이가 코드로 인코딩해서 보낸 문자메시지의 내용을 3개 혹은 그 이상으로 문자열로 바꿀 수 있는지 확인하는 작업이다.코드가 주어졌을 때, 3개 이상의 문자열로 바꿀 수 있는 숌 코드의 가장 짧은 길이를 구하는 프로그램을 작성하시오.첫째 줄에 세 개 이상의 문자열로 해석할 수 있는 숌 코드의 최소 길이를 출력한다. 만약 그러한 코드가 없다면 -1을 출력한다.",16.667%,1651,1,0.0,0,
/problem/1786,찾기,"워드프로세서 등을 사용하는 도중에 찾기 기능을 이용해 본 일이 있을 것이다. 이 기능을 여러분이 실제로 구현해 보도록 하자.두 개의 문자열 P와 T에 대해, 문자열 P가 문자열 T 중간에 몇 번, 어느 위치에서 나타나는지 알아내는 문제를 '문자열 매칭'이라고 한다. 워드프로세서의 찾기 기능은 이 문자열 매칭 문제를 풀어주는 기능이라고 할 수 있다. 이때의 P는 패턴이라고 부르고 T는 텍스트라고 부른다.편의상 T의 길이를 n, P의 길이를 m이라고 하자. 일반적으로, n ≥ m이라고 가정해도 무리가 없다.  n<m이면 어차피 P는 T중간에 나타날 수 없기 때문이다. 또, T의 i번째 문자를 T[i]라고 표현하도록 하자. 그러면 물론, P의 i번째 문자는 P[i]라고 표현된다.      1 2 3 4 5 6 7 8 9 …T : [ A B C D A B C D A B D E ]      | | | | | | XP : [ A B C D A B D ]      1 2 3 4 5 6 7문자열 P가 문자열 T 중간에 나타난다는 것, 즉 문자열 P가 문자열 T와 매칭을 이룬다는 것이 어떤 것인지 위와 아래의 두 예를 통해 알아보자. 위의 예에서 P는, T의 1번 문자에서 시작하는 매칭에 실패했다. T의 7번 문자 T[7]과, P의 7번 문자 P[7]이 서로 다르기 때문이다.그러나 아래의 예에서 P는, T의 5번 문자에서 시작하는 매칭에 성공했다. T의 5～11번 문자와 P의 1～7번 문자가 서로 하나씩 대응되기 때문이다.      1 2 3 4 5 6 7 8 9 …T : [ A B C D A B C D A B D E ]              | | | | | | |P :         [ A B C D A B D ]              1 2 3 4 5 6 7가장 단순한 방법으로, 존재하는 모든 매칭을 확인한다면, 시간복잡도가 어떻게 될까? T의 1번 문자에서 시작하는 매칭이 가능한지 알아보기 위해서, T의 1～m번 문자와 P의 1～m번 문자를 비교한다면 최대 m번의 연산이 필요하다. 이 비교들이 끝난 후, T의 2번 문자에서 시작하는 매칭이 가능한지 알아보기 위해서, T의 2～m+1번 문자와 P의 1～m번 문자를 비교한다면 다시 최대 m번의 연산이 수행된다. 매칭은 T의 n-m+1번 문자에서까지 시작할 수 있으므로, 이러한 방식으로 진행한다면 O( (n-m+1) × m ) = O(nm) 의 시간복잡도를 갖는 알고리즘이 된다.더 좋은 방법은 없을까? 물론 있다. 위에 제시된 예에서, T[7] ≠ P[7] 이므로 T의 1번 문자에서 시작하는 매칭이 실패임을 알게 된 순간으로 돌아가자. 이때 우리는 매칭이 실패라는 사실에서, T[7] ≠ P[7] 라는 정보만을 얻은 것이 아니다. 오히려 i=1…6에 대해 T[i] = P[i] 라고 하는 귀중한 정보를 얻지 않았는가? 이 정보를 십분 활용하면, O(n)의 시간복잡도 내에 문자열 매칭 문제를 풀어내는 알고리즘을 설계할 수 있다.P 내부에 존재하는 문자열의 반복에 주목하자. P에서 1, 2번 문자 A, B는 5, 6번 문자로 반복되어 나타난다. 또, T의 1번 문자에서 시작하는 매칭이 7번 문자에서야 실패했으므로 T의 5, 6번 문자도 A, B이다.따라서 T의 1번 문자에서 시작하는 매칭이 실패한 이후, 그 다음으로 가능한 매칭은 T의 5번 문자에서 시작하는 매칭임을 알 수 있다! 더불어, T의 5～6번 문자는 P의 1～2번 문자와 비교하지 않아도, 서로 같다는 것을 이미 알고 있다! 그러므로 이제는 T의 7번 문자와 P의 3번 문자부터 비교해 나가면 된다.이제 이 방법을 일반화 해 보자. T의 i번 문자에서 시작하는 매칭을 검사하던 중 T[i+j-1] ≠ P[j]임을 발견했다고 하자. 이렇게 P의 j번 문자에서 매칭이 실패한 경우, P[1…k] = P[j-k…j-1]을 만족하는 최대의 k(≠j-1)에 대해 T의 i+j-1번 문자와 P의 k+1번 문자부터 비교를 계속해 나가면 된다.이 최대의 k를 j에 대한 함수라고 생각하고, 1～m까지의 각 j값에 대해 최대의 k를 미리 계산해 놓으면 편리할 것이다. 이를 전처리 과정이라고 부르며, O(m)에 완료할 수 있다.이러한 원리를 이용하여, T와 P가 주어졌을 때, 문자열 매칭 문제를 해결하는 프로그램을 작성하시오.첫째 줄에, T 중간에 P가 몇 번 나타나는지를 나타내는 음이 아닌 정수를 출력한다. 둘째 줄에는 P가 나타나는 위치를 차례대로 공백으로 구분해 출력한다. 예컨대, T의 i～i+m-1번 문자와 P의 1～m번 문자가 차례로 일치한다면, i를 출력하는 식이다.",29.846%,1786,1,16.0,"KMP,문자열,","스트링,"
/problem/2180,소방서의 고민,"여기는 울릉도 소방서이다. 소방차가 한 대 밖에 없어서 여러 차례 중앙 정부에 소방차 증차를 요청하였으나 아직도 증차가 실현되지 않고 있다. 그런데 오늘 믿어지지 않는 엄청난 일이 발생하고 말았다. 여러 건의 화재가 동시에 발생한 것이다. 소방서의 고민은 한 대의 소방차를 이용하여 어떤 순서로 화재를 진압하는 것이 모든 화재를 진압하는데 걸리는 시간을 최소화하느냐는 것이다. 지체할 시간이 없다. 그 순서를 아주 빨리 정해야 한다. 당신의 도움이 필요하다.다행히 다음과 같은 정보를 얻을 수 있다. 한 화재 사건에 소방차 도착이 늦으면 늦을수록 화재를 진압하는데 걸리는 시간이 같거나 길어진다. 화재의 종류에 따라서, 화재 발생 후 소방차가 t초 후에 도착하면 화재를 진압하는데 걸리는 시간은 at +b와 같이 1차 함수의 형태로 나타나게 된다. 물론 a와 b는 음수는 아니다. 화재 종류별로 a, b의 값이 일반적으로 다르게 나타나게 된다.모든 화재 사건은 시각 0에서 발생하였다. 당신은 모든 화재를 진압하는데 걸리는 최소 시간이 얼마인지를 알고 싶다. 소방차의 이동 시간은 고려하지 않고 0으로 가정하며, 한 화재 진압이 완전히 끝나기 전에는 소방차가 다른 화재 현장으로 이동할 수 없다.첫째 줄에 모든 화재를 진압하는데 걸리는 최소 시간을 40,000으로 나눈 나머지를 출력한다.",18.868%,2180,1,16.0,"그리디 알고리즘,정렬,","탐욕법,"
/problem/2195,문자열 복사,"어떤 원본 문자열 S가 주어졌을 때, 이 문자열의 부분을 복사하여 P라는 새로운 문자열을 만들려고 한다. 복사를 할 때에는 copy(s, p) 이라는 함수를 이용하는데, 이는 S의 s번 문자부터 p개의 문자를 P에 복사해서 붙인다는 의미이다.예를 들어 S=""abaabba"", P=""aaabbbabbbaaa""인 경우를 생각해 보자. 이때는 copy(3, 2), copy(4, 3), copy(2, 2), copy(5, 2), copy(2, 3), copy(1, 1) 를 수행하여 P를 만들 수 있다. 각 단계별로 P는 ""aa"", ""aaabb"", ""aaabbba"", …와 같이 변하게 된다.이와 같은 copy 연산을 이용하여 S에서 P를 만들려고 하는데, 이때 가능하면 copy 함수를 조금 사용하려고 한다.S와 P가 주어졌을 때, 필요한 copy 함수의 최소 사용횟수를 구하는 프로그램을 작성하시오.첫째 줄에 copy 함수의 최소 사용횟수를 출력한다.",52.267%,2195,1,11.0,"그리디 알고리즘,문자열,","탐욕법,스트링,"
/problem/2237,수열 축소,"N개의 양수로 이루어진 수열 {A[1], A[2], …, A[N]}이 있다. 이 수열에 A[i]에서 A[i+1]을 빼는 축소 연산을 적용하려 한다. 축소 연산은 CON이라는 함수로 나타낼 수 있으며, CON(A, i)를 수행하면 {A[1], A[2], …, A[i-1], A[i] - A[i+1], A[i+2], …, A[N]}의 수열을 얻는다.이와 같은 축소 연산을 N-1번 적용하면, 수열의 길이가 N-1, N-2, …, 1이 되어 결국에는 한 수만 남게 된다. 이와 같은 축소 연산을 적용하여 T라는 수를 만들 수 있는지 알아보려 한다.예를 들어 {12, 10, 4, 3, 5}라는 수열에 다음과 같은 축소 연산을 적용하면 4를 만들 수 있다.CON( {12, 10, 4, 3, 5}, 2 ) = {12, 6, 3, 5}CON( {12, 6, 3, 5}, 3 ) = {12, 6, -2}CON( {12, 6, -2}, 2 ) = {12, 8}CON( {12, 8}, 1 ) = {4}첫째 줄부터 사용한 순서대로 축소 연산에서의 i를 출력한다. 항상 가능한 경우만 입력으로 주어지며, 답이 여러 개 존재할 경우에는 임의의 하나를 출력하면 된다.",44.624%,2237,1,17.0,"다이나믹 프로그래밍,","동적계획법,동적 계획법,다이나믹프로그래밍,"
/problem/2247,실질적 약수,"두 자연수 A와 B가 있을 때, A = BC를 만족하는 자연수 C를 A의 약수라고 한다. 모든 자연수 N은 1과 자기 자신(N)을 약수로 갖게 된다.실질적 약수(actual divisor)라는 것이 있다. 자연수 N의 약수들 중에서 1과 자기 자신(N)을 제외한 약수를 실질적 약수라고 한다. 따라서 6의 실질적 약수는 2, 3이며, 13의 실질적 약수는 없다.SOD(Sum Of Divisor)라는 함수를 정의하자. SOD(n)은 정수 n의 모든 실질적 약수의 합을 가리킨다. 따라서 SOD(6) = 5이며, SOD(13) = 0이다. 한편, CSOD(Cumulative SOD)라는 함수도 정의해 볼 수 있다. CSOD(n)은 SOD(1) + SOD(2) + … + SOD(n)이라고 하자.CSOD(n)을 구하는 프로그램을 작성하시오.첫째 줄에 CSOD(n)을 1,000,000으로 나눈 나머지를 출력한다.",36.416%,2247,1,11.0,"수학,정수론,",
/problem/2268,수들의 합 7,"N개의 수 A[1], A[2], …, A[N] 이 주어졌을 때, 함수 Sum(i, j)는 A[i] + A[i+1] + … + A[j]를 구하는 함수이다. (i > j일 경우에는 A[j] + A[j+1] + ... + A[i]) A가 주어졌을 때, Sum(i, j)를 구하는 것은 매우 쉬운 문제이다. 이러한 (i, j)가 여러 개 주어졌을 때도 별로 어려운 문제는 아니다.Sum함수와 더불어 Modify라는 함수를 정의하자. Modify(i, k)를 수행하면 A[i] = k가 되는 함수이다. Sum함수와 Modify 함수의 사용 목록이 주어졌을 때, 이에 해당하는 연산을 하는 프로그램을 작성하시오. 두 함수를 섞어서 사용할 수도 있다.Sum 함수의 개수만큼 각 줄에 Sum 함수의 리턴값을 출력한다.",30.432%,2268,1,15.0,"세그먼트 트리,자료 구조,","구간트리,세그트리,fenwick,펜윅,자료구조,자구,"
/problem/2280,정사각형과 점,"[0, 1]×[0, 1]의 정사각형과 그 안(정사각형의 테두리 및 꼭짓점 포함)에 N개의 점들 P[1], P[2], …, P[N]이 있다. 이 점들과 정사각형의 네 꼭짓점을 연결하여 임의의 두 점이 직접 혹은 간접적으로 연결되어 있게 하려 한다. 이와 같이 만든 그래프의 간선의 길이를 합한 것을 Len(P) 라고 정의하자.N개의 점들의 위치를 임의로 바꾸면 Len(P)의 값도 이에 따라 변하게 된다. Len(P)가 최소가 되도록 하는 점들의 집합을 P'라고 하자. 즉, Len을 점들의 집합 P에 대한 함수로 생각했을 때, Len의 최솟값이 Len(P')가 되는 것이다.N개의 점들을 잘 배치하여 Len이 최소가 되도록 할 때, 각각의 점들을 이동시킨 거리가 최소가 되도록 하는 프로그램을 작성하시오.즉, Len(P"")=Len(P')를 만족하는 P""들 중에서, |P[1]-P""[1]| + |P[2]-P""[2]| + … + |P[N]-P""[N]|이 최소가 될 때, 그 최솟값을 구하는 것이다.각 테스트 케이스마다 답을 출력한다. 절대/상대 오차는 10-3까지 허용한다.",66.667%,2280,1,0.0,0,
/problem/2324,이진 행렬,"어떤 n×m(1 ≤ n, m ≤ 100)의 이진 행렬이 있다. 이진 행렬이라는 것은 0과 1로만 된 행렬이라는 뜻이다.이 행렬에서 Reverse(x, y)라는 연산이 정의되어 있다. 행렬의 (x, y)에 원래 저장되어 있던 값을 k라고 하자. 이 함수를 수행하면 (x, y)와 인접(상하좌우)해 있는 칸들 중에서 그 행렬 값이 k인 위치로 퍼져 나가면서, 행렬 값을 1-k(즉, 0을 1로, 1을 0으로)로 바꾼다. x는 행 번호, y는 열 번호이다. 행렬의 행 번호와 열 번호는 1부터 시작한다.예를 들어 11000111과 같은 1×8의 행렬이 있다고 해 보자. Reverse(1,1)을 수행하면 00000111이 되고, Reverse(1,4)를 수행하면 11111111이 된다.이와 같은 Reverse 함수를 최소로 이용하여, 전체 행렬에 저장되어 있는 값을 같은 값(0 또는 1)로 바꾸는 것이 목적이다.첫째 줄에 함수의 호출 회수 K를 출력한다. 다음 K개의 줄에는 x, y를 출력한다. 이는 차례로 Reverse(x, y)의 함수를 호출하였다는 의미이다.",34.615%,2324,1,20.0,"너비 우선 탐색,브루트포스 알고리즘,그래프 이론,그래프 탐색,휴리스틱,","breadthfirst,breadth first,완전탐색,완전 탐색,브루트포스,bruteforce,brute force,완탐,그래프이론,bfs,dfs,"
/problem/2328,그래프의 해시,"해시(hash)란 주어진 데이터를 하나의 수로 표현하는 것을 말한다. 예를 들어서 ""1024""와 같은 문자열을 1024 라는 수로 생각하는 방법은 해시의 한 예이다. 또, 영단어에서 'a'부터 'z'까지를 1에서 26까지의 수로 생각하여 그 수들을 합한 것도 해시의 한 예이다. 이런 해시를 적용하면 ""ab""와 같은 영단어는 3이라는 수가 되고, ""ace""와 같은 영단어는 9라는 수가 된다.당신은 그래프에 대해서 해시 함수를 하나 설계하였다. 당신이 설계한 해시 값은 그래프의 1번 정점에서 2번 정점까지 가는 모든 경로들의 경로 값의 최소공배수로 정의한다. 경로 값은 경로 상에 있는 모든 간선의 가중치들의 최대공약수로 정의한다. 물론 경로에서는 같은 정점이 두 번 이상 나와서는 안 된다.예를 들어 위와 같은 그래프를 보자. 위의 그래프에서 1번 정점에서 2번 정점까지 가는 경로는 1-4-2, 1-3-2의 두 개가 있다. 각 경로의 경로 값은 2(16, 6의 최대공약수), 3(3, 9의 최대공약수)이 되고, 따라서 해시 값은 6(2, 3의 최소공배수)이 된다.하나의 그래프가 주어졌을 때, 그 그래프의 해시 값(위에서 설계한 해시 함수를 이용하여 계산한)을 구해내는 프로그램을 작성하시오.첫째 줄에 해시 값을 출력한다. 이 값은 10진수로 1000자리를 넘지 않는다.",39.062%,2328,1,16.0,"임의 정밀도 / 큰 수 연산,그래프 이론,그래프 탐색,수학,정수론,소수 판정,에라토스테네스의 체,","빅인티저,빅데시멀,biginteger,bigdecimal,그래프이론,bfs,dfs,소수,소수판별,소수판정,prime,sieve,에라체,소수,prime,"
/problem/2354,비교교환,"n개의 수 A[1], A[2], …, A[n]이 있을 때, 1 ≤ a < b ≤ n인 두 정수 a, b에 대해서 비교교환(Compare-Exchange) 함수는 다음과 같이 정의된다.CE(a, b)    if(A[a] > A[b])        Swap(A[a], A[b]);즉, 두 값을 비교하여 더 작은 값이 앞으로 오도록 하는 함수이다. 이와 같은 CE함수를 나열해 놓은 것을 CE프로그램이라 한다. 어떤 CE프로그램을 수행한 후, 어떤 A[1], A[2], …, A[n]에 대해서도 A[1]에 최솟값(A[1], A[2], …, A[n] 중에서)이 저장될 경우, 그 CE프로그램을 최소-탐색-CE프로그램 이라고 한다. 특히 이와 같은 최소-탐색-CE프로그램들 중에서 프로그램 내의 CE함수 호출을 임의로 하나 제거해도 최소-탐색-CE프로그램인 것을 안정적인-최소-탐색-CE프로그램 이라고 한다.어떤 CE프로그램이 주어졌을 때, 여기에 프로그램의 마지막 부분에 CE함수 호출을 최소로 추가하여 안정적인-최소-탐색-CE프로그램이 되도록 하려 한다.첫째 줄에 추가할 CE함수 호출 횟수의 최솟값을 출력한다.",45.161%,2354,1,13.0,0,
/problem/2826,함수의 리턴값,"창영이는 다음과 같은 함수를 작성했다.int fun() {    int ret = 0;    for (int a = X1; a <= Y1; ++a)        for (int b = X2; b <= Y2; ++b)        ...            for (int <n-th> = XN; <n-th> <= YN; ++<n-th>)                ret = (ret + 1)  % 1000000007;    return ret;}<N-th>는 영어 알파벳의 N번째 소문자이다. Xi와 Yi는 100,000보다 작거나 같은 양의 정수 또는 해당 루프 바깥 쪽에서 등장한 변수가 될 수 있다.예를 들어, X3은 a, b, 또는 정수가 될 수 있다. Xi와 Yi중 적어도 하나는 변수 이름이 아닌 정수이며, 이는 모든 i에 해당된다.Xi, Yi의 값이 주어졌을 때, 함수의 리턴값을 출력하는 프로그램을 작성하시오.만약 (X1, Y1) = (1, 2), (X2, Y2) = (a, 3), (X3, Y3) = (1, b)라면, 함수는 다음과 같다.int fun() {    int ret = 0;    for (int a = 1; a <= 2; ++a)        for (int b = a; b <= 3; ++b)            for (int c = 1; c <= b; ++c)                ret = (ret + 1)  % 1000000007;    return ret;}첫째 줄에 함수의 리턴값을 출력한다.",17.722%,2826,1,21.0,"다이나믹 프로그래밍,누적 합,","동적계획법,동적 계획법,다이나믹프로그래밍,구간합,부분합,rangesum,"
/problem/2900,프로그램,"창영이가 에러를 찾기 위해서 디버깅을 하고 있다. 이 프로그램은 크기가 N이고 0으로 채워져있는 배열을 a를 만들고, 아래 something 함수를 호출한다.void something(int jump) {    int i = 0;    while (i < N) {        a[i] = a[i] + 1;        i = i + jump;    }}창영이는 함수를 K번 호출하려고 한다. 각각 호출할 때, 인자로 넘기는 jump의 값은 X1, X2, X3, ... Xk 순서이다.이렇게 호출한 뒤에는 배열의 값이 정상적으로 들어갔는지를 확인하려고 한다. 확인은 총 Q번 하고, 매번 확인을 할 때마다 L과 R(L ≤ R)을 정한뒤, 그 구간의 배열의 합을 구한다. 즉, a[L] + a[L+1] + ... + a[R]을 구한다.함수를 호출할 때 필요한 X의 값과 창영이가 확인한 횟수 Q가 주어졌을 때, 확인한 결과(배열의 합)을 구하는 프로그램을 작성하시오.출력은 총 Q줄이다. 창영이가 확인하는데 사용한 L과 R이 주어졌을 때, a[L] + a[L+1] + a[L+2] ... + a[R]을 출력한다. ",32.996%,2900,1,13.0,"수학,정수론,누적 합,","구간합,부분합,rangesum,"
/problem/2957,이진 탐색 트리,"이진 탐색 트리는 모든 노드가 많아야 2개의 자식 노드를 가지고 있는 트리이고, 각 노드에는 수가 하나씩 쓰여있다. 만약 어떤 노드에 쓰여 있는 수가 X라면, 그 노드의 왼쪽 서브트리에는 X보다 작은 수, 오른쪽 서브트리에는 X보다 큰 수만 저장되어 있어야 한다.1보다 크거나 같고, N보다 작거나 같은 수 N개가 한 번씩 등장하는 수열이 입력으로 주어진다. 이 수열을 이용해서 이진 탐색 트리를 만들려고 한다. 이제 배열의 첫 번째 수를 루트 노드로 놓고, 다른 나머지 수들을 순서대로 삽입하면서 이진 탐색 트리를 만들려고 한다. 즉, 첫 번째 수를 제외한 모든 수에 대해서 insert(X,root)를 실행하는 것과 같다. 그 함수는 다음과 같다. 이진 탐색 트리에 삽입하는 함수는 다음과 같다.insert(number X, node N)    카운터 C값을 1 증가시킨다    if X가 노드 N에 있는 수보다 작다면        if N의 왼쪽 자식이 없다면            X를 포함하는 새 노드를 만든 뒤, N의 왼쪽 자식으로 만든다        else            insert(X, N의 왼쪽 자식)    else (X가 노드 N에 있는 수보다 크다면)        if N의 오른쪽 자식이 없다면            X를 포함하는 새 노드를 만든 뒤, N의 오른쪽 자식으로 만들기        else            insert(X, N의 오른쪽 자식)각 수를 삽입한 후에 C의 값을 출력하는 프로그램을 작성하시오. 카운터 C의 값은 0으로 초기화되어 있다.N개의 줄에 각 수가 트리에 삽입된 후에 카운터 C값을 한 줄에 하나씩 출력한다.",25.156%,2957,1,16.0,"자료 구조,트리를 사용한 집합과 맵,","자료구조,자구,집합,맵,셋,딕셔너리,dictionary,map,set,bbst,트리,tree,"
/problem/3217,malloc,"메모리 할당 명령을 시뮬레이팅하는 프로그램을 작성하시오.메모리는 100,000개의 연속된 공간이고, 1번부터 100,000번까지 번호가 매겨져 있다. 초기에 모든 공간은 할당되지 않은 상태이다.명령어의 종류는 다음 중 하나이다.var=malloc(size);이 함수은 처음 등장하는 size개의 연속된 공간을 찾아, 할당해주는 함수이다. 이 함수의 리턴값은 할당된 공간의 제일 처음 주소이다. 만약, 할당해줄 수 있는 공간이 없다면 0을 리턴한다. (100 ≤ size ≤ 100,000)free(var);이 함수는 이전에 malloc을 통해 var에 할당된 공간을 할당 해제시켜주고, var에 0을 저장하는 함수이다. 만약, var가 이미 0이라면, 아무 일도 일어나지 않는다.print(var);var에 저장된 값을 출력하는 함수이다.모든 명령은 세미콜론(';')으로 끝난다. 변수는 알파벳 소문자로 이루어져 있으며, 항상 네글자이다. 서로 다른 변수의 개수는 1,000개보다 작거나 같다. 모든 변수는 0으로 초기화되어있다.print가 나올 때 마다 결과를 한 줄에 하나씩 출력한다.",22.654%,3217,1,15.0,"자료 구조,구현,연결 리스트,","자료구조,자구,링크드리스트,"
/problem/3807,고창영 비밀번호의 비밀,"창영이는 비밀번호를 만드는 함수가 있다.	이 함수의 뜻은 최소공배수가 n인 모든 쌍을 찾아, 그 합을 구하는 것이다.	예를 들어, 최소공배수가 6인 쌍은 5가지가 있다. (1, 6), (2, 6), (2, 3), (3, 6), (6, 6)	따라서 f(6)은 f(6) = (1+6) + (2+6) + (2+3) + (3+6) + (6+6) = 7+8+5+9+12 = 41 이 된다.	창영이의 온라인 저지 비밀번호를 만든 n이 주어졌을 때, 비밀번호를 구하는 프로그램을 작성하시오.	각 테스트 케이스에 대해서, 한 줄에 하나씩 f(n)값을 1000000007으로 나눈 나머지를 출력한다.",38.843%,3807,1,20.0,"수학,정수론,",
/problem/3828,잘못된 계산,"김상근 교수는 수치표를 만드는 새로운 컴퓨팅 엔진을 개발했다. 이 엔진은 단일 변수 다항식 함수의 값을 계산하기 위해 만들어졌다.다항식 함수가 f(x) = x2 + 2x + 1인 경우에 결과로 나오는 값은 1 (=f(0)), 4 (=f(1)), 9 (=f(2)), 16 (=f(3)), 25 (=f(4))가 있다.하지만, 상근이는 음주 코딩을 하다가 실수를 하였다. 따라서, 이 엔진은 항상 하나의 특정한 값에 대해서만 결과를 잘못 출력한다. 따라서, 위의 다항식 함수를 입력했을 때, 1, 4, 9, 16, 25 대신에 1, 4, 12, 16, 25가 나올 수 있다.상근이의 엔진이 출력한 값이 주어졌을 때, 몇 번째 결과가 잘못 계산된 것인지 구하는 프로그램을 작성하시오.각 테스트 케이스에 대해서, 잘못 계산된 값이 몇 번째 값인지 출력한다. f(i)의 결과가 잘못되었다면, i를 출력한다.",43.902%,3828,1,16.0,"브루트포스 알고리즘,다이나믹 프로그래밍,가우스 소거법,선형대수학,수학,","완전탐색,완전 탐색,브루트포스,bruteforce,brute force,완탐,동적계획법,동적 계획법,다이나믹프로그래밍,선형대수,"
/problem/3958,롤러코스터 타기,"상근이와 친구들은 놀이 공원에 놀러갔다. 이 놀이 공원에는 많은 종류의 롤러코스터가 있고, 상근이는 각 롤러코스터를 미리 분석해 왔다. 상근이는 각 롤러코스터를 탔을 때 느낄 수 있는 재미를 숫자로 적어왔다. 하지만, 롤러코스터를 탈 때 마다 느끼는 재미는 점점 떨어진다.상근이는 i번 롤러코스터를 k번째로 탔을 때 느끼는 재미를 함수로 정의해 왔다. f(i, k) = ai - (k-1)2*bi. 만약 f(i,k)값이 양수가 아니라면, 그 롤러코스터를 타면, 더이상 재미를 느끼지 않는 것이다.상근이는 재미의 합이 최대가 되게 롤러코스터를 타려고 한다.출력은 Q개의 줄을 출력한다. 각각의 시간 Ti에 대해서, 상근이가 느낄 수 있는 최대 재미 점수를 출력한다.",46.667%,3958,1,15.0,"다이나믹 프로그래밍,수학,","동적계획법,동적 계획법,다이나믹프로그래밍,"
/problem/4256,트리,"이진 트리는 매우 중요한 기본 자료 구조이다. 아래 그림은 루트 노드가 유일한 이진 트리이다. 모든 노드는 최대 2개의 자식 노드를 가질 수 있으며, 왼쪽 자식이 순서가 먼저이다. 노드 n개로 이루어진 이진 트리를 BT라고 하자. BT의 노드는 1부터 n까지 유일한 번호가 매겨져 있다.아래 그림에 나와있는 BT의 루트는 3번 노드이다. 1번 노드는 오른쪽 자식만 가지고 있고, 4와 7은 왼쪽 자식만 가지고 있다. 3과 6은 왼쪽과 오른쪽 자식을 모두 가지고 있다. 나머지 노드는 모두 자식이 없으며, 이러한 노드는 리프 노드라고 부른다.BT의 모든 노드를 순회하는 방법은 전위 순회(preorder), 중위 순회(inorder), 후위 순회(postorder)로 총 세 가지가 있다. 이 세 방법은 아래에 C 스타일의 의사 코드로 나와 있다. BT의 노드 v에 대해서, v.left는 왼쪽 자식, v.right는 오른쪽 자식을 나타낸다. v가 왼쪽 자식이 없으면 v.left는 ∅와 같고, 오른쪽 자식이 없으면 v.right는 ∅와 같다.BT를 전위 순회, 중위 순회한 결과가 주어진다. 즉, 위의 함수 중 preorder(root node of BT)와 inorder(root node of BT)를 호출해서 만든 리스트가 주어진다. 두 순회한 결과를 가지고 다시 BT를 만들 수 있다. BT의 전위, 중위 순회한 결과가 주어졌을 때, 후위 순회했을 때의 결과를 구하는 프로그램을 작성하시오.예를 들어, 위의 그림을 전위 순회하면 3,6,5,4,8,7,1,2, 중위 순회하면 5,6,8,4,3,1,2,7이 된다. 이를 이용해 후위 순회하면 5,8,4,6,2,1,7,3이 된다.각 테스트 케이스마다 후위 순회한 결과를 출력 한다.",56.474%,4256,1,14.0,"분할 정복,재귀,트리,","dnc,trees,"
/problem/4673,셀프 넘버,"셀프 넘버는 1949년 인도 수학자 D.R. Kaprekar가 이름 붙였다. 양의 정수 n에 대해서 d(n)을 n과 n의 각 자리수를 더하는 함수라고 정의하자. 예를 들어, d(75) = 75+7+5 = 87이다.양의 정수 n이 주어졌을 때, 이 수를 시작해서 n, d(n), d(d(n)), d(d(d(n))), ...과 같은 무한 수열을 만들 수 있다. 예를 들어, 33으로 시작한다면 다음 수는 33 + 3 + 3 = 39이고, 그 다음 수는 39 + 3 + 9 = 51, 다음 수는 51 + 5 + 1 = 57이다. 이런식으로 다음과 같은 수열을 만들 수 있다.33, 39, 51, 57, 69, 84, 96, 111, 114, 120, 123, 129, 141, ...n을 d(n)의 생성자라고 한다. 위의 수열에서 33은 39의 생성자이고, 39는 51의 생성자, 51은 57의 생성자이다. 생성자가 한 개보다 많은 경우도 있다. 예를 들어, 101은 생성자가 2개(91과 100) 있다. 생성자가 없는 숫자를 셀프 넘버라고 한다. 100보다 작은 셀프 넘버는 총 13개가 있다. 1, 3, 5, 7, 9, 20, 31, 42, 53, 64, 75, 86, 9710000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 출력하는 프로그램을 작성하시오.10,000보다 작거나 같은 셀프 넘버를 한 줄에 하나씩 증가하는 순서로 출력한다.",48.741%,4673,1,6.0,"브루트포스 알고리즘,구현,수학,","완전탐색,완전 탐색,브루트포스,bruteforce,brute force,완탐,"
/problem/4800,대충 정렬,"많은 프로그래밍 언어는 라이브러리 함수를 이용해서 배열의 값을 정렬할 수 있다. 이 함수를 사용해서 정렬을 하려면, less(x,y)와 같은 비교 함수를 작성해야 한다.less(x,y)는 정렬한 순서에서 x가 y의 앞에 온다면 true를 리턴하는 함수이다. 이러한 함수는 항상 이치에 맞아야 한다. 즉, 서로 다른 두 원소 x와 y에 대해서, less(x,y)와 less(y,x)중 하나만 true가 되어야 한다.이 문제에서는 수열에서 도치가 발생하지 않은 경우에 정렬되었다고 한다. less(x,y)에 대한 도치란, 크기가 n인 배열 A에서 less(A[j], A[i]) = true (0 ≤ i < j < n)를 만족하는 경우이다. (less(A[i], A[j]) = false와 동등한 의미가 아니다)안타깝게도 어떤 프로그래머는 이런 비교 함수를 신중하게 작성하지 않는다. 이러한 경우에는 절대로 수열을 정렬할 수 없는 경우가 생길수도 있다.less함수의 결과가 모두 주어진다. 이때, 이 함수를 이용해서 정렬했을 때, 도치의 개수를 최소가 되는 순열을 구하는 프로그램을 작성하시오.각 테스트 케이스에 대해서, 주어진 비교 함수로 정렬했을 때, 도치의 개수가 최소가 되는 순열을 출력한다. 그 다음 줄에는 그 순열에서 도치의 개수를 출력한다. 만약, 도치의 개수가 같은 순열이 여러 개인 경우에는 사전 순으로 앞서는 것을 출력한다.",54.545%,4800,1,17.0,"비트마스킹,브루트포스 알고리즘,다이나믹 프로그래밍,비트필드를 이용한 다이나믹 프로그래밍,","비트필드,완전탐색,완전 탐색,브루트포스,bruteforce,brute force,완탐,동적계획법,동적 계획법,다이나믹프로그래밍,동적계획법,비트마스크,비트dp,"
/problem/4802,함수 오버로딩,"프로그래머는 다양한 프로그래밍언어에서 함수를 오버로드할 수 있다. 함수 오버로드란 같은 함수의 이름을 가지고 있으나, 매개변수가 다른 함수이다. 그러나, Ada와 같은 언어에서는 리턴 타입도 오버로드할 수 있다. 즉, 같은 이름과 매개변수를 가지고 있으나, 리턴타입이 다를 수도 있는 것이다.다음은 함수 오버로딩의 예이다.char f(float x, int y)char f(float x, float y)float f(float x, float y)float g(float x, int y)float g(int x, float y)위와 같이 함수 선언이 있을 때, 아래와 같은 변수 선언과 함수 호출을 포함한 프로그램을 작성할 수 있다.float a = 1.0, b = 2.0;int c = 3;float d = g(c, f(a, b));f의 처음 두 선언은 위의 함수 f에 해당하지 않는다. 하지만, 세 번째 함수는 f(<float>, <float>)와 같은 형식이라 매개변수의 타입이 같고, 리턴 타입도 g(<int>, <float>)의 float과 같기 때문에 해당한다. 따라서, 3번째 f와 두 번째 g를 사용할 수 있다.이렇게 3번째 f와 2번째 g를 사용했기 때문에, 다음과 같이 숫자와 함께 표현할 수 있다.d = g2(c, f3(a, b))하지만, 위의 함수 선언을 이용해서 c = g(a, f(a, c))는 사용할 수 없다.마지막으로 다음과 같은 함수 선언이 있다고 하자.float x(float w)int x(float w)char y(float v)char y(int v)위와 같은 선언에서 다음과 같은 함수 호출은 애매모호(ambiguous)하기 때문에 사용할 수 없다.float a = 1.0char c = y(x(a))입력으로 주어진 각 함수 호출에 대해서, 만약 어떤 함수를 사용했는지 유일하게 결정할 수 있다면, 입력 함수 호출에서 함수의 이름에 시리얼 넘버만 추가한 형태로 출력한다. 만약, 해당하는 함수가 없어서 호출할 수 없다면 ""impossible""을 출력하고, 애매모호해서 호출하는 방법이 여러 가지라면, ""ambiguous""를 출력하고, 경우의 수를 출력한다. 만약, 1000가지를 넘는 방법으로 호출할 수 있다면 ""> 1000""을 경우의 수 대신 출력한다.",16.667%,4802,1,20.0,"애드 혹,다이나믹 프로그래밍,트리에서의 다이나믹 프로그래밍,구현,파싱,문자열,트리,","동적계획법,동적 계획법,다이나믹프로그래밍,트리dp,스트링,trees,"
/problem/4924,정수론 싫어,"정수론 중간고사를 마치고 집으로 돌아온 상근이는 패닉에 빠졌다. 유일하게 공부를 하지 않은 것이 오일러 피 함수(Euler's totient function, \(\varphi \))였는데, 그 함수에 관한 문제만 나왔기 때문이다. 상근이는 너무 억울했고, 직접 Totient 함수를 만들기로 했다.정수론에서 양의 정수의 소인수는 그 정수를 나머지 없이 나눌 수 있는 소수이다. 상근이는 $n \ge 2$에서 함수 $F(n)$을 곱이 $n$이 되는 감소하지 않는 소수의 리스트로 정의했다. 예를 들어, $F(8) = \ll 2,2,2 \gg$, $F(60) = \ll 2,2,3,5 \gg$, $F(71) = \ll 71 \gg$ 이다. $O(n)$은 $F(n)$의 길이이다. 예를 들어, $O(8) = 3$, $O(60) = 4$, $O(71) = 1$ 이 된다. 마지막으로, 양의 정수에 대해서 \(p(n)\)을 다음과 같이 정의했다.\(p(n) = \begin{cases} 0 & \text{if } n = 1 \\ -1 & \text{if } n \text{ is a prime number} \\ O(n) & \text {otherwise} \end{cases}\)아래 표에는 \(p(n)\)의 첫 20개 값이 나와있다.$n$$1$$2$$3$$4$$5$$6$$7$$8$$9$$10$$11$$12$$13$$14$$15$$16$$17$$18$$19$$20$$p(n)$$0$$-1$$-1$$2$$-1$$2$$-1$$3$$2$$2$$-1$$3$$-1$$2$$2$$4$$-1$$3$$-1$$3$$a \le b$를 만족하는 두 양의 정수 $a$와 $b$에 대해서, 상근이는 자신의 Totient 함수인 \(\varphi(a,b)\)를 다음과 같이 정의했다.\(\varphi (a,b)= ( \sum _{ k=a }^{ b }{ p(k) }  )  - (b-a+1)\)예를 들어, \(\varphi(1,4) = -4\), \(\varphi(16,16) = 3\), \(\varphi(8,12) = 4\) 이다.구간 $[L, U]$가 주어졌을 때, 가장 큰 값을 갖는 \(\varphi\)를 찾는 프로그램을 작성하시오.즉, $L \le U$를 만족하는 두 양의 정수 $L$과 $U$가 주어졌을 때, 가장 큰 \(\varphi(a,b)\) ($L \le a \le b \le U$) 를 찾는 프로그램을 작성하시오. 예를 들어, 구간 $[1,20]$에서 가장 큰 \(\varphi\)는 7이다. (\(\varphi(8,16)\))각 테스트 케이스마다 주어진 구간 $[L, U]$에서 찾을 수 있는 가장 큰 \(\varphi\) 값을 출력한다.",$3$,4924,1,16.0,"다이나믹 프로그래밍,수학,정수론,누적 합,소수 판정,에라토스테네스의 체,","동적계획법,동적 계획법,다이나믹프로그래밍,구간합,부분합,rangesum,소수,소수판별,소수판정,prime,sieve,에라체,소수,prime,"
/problem/5178,시간 초과,"지금껏 문제를 풀면서 시간 초과 메시지를 본 적이 있을 것이다.시간 초과의 이유엔 여러 가지가 있지만, 주로 제출한 코드의 시간복잡도가 문제에서 요구하는 최대 한도의 시간복잡도를 상회했을 때 발생한다.이번 문제를 풀면서 시간복잡도에 대한 이해도를 높이고 시간 초과 메시지를 덜 받도록 해보자.어떤 소스 코드가 주어지면 이 소스 코드의 시간복잡도를 계산하면 된다.물론 그냥 계산하기엔 너무 어려우므로, 다음과 같은 간소화된 방식으로 계산해보도록 하자.프로그램은 단 네 개의 명령어만을 가진다고 가정한다. 목록은 아래와 같다.basic : 사칙연산 혹은 값 할당 등의 기초적인 코드loop : 반복문의 시작endloop : 반복문의 끝endprogram : 프로그램의 종료프로그램 분석은 아래의 규칙에 따라 시행한다.위에 주어진 네가지 명령어만이 프로그램에 존재한다.loop문은 항상 하나의 전달 인자를 가지며, 대응되는 하나의 endloop문(loop의 시작 이후로 만나는 첫 endloop문)과 묶여 하나의 반복문이 된다.loop의 전달 인자는 x, y, 또는 양의 정수가 될 수 있으며, x, y는 상수이다. 프로그램 실행 도중 재할당되지 않는다. 이 전달인자만큼 루프를 반복하게 된다.만일 어떤 loop문 내에 basic 코드가 하나도 존재하지 않는다면 의미없는 루프이므로 전달인자의 값에 관계없이 그 loop를 즉시 종료하게 된다.만일 어떤 loop문 내에 basic 코드가 여러 개 존재하더라도 한 개의 basic 코드가 있는 것과 같이 생각해도 된다.basic 코드는 실행에 상수 시간이 걸린다.시간복잡도는 basic 구문의 실행 횟수를 함수로 나타낸 뒤 빅오 표기법을 사용하여 분석한다.빅오 표기법의 정의는 다음과 같다.어떤 임의의 양의 상수 c와 d를 잘 골라, 1 이상인 모든 x에 대하여 c*g(x) ≤ f(x) ≤ d*g(x)를 만족하게 할 수 있다면 f(x)의 빅오 표기는 O(g)이다.좀 더 쉽게 설명하면, 모든 상수부는 떼어내버릴 수 있다는 의미이다.예를 들면 4x 3의 빅오 표기는 x3가 된다.또한, 어떤 항보다 낮은 차수를 가지는 항들은 통째로 제거하는 것이 가능하다.예를 들어, x 3 + x2의 빅오 표기는 x3이 되며, x2 + 7의 빅오 표기는 x2가 된다.하지만 여러 서로 다른 변수가 섞여있다면 다른 항보다 작다고 확신할 수 없는 항들은 모두 표기해야 한다.예를 들어, x 2y + y2x + xy + x2 의 빅오 표기는 x2y + y2x가 되며, x2 + 17xy + y2 의 빅오 표기는 x2 + y2이 된다.각 테스트 케이스마다 Data Set K: 를 출력한 뒤, 입력으로 주어진 프로그램의 시간복잡도를 출력한다.",16.379%,5178,1,18.0,"볼록 껍질,기하학,구현,수학,파싱,문자열,","컨벡스헐,스트링,"
/problem/5430,AC,"선영이는 주말에 할 일이 없어서 새로운 언어 AC를 만들었다. AC는 정수 배열에 연산을 하기 위해 만든 언어이다. 이 언어에는 두 가지 함수 R(뒤집기)과 D(버리기)가 있다.함수 R은 배열에 있는 수의 순서를 뒤집는 함수이고, D는 첫 번째 수를 버리는 함수이다. 배열이 비어있는데 D를 사용한 경우에는 에러가 발생한다.함수는 조합해서 한 번에 사용할 수 있다. 예를 들어, ""AB""는 A를 수행한 다음에 바로 이어서 B를 수행하는 함수이다. 예를 들어, ""RDD""는 배열을 뒤집은 다음 처음 두 수를 버리는 함수이다.배열의 초기값과 수행할 함수가 주어졌을 때, 최종 결과를 구하는 프로그램을 작성하시오.각 테스트 케이스에 대해서, 입력으로 주어진 정수 배열에 함수를 수행한 결과를 출력한다. 만약, 에러가 발생한 경우에는 error를 출력한다.",19.956%,5430,1,11.0,"덱,파싱,구현,문자열,자료 구조,","스트링,자료구조,자구,"
/problem/5433,RNG,"현수는 새로운 게임을 만들고 있다. 이 게임은 어드벤쳐 게임으로 해적과 원숭이가 등장한다. 게임을 해본 사람들의 말에 의하면 엄청나게 재밌다고 한다.이 게임은 다양한 랜덤 요소를 포함하고 있다. 따라서, 현수는 랜덤 함수 생성기를 이용하려고 한다. 랜덤 함수 생성기는 줄여서 RNG라고 쓴다.각 RNG는 다음과 같은 식을 사용한다. x가 이전 랜덤 숫자 일때, y는 아래 식으로 구할 수 있다.y = ax2 + bx + c (mod 2n)a, b, c, n은 정수이다.현수는 게임을 테스트 하기 위하고 있다. 현수는 게임을 중단시키고 디버그 콘솔을 볼 수 있다. 디버그 콘솔에는 현재 생성된 랜덤 숫자 하나가 나타나 있다. 하지만, 현수는 프로그램을 역추적해 그 전의 랜덤 숫자를 알아내려고 한다.현재 랜덤 숫자(y)의 값과 a, b, c, n이 주어졌을 때, 이전 랜덤 숫자(x)를 구하는 프로그램을 작성하시오.각 테스트 케이스에 대해서, 이전 랜덤 숫자 x를 출력한다. (0 ≤ x < 2n) 만약, 가능한 x가 없거나, 두 개 이상 존재한다면 ""No unique solution""을 출력한다.",42.857%,5433,1,0.0,0,
/problem/5640,즐거운 색칠,"즐거운 색칠 문제는 다음과 같다.유한 집합 \(U\)와 \(\left| S_i \right| \le 3\)를 만족하는 집합 \(S_1,S_2,S_3,\dots ,S_m \subseteq U \) 가 있다.문제: 적어도 \(S_i\)의 한 원소가 다른 원소의 색과 다르게 할당하는 함수 \(f:U\mapsto \left\{ RED,BLUE \right\} \) 가 존재하는가?즐거운 색칠 문제가 주어졌을 때, 그러한 함수 \(f\)가 존재하는지 알아내는 프로그램을 작성하시오.각 테스트 케이스마다 함수 \(f\)가 존재하면 'Y', 아니면 'N'을 출력한다. 모든 정답은 한 줄에 붙여서 순서대로 출력한다.",41.176%,5640,1,15.0,"브루트포스 알고리즘,","완전탐색,완전 탐색,브루트포스,bruteforce,brute force,완탐,"
/problem/5811,낙하산 고리들,"레오나르도 다 빈치의 코덱스 아틀란티쿠스 에는 최초로 설계한 꽤 정교한 낙하산이 설명되어 있는데, 이 다 빈치의 낙하산은 피라미드 모양의 나무 구조를 통해 열리는 우산모양의 리넨 옷감으로 설계되어있다.스카이다이버 아드리안 니콜라스는 500년 이상 오래된 다 빈치의 디자인을 시험해보았다. 이를 위해, 사람의 몸을 다 빈치의 낙하산에 묶기 위한 최신식 초경량 구조를 사용하였다. 우리는 리넨 옷감에도 걸 수 있는 고리 구조를 사용하고자 한다. 각각의 고리는 유연하고 강한 소재로 만들어졌다. 모든 고리들은 열고 닫을 수 있으므로, 다른 고리들과 쉽게 연결될 수 있다. 체인은 고리 구조의 특별한 형태를 말한다. 아래에 있는 그림처럼, 각각의 고리들이 (최대 두 개의) 인접한 고리들과 차례대로 연결되어 있고, 시작과 끝이 있는 고리 구조는 체인이 된다. (시작과 끝에 있는 고리들은 각각 최대 하나의 다른 고리들과 연결된다.) 특히, 고리 하나도 마찬가지로 체인이다.하나의 고리가 세 개 이상의 다른 고리들과 연결된 고리 구조의 형태도 당연히 가능하다. 이러한 고리 구조에서, 어떤 하나의 고리를 열어서 없앤 후에 남은 다른 고리들이 모두 체인의 형태를 만들 때 (혹은 고리가 하나도 남지 않았을 때), 그 고리를 중요한 고리라고 한다. 다시 말해, 중요한 고리를 제거하면, 체인만 남게 된다.다음의 그림과 같이, 0번부터 6번까지 번호가 매겨진 7개의 고리를 생각해보자. 이 고리 구조에는 2개의 중요한 고리가 있다. 그 중 하나는 2번인데, 이 고리를 없애면 남은 고리들이 [1], [0, 5, 3, 4], 그리고 [6]의 체인이 된다. 다른 하나는 3번인데, 이 고리를 없애면 남은 고리들이 [1, 2, 0, 5], [4], 그리고 [6]의 체인이 된다. 만약 그 이외의 다른 고리들을 없애면, 체인이 아닌 것이 남아있게 된다. 예를 들어, 5번 고리를 없애면 [6]은 체인이 되지만, 0번, 1번, 2번, 3번, 그리고 4번 고리로 만들어진 고리 구조는 체인이 아니다.여러분이 할 일은 입력으로 주어지는 고리 구조에서, 중요한 고리의 개수를 세는 프로그램을 작성하는 것이다.처음에는, 서로 연결되지 않은 고리들의 개수가 주어진다. 다음에는, 고리 구조가 만들어 진다. 입력 중에 언제든지, 여러분은 현재 고리 구조에서 중요한 고리의 개수를 답해야 된다. 이를 위해 여러분은 3개의 함수를 구현해야한다.Init(N) - 처음에, 오직 한번 실행된다. 인자 N의 의미는 0부터 N - 1까지 번호가 붙은 N개의 고리들이 있다는 것을 의미한다.Link(A, B) - A번 고리와 B번 고리를 서로 연결함을 의미한다. A와 B는 다르고, A번 고리와 B번 고리는 현재 연결되어 있지 않다는 것을 보장한다. 이를 제외하고, A번 고리와 B번 고리 사이에는 다른 제약조건이 없다. (특히, 물리적인 조건과는 관계가 없다.) 또한, Link(A, B)와 Link(B, A)는 서로 같은 의미이다.CountCritical() — 현재의 고리 구조의 형태에서, 중요한 고리의 개수를 계산하여 반환한다.N = 7 개의 고리가 주어질 때를 생각해보자. 다음의 표는 가능한 호출 순서에 대해서, 각 호출에서 얻은 결과를 보여준다.함수 호출반환값Init(7) CountCritical()7Link(1,2) CountCritical()7Link(0,5) CountCritical()7Link(2,0) CountCritical()7Link(3,2) CountCritical()4Link(3,5) CountCritical()3Link(4,3) CountCritical()2CountCritical을 호출할 때 마다 결과를 한 줄에 하나씩 순서대로 출력한다.",2,5811,1,24.0,"많은 조건 분기,자료 구조,분리 집합,그래프 이론,구현,","케이스,케이스워크,케이스 워크,자료구조,자구,union,find,유니온,파인드,그래프이론,"
/problem/5812,크래이피쉬 글쓰는 기계,"활자 인쇄기를 발명한 독일 대장장이인 요하네스 구텐베르크는 레오나르도가 열렬히 존경하는 사람이었다. 레오나르도는 크래이피쉬 글쓰는 기계 — il gambero scrivano —로 불리는 매우 단순한 타자 기계를 설계하여 구텐베르크에게 존경을 표시하였다. 이것은 단순한 현대의 타자기와 매우 비슷하며, 단지 두 개의 명령어만 받아들인다: 하나는 그 다음 문자를 타자하는 것이고, 다른 하나는 가장 최근의 명령어들을 취소(undo)하는 것이다. 이 타자 기계의 주목할만한 특징은 취소 기능이며, 이는 매우 강력한 기능이다: 취소 명령은 자기자신, 즉 취소 명령어에 대해서도 적용될 수 있다.여러분이 할 일은 크래이피쉬 글쓰기 기계와 같이 동작하는 소프트웨어를 구현하는 것이다: 빈 텍스트에서 시작하고, 사용자가 입력한 명령어의 순서들을 받아들이고, 다음과 같이 텍스트의 현재 상황의 특정 위치에 대한 질의를 수행한다.Init() — 실행 초기에 인자가 없이 한번만 호출된다. 이 함수는 자료 구조를 초기화 하는데 사용될 수 있다. 이것은 결코 취소될 필요가 없을 것이다.TypeLetter(L) — a, …, z으로부터 선택된 하나의 소문자 L을 텍스트의 끝에 추가한다.UndoCommands(U) — 양의 정수 U에 대해, 가장 최근의 U 개의 명령어를 취소한다.GetLetter(P) — 음이 아닌 인덱스 P에 대해, 현재 텍스트에서 위치 P의 문자를 되돌려준다. 텍스트에서 첫 번째 문자의 인덱스는 0 이다. (이 질의는 명령어가 아니어서 취소 명령어에서는 무시된다.)Init()를 호출한 후에, 그 외의 루틴들은 임의의 순서로 0번 이상 호출 될 수 있다. U는 이전에 들어온 명령어들의 수를 초과하지 않음이 보장되며, P는 현재의 텍스트의 길이보다 작을 것이다 (현재 텍스트에서의 문자의 수).UndoCommands(U)에서는 이전의 U개의 명령어를 역순으로 취소한다: 만약 취소될 명령어가 TypeLetter(L)라면, 이것은 현재 텍스트의 끝에서부터 L을 삭제한다: 만약 취소될 명령어가 어떤 값 X에 대해 UndoCommands(X) 라면 이것은 이전의 X개의 명령어를 원래의 순서대로 다시 실행한다.하나의 가능한 호출순서에 대해서 각 호출후의 텍스트의 상태를 보인다.CallReturnsCurrent textInit()  TypeLetter(a) aTypeLetter(b) abGetLetter(1)babTypeLetter(d) abdUndoCommands(2) aUndoCommands(1) abdGetLetter(2)dabdTypeLetter(e) abdeUndoCommands(1) abdUndoCommands(5) abTypeLetter(c) abcGetLetter(2)cabcUndoCommands(2) abdGetLetter(2)dabdGetLetter에 의해 리턴된 문자를 한 줄에 하나씩 출력한다.","명령어와 질의의 전체 수가 1이상 1,000,000이하이다.
",5812,1,19.0,"자료 구조,희소 배열,","자료구조,자구,스파스어레이,sparse table,"
/problem/5813,이상적인 도시,"당대의 많은 이탈리아 과학자들과 예술가들처럼 다빈치는 도시 계획과 디자인에 대단한 관심이 있었다. 다빈치는 편안하고, 공간을 넓고 합리적으로 사용하며, 중세 시대 도시의 좁고 답답함과는 거리가 먼 이상적인 도시를 디자인할 계획을 가지고 있었다무한 개 네모 셀들의 격자 위에 N 개의 블록들을 놓아서 도시를 만든다. 각 셀은 좌표들의 쌍 (행, 열)로 나타낸다. (i, j) 셀이 주어지면, 인접한 셀들은 (i-1, j), (i+1, j), (i, j-1) 그리고 (i, j+1) 이다. 그리드 위에 놓여질 때, 각 블록은 정확히 하나의 셀을 덮는다. 블록은 1 ≤ i, j ≤ 231- 2 인 셀 (i, j) 에만 놓을 수 있다. 셀들 위에 놓여진 블록들을 나타낼 때, 셀들의 좌표를 사용할 것이다. 두 블록이 서로 인접한 셀들에 놓여지면 두 블록은 인접했다고 말한다. 이상적인 도시에서 모든 블록들은 도시안에 구멍이 없도록 연결된다. 다시 말해서, 셀들은 아래의 조건들을 만족해야만 한다.임의의 두 비어 있는 셀들에 대해서, 인접한 비어 있는 셀들로만 이동하는 방법으로 한 셀에서 다른 셀에 도달할 수 있는 경로가 적어도 하나 이상 존재한다.임의의 두 비어있지 않은 셀들에 대해서, 인접한 비어있지 않은 셀들로만 이동하는 방법으로 한 셀에서 다른 셀에 도달할 수 있는 경로가 적어도 하나 이상 존재한다.아래 그림 모두는 이상적인 도시가 아니다. 처음 두 개는 첫 번째 조건을 만족하지 않고, 세 번째 그림은 두 번째 조건을 만족하지 않고, 네 번째 그림은 두 조건 모두를 만족하지 않는다.도시 안을 이동할 때, 걸음은 한 블록에서 인접한 블록으로 이동하는 것을 말한다. 비어있는 셀들로는 이동할 수 없다. v0, v1, …, vN-1 을 그리드 위에 놓여 있는 N 개 블록들의 좌표라고 하자. 좌표 vi 와 vj 를 가진 임의의 서로 다른 두 블록들에 대해서, 그들간의 거리 d(vi, vj)는 이 블록들 중 하나에서 다른 곳으로 가는데 요구되는 걸음들의 최소 수로 정의된다.아래 그림은 좌표 v0 = (2, 5), v1 = (2, 6), v2 = (3, 3), v3 = (3, 6), v4 = (4, 3), v5 = (4, 4), v6 = (4, 5), v7 = (4, 6), v8 = (5, 3), v9 = (5, 4), 그리고 v10 = (5, 6) 를 가지는 N = 11 개의 블록들로 이루어진 이상적인 도시를 나타낸다. 그러면, d(v1, v3) = 1, d(v1, v8) = 6, d(v6, v10) = 2, 그리고 d(v9, v10) = 4 이다.당신은 모든 가능한 i < j 인 두 블록 쌍 vi와 vj에 대한 거리들의 합을 계산하는 프로그램을 작성해야 한다. 정확히 말하면, 프로그램은 다음의 합을 계산해야 한다.∑d(vi, vj), 단, 0 ≤ i < j ≤ N - 1구체적으로, 도시를 나타내는 N 과 두 배열 X 와 Y 가 주어 질때, 위 공식을 계산하는 함수 DistanceSum(N, X, Y) 를 구현해야 한다. 배열 X 와 Y 는 크기 N 이고, 0 ≤ i ≤ N - 1 에 대해서, 블록 i 는 좌표 (X[i], Y[i])를 가지고 1 ≤ X[i], Y[i] ≤ 231- 2 이다. 결과가 32비트를 사용해서 표현하기에 너무 클 수 있기 때문에 결과를 1,000,000,000 으로 나눈 나머지로 계산한다.위의 예제에서 11 × 10 / 2 = 55 개의 블록 쌍이 존재한다. 모든 쌍 간의 거리들의 합은 174 이다모든 가능한 i < j인 두 블록 쌍 vi와 vj에 대한 거리들의 합을 1,000,000,000 으로 나눈 나머지를 출력한다.",46.610%,5813,1,24.0,"다이나믹 프로그래밍,트리에서의 다이나믹 프로그래밍,그래프 이론,트리,","동적계획법,동적 계획법,다이나믹프로그래밍,트리dp,그래프이론,trees,"
/problem/5814,마상시합 토너먼트,"1491년 베아트리체의 결혼식을 위해서 밀란의 스포르자 공작은 다빈치에게 3일간의 마상시합(말을 타고 창 실력을 겨루는 게임)을 포함한 결혼 축제를 기획하도록 부탁하였다. 하지만 가장 인기있는 기사가 도착이 늦기에...마상시합 토너먼트에 참가하는 N 명의 기사는 처음에 한 줄로 서 있고, 줄에 선 순서대로 기사들은 0 부터 N - 1 까지 번호가 붙어 있다. 마상시합의 한 라운드는 두 위치 S와 E를 (0 ≤ S < E ≤ N - 1) 부름으로써 시작된다. 그러면 번호가 S 이상 E 이하인 모든 기사들이 이번 라운드에서 경쟁하여 1명의 승자가 정해지게 된다. 승자는 다시 원래의 줄로 돌아가고, 패자들은 경기에서 빠지게 된다. 기사들이 0번 쪽으로 순서를 유지하면서 이동하여 원래 줄의 빈 자리들을 채운다. 결과적으로 남은 기사들의 번호는 0 부터 N - (E - S) - 1 까지가 된다. 다음 라운드도 같은 방식으로 계속되어 마지막 한 명의 기사가 남을 때 까지 계속된다.다빈치는 기사들의 실력이 모두 다르다는 것을 알고 있으며, 실력은 0 부터 N - 1 까지의 정수로 표현된다 (값이 클 수록 더 좋은 실력을 의미한다). 또한, 다빈치는 모든 C개의 라운드에서 불려질 번호 범위도 정확히 알고 있고, 각 라운드에서 가장 좋은 실력 값을 가진 기사가 반드시 이긴다고 확신한다.N 명의 기사들 중 N - 1 명은 이미 도착하여 줄을 서 있지만, 가장 인기있는 기사만이 아직 도착하지 않았다. 아직 도착하지 않은 기사의 실력 값은 R이다. 다빈치는 그 기사의 인기를 이용해 축제의 즐거움을 더할 목적으로, 그 기사가 승리하는 라운드의 수가 가장 많아지도록 그 기사의 위치를 정하고 싶어한다. 그 기사가 참여하지 않는 라운드는 무관하며 단지 그 기사가 참여해서 이기는 라운드의 수 만이 중요하다는 점에 주의하라.기사의 총 수 N = 5인 경우에, N - 1 명의 기사들은 이미 줄을 서 있고 각각의 실력 값은 줄에 있는 순서 대로 [1, 0, 2, 4]라고 하자. 늦게 온 기사의 실력 값은 R = 3임을 알수 있다. 토너먼트는 C = 3 라운드로 구성되며 각 라운드에서 불려지는 (S, E) 값들은 순서대로 다음과 같다고 하자: (1, 3), (0, 1), (0, 1).다빈치가 늦게 온 기사를 첫 번째 위치에 배치하게 되면 전체 기사들의 실력 값은 [3, 1, 0, 2, 4]가 된다. 첫 번째 라운드는 위치 1, 2, 3에 있는 실력 값이 각각 1, 0 , 2인 기사들이 경쟁하고 실력 값 2인 기사가 승자가 된다. 이 라운드 후에 남은 기사들이 있는 줄의 실력 값은 순서대로 [3, 2, 4]와 같이 될 것이다. 다음 라운드는 실력 값 3인 기사와 실력 값 2인 기사가 (위치 번호로는 0과 1) 경쟁하고 실력 값 3인 기사가 승리하여, 남은 줄의 실력 값은 [3, 4]가 된다. 마지막 라운드의 승자는 실력 값 4인 기사일 것이다. 결과적으로, 늦게 온 기사는 단 하나의 라운드(두 번째 라운드)에서만 승리하였다.반면에, 다빈치가 늦게 온 기사를 실력 값 1인 기사와 0인 기사 사이에 배치하였다면, 최초의 줄의 실력 값들은 다음과 같을 것이다: [1, 3, 0, 2, 4]. 이 경우, 첫 라운드에 참여하는 기사들의 실력 값은 3, 0, 2와 같으며, 실력 값 3인 기사가 승리한다. 이제 남은 줄의 실력 값들은 [1, 3, 4]이며 그 다음 라운드에서 실력 값 1, 3인 기사들이 경쟁하여 역시 실력 값 3인 기사가 승리한다. 직후의 남은 줄의 실력 값들은 [3, 4]이며, 마지막 라운드에서는 실력 값 4인 기사가 승리한다. 따라서, 이 경우 늦게 온 기사는 2개의 라운드에서 승리하며, 늦게온 기사가 3회 이상 승리하는 것은 불가능하므로 이 방법이 가장 좋은 경우이다.다빈치가 바라는 바에 따라, 늦게 온 기사가 승리하는 라운드의 수가 최대가 되는 위치를 찾아내는 프로그램을 작성하라. 구체적으로, GetBestPosition(N, C, R, K, S, E) 함수를 작성하여야 한다.N은 기사들의 총 수이다 (1 ≤ N ≤ 100,000)C는 진행되는 라운드의 수이다 (1 ≤ C ≤ N - 1).R은 늦게 온 기사의 실력 값이다. 늦게 온 기사를 포함한 모든 기사들의 실력 값은 0 이상 N - 1 이하의 정수이며 모두 다르다. R의 값은 다른 입력 값들로 부터 계산이 가능하지만, 명시적으로 주어진다.K는 N - 1 개의 정수의 배열이며, 이미 줄에 서 있는 N - 1 명의 기사들의 실력 값을 줄에 서 있는 순서와 같은 순서로 저장하고 있다.S와 E는 크기 C인 배열들이다. 0 이상 C - 1 이하의 i 에 대해서 S[i]과 E[i]의 값은 (i + 1) 번째 라운드에 참여하는 기사들의 줄에서의 위치가 S[i] 부터 E[i] 까지 임을 의미한다. 모든 i에 대해서 S[i] < E[i] 임은 보장된다.이 함수를 호출할 때 인자들의 값의 정확함이 보장된다. 즉, E[i]의 값은 (i + 1) 번째 라운드가 시작할 때 줄에 있는 기사들의 수 보다 작음이 보장되며, 모든 C개의 라운드가 끝난 다음에는 단 한 명의 기사만이 남아 있음이 보장된다.GetBestPosition(N, C, R, K, S, E) 함수는 늦게 온 기사를 배치할 수 있는 최적의 위치 P를 리턴하여야 한다 (0 ≤ P ≤ N - 1). 만약 최적의 위치가 여러 개일 경우는 가장 작은 값을 리턴하여야 한다. (늦게 온 기사의 위치는 그 기사가 배치된 이후의 줄에서의 위치를 말하며, 가장 앞의 위치를 0으로 시작하여 표현한 것이다. 다르게 표현하면, P는 늦게온 기사를 최적 위치에 배치한 후, 그 기사 앞에 있는 기사들의 수이다. 특정한 경우들을 보면, P = 0이라는 것은 늦게 온 기사가 가장 앞에 위치한다는 뜻이며, P = N - 1 이라는 것은 늦게 온 기사가 줄의 가장 뒤에 위치한다는 뜻이다.)GetBestPosition(N, C, R, K, S, E)를 호출한 결과를 출력한다.","N ≤ 100 000.
",5814,1,22.0,"자료 구조,다이나믹 프로그래밍,트리에서의 다이나믹 프로그래밍,최소 공통 조상,세그먼트 트리,트리,","자료구조,자구,동적계획법,동적 계획법,다이나믹프로그래밍,트리dp,구간트리,세그트리,fenwick,펜윅,trees,"
/problem/5819,열대 식물원,"식물학자 철수는 여러 반의 학생들과 함께 태국 최대의 식물원을 방문하기로 하였다. 이 넓은 식물원은 (0 부터 N-1 까지의 번호가 붙은) N 개의 연못과 M 개의 산책로로 구성되어 있다. 각 산책로는 서로 다른 두 연못을 연결하며, 양방향으로 모두 이동하는 것이 가능하다. 어느 연못이든지 최소 하나의 산책로가 연결되어 있다. 이 산책로들에는 철수가 좋아하는 아름다운 식물들이 많이 있다. 같은 반의 학생들은 함께 이동하며, 각 반이 산책을 시작하는 연못은 서로 다를 수 있다. 철수는 아름다운 열대 식물들을 아주 좋아한다. 따라서, 철수와 각 반의 학생들은 어느 연못에서든 가장 아름다운 산책로를 선택하여 이용한다. 단, 그 산책로를 바로 직전에 이용한 경우에는 두 번째로 아름다운 산책로를 이용한다. 하지만, 현재 연못에 연결된 산책로가 단 하나뿐인 경우는 두 번째로 아름다운 산책로가 존재하지 않으므로 방금 사용한 산책로를 다시 이용하는 것을 허용한다. 철수는 식물학자이므로 두 산책로의 아름다운 정도가 같은 경우는 없다.학생들은 식물에는 큰 관심이 없다. 학생들의 관심은 어떤 연못 P 옆에 위치한 고급 식당에서 점심 식사를 하는 것이다. 철수는 각 반의 학생들이 정확히 K 개의 산책로를 지난 다음 배가 고파질 것이라는 것을 알고 있다. 각 반 마다 K 의 값은 다를 수 있다. 이 상황 하에서 철수는 각 반에 대해 정확히 K 개의 산책로를 이용한 후 연못 P 에 도착하는 방법의 수가 얼마나 많은지 알고 싶다. 각 반에 대한 상황을 정리하면 다음과 같다.각 반은 아무 연못에서나 출발핛 수 있다.산책로를 선택하는 규칙은 위의 설명과 같다.각 반은 정확히 K 개의 산책로를 이용한 다음에는 연못 P 에 도착해야 한다.각 반이 P 로 가는 도중에 연못 P 를 지나는 것도 가능하다. 그러나, 마지막에는 반드시 P 에 도달하여야 한다.당신은 연못과 산책로에 대한 정보를 받아서 Q 개의 반에 대한 해답을 찾아야 한다. 즉, Q 개의 K 값에 대한 해답을 생성해야 하는 것이다.다음의 입력을 받는 count_routes(N, M, P, R, Q, G) 함수를 작성하라.N - 연못의 수. 연못은 0 부터 N-1 까지 번호가 붙어 있다.M - 산책로의 수. 산책로는 0 부터 M-1 까지 번호가 붙어 있다. 산책로의 번호는 아름다운 정도가 줄어드는 순서이다. 즉, 모든 i(0 ≤ i < M-1)에 대해서 산책로 i 는 산책로 i+1 보다 더 아름답다.P - 고급 식당이 위치하는 연못의 번호R - 산책로들을 표현한 2 차원 배열. 산책로 i(0 ≤ i < M-1)는 연못 R[i][0]과 연못 R[i][1]을 연결한다. 한 산책로는 서로 다른 두개의 연못을 연결하며, 두 연못 사이에는 최대 하나의 산책로만 존재한다는 것에 주의하라.Q – 반의 수G – 각 반에 대한 K 의 값을 가지는 배열. 각 i(0 ≤ i < Q)에 대해서 G[i]의 값은 반 i 가 목적지 P 에 도달하기 위해 이용하는 산책로의 개수인 K 의 값이다.각 i(0 ≤ i < Q)에 대해서 당신의 함수는 철수와 반 i 의 학생들이 정확히 G[i]개의 산책로를 이용한 후 연못 P 에 도달할 수 있는 모든 가능한 서로 다른 경로들의 개수를 찾아야 한다. 각 반 i 에 대해서 당신의 함수는 반 i 의 경로의 수가 X 라는 의미로 answer(X)를 호출해야 한다. answer() 함수가 호출되는 순서는 배열 G 에 주어진 순서와 동일해야 한다. 어떤 반에 대해 가능한 경로가 없는 경우는 answer(0)을 호출해야 한다.문제에는 answer(X)를 호출하라고 되어 있지만, answer 함수를 호출하지 말고, X값을 한 줄에 하나씩 순서대로 출력한다.",39.024%,5819,1,22.0,"그래프 이론,그래프 탐색,","그래프이론,bfs,dfs,"
/problem/5820,경주,"IOI 를 개최하는 파타야 시는 경주대회인 IOR 2011 도 함께 개최하며 이를 위해 가장 적합한 경주코스를 찾고 있다.파타야 인근 지역에는 N 개의 도시가 있고 N-1 개의 고속도로가 이 도시들을 연결하고 있다. 각 고속도로는 양방향이며 서로 다른 두 개의 도시를 연결한다. 각 고속도로의 길이는 킬로미터 단위로 나타내며 정수 값이다. 그리고 임의의 두 도시는 직접 고속도로로 연결되지 않더라도 단 하나의 경로에 의해 연결된다. 즉, 같은 도시를 두 번 이상 방문하지 않고 한 도시에서 출발하여 다른 도시에 도착하는 방법은 유일하다.IOR 에 사용되는 경주코스는 출발 도시와 도착 도시가 서로 달라야 하며 길이는 정확하게 K 킬로미터인 경로이다. 그리고 충돌을 방지하기 위해 한 고속도로를 두 번 이상 사용하지 않는다. (따라서 한 도시도 두 번 이상 방문하지 않는다.) 또한 교통체증을 줄이기 위해 되도록 가장 작은 수의 고속도로를 사용하여 경주코스를 구성하려고 한다.다음의 파라미터를 받는 best_path(N,K,H,L) 함수를 작성하라.N – 도시의 수. 각 도시는 0 번부터 N-1 번까지 정수로 나타낸다.K – 경주코스의 길이.H – 각 고속도로를 나타내는 2 차원 배열. 고속도로 i (0 ≤ i < N-1)는 도시 H[i][0]와 도시 H[i][1]를 연결하는 도로이다.L – 고속도로의 길이를 나타내는 1 차원 배열. 고속도로 i (0 ≤ i < N-1)의 길이는 L[i]이다.배열 H 에 저장된 값은 0 이상 N-1 이하이다. 또한 배열 L 에 저장된 값은 0 이상 1 000 000 이하의 정수이다. 그리고 모든 도시들은 연결되어 있다.당신이 작성한 함수는 길이가 K 인 경주코스 중에서 고속도로 수가 가장 작은 경주코스의 고속도로 수를 반환한다. 만약 길이가 K 인 경주코스가 없다면 -1 을 반환하라.best_path(N,K,H,L)가 리턴한 값을 출력한다.",20.042%,5820,1,22.0,"centroid,센트로이드 분할,분할 정복,트리,","센트로이드,dnc,trees,"
/problem/5821,쌀 창고,"어느 시골에, 쌀의 길 이라고 불리는 긴 직선 도로가 있다. 이 길을 따라 R 개의 논들이 있다. 각 논들은 1 이상 L 이하의 정수좌표를 갖는다. 논들은 좌표 값이 감소하지 않는 순서로 주어진다. 즉, 0 ≤ i < R 에 대해서, 논 i 는 좌표 X[i] 에 있다. 1 ≤ X[0] ≤ ... ≤ X[R-1] ≤ L 라고 가정할 수 있다.여러 개의 논이 하나의 같은 좌표에 있을 수 있음을 주의하라.논에서 수확한 가능한 가장 많은 쌀들을 저장할 수 있는 하나의 쌀 창고를 세우려고 계획하고 있다. 논의 위치와 같이, 쌀 창고의 위치는 1 이상 L 이하의 정수좌표에만 있을 수 있다. 쌀 창고는 논들이 위치하고 있는 장소를 포함하여 어떤 곳에든지 세울 수 있다.수확의 계절에 각 논들은 정확히 트럭 한대 분량의 쌀만 생산할 수 있다. 쌀들을 창고로 옮기기 위해서 트럭 운전사들을 고용하여야 한다. 트럭 운전사는 한 트럭분량의 쌀을 창고로 옮기는데 단위 거리당 1 바트의 요금을 청구한다. 다르게 말하자면, 논으로부터 쌀을 창고로 옮기는 비용은, 논의 좌표 값과 창고의 좌표 값의 차이와 같다.불행히도, 올해의 예산이 충분하지 못하여 쌀의 수송에는 최대 B 바트 까지만 사용할 수 있다. 여러분이 해야 할 일은 가능한 가장 많은 쌀을 창고로 모으기 위한 창고의 위치를 결정하는 것이다.다음의 파라미터를 갖는 besthub(R,L,X,B) 함수를 작성하라:R – 논의 수. 논들은 0 이상 R-1 이하의 번호로 나타낸다. L – 최대 좌표 값.X – 가장 작은 수부터 가장 큰 수까지 정렬된 정수의 1 차원 배열. 0 ≤ i < R 에 대하여, 논 i 는 X[i]에 위치한다. B – 예산.여러분의 함수는 반드시 최적의 쌀 창고의 위치를 찾아야 하고, 예산 범위 이내에서 쌀 창고까지 옮길 수 있는 최대 쌀의 양이 트럭 몇 대 분량 인지를 리턴 하여야 한다.쌀을 옮기는데 허용된 예산은 매우 클 수가 있음을 주의하라. 예산은 64-비트의 정수로 주어지고, 계산 과정에서는 64-비트의 정수를 사용하도록 권장한다. C/C++에서는 long long 데이터 형을 사용하고, 파스칼에서는 Int64 데이터 형을 사용하라.besthub(R,L,X,B)의 리턴값을 출력한다.",38.298%,5821,1,17.0,"이분 탐색,누적 합,두 포인터,","이분탐색,이진탐색,구간합,부분합,rangesum,투포인터,인치웜,inchworm,twopointer,"
/problem/5822,악어의 지하 도시,"고고학자 철수는 악어의 신비한 지하 도시를 탐험하다가 위험을 느끼고 도망치게 되었다. 지하 도시는 N 개의 방으로 구성되어 있다. 방들을 연결하는 M 개의 복도가 있는데, 각 복도는 서로 다른 두 방을 연결하며, 같은 쌍의 방을 연결하는 복도는 최대 1 개이다. 복도를 통과하는데 걸리는 시간은 복도마다 다를 수 있다. N 개의 방들 중 K 개는 바로 탈출이 가능한 “탈출방”이다. 철수는 최초에 방 0 에 있다. 철수는 최대한 빨리 탈출방으로 가려고 한다.악어 문지기는 철수가 탈출하는 것을 막으려고 한다. 문지기는 복도 중 임의의 하나를 막을 수 있는 방법이 있다. 어떤 시점이든 단 하나만 막을 수 있다. 즉, 문지기가 새로운 복도를 막으면 이전에 막았던 복도는 열린다.철수의 상황을 좀더 자세히 설명하면 다음과 같다: 철수가 어떤 방을 떠나려고 할 때 문지기는 그 방과 연결된 복도들 중 하나를 막을 수 있다. 철수는 막히지 않은 복도 중 하나를 골라서 다른 방으로 이동한다. 철수가 복도에 일단 들어가고 나면 철수가 이동을 완료할 때 까지는 문지기가 이 복도를 막을 수 없다. 철수가 다른 방에 들어가고 나면 문지기는 (방금 지나온 복도도 당연히 포함하여) 또 다른 복도를 막을 수 있고, 이런 식으로 반복된다.철수는 탈출 계획을 미리 정해 놓기를 원한다. 정확히 말하자면, 각 방 마다, 그 방에 도착하면 어떤 식으로 행동해야 하는 지의 계획이 미리 정해져 있어야 한다. A 가 어떤 방이라고 하자. 만약 A 가 탈출방이라면 바로 탈출하면 되므로 별다른 계획이 필요하지 않다. A 가 탈출방이 아니라면 A 에 대해서는 다음 중 한가지 형태의 계획이 있어야 한다.만약 A 에 있다면 방 B 로 이동하는 것이 우선이다. 만약 그 쪽 복도가 막혀 있으면 방 C 로 이동하라.이 계획 하에서는 A 에 절대 도달할 수 없으므로, 아무 계획이 없음.어떤 경우에는 (예를 들어 어떤 계획하에서 철수가 싸이클을 도는 경우 등) 문지기가 탈출이 영원히 불가능하도록 만들 수도 있다는 점에 주의하라. 어떤 탈출 계획이 문지기가 어떤 작전을 쓰던지 철수가 유한한 시간 안에 탈출하는 것이 가능하다는 것을 보장하면 그 계획은 ""좋은"" 계획이라고 부른다. 어떤 좋은 계획 하에서, 철수가 그 시간이 지난 후에는 반드시 탈출한다고 보장할 수 있는 최소의 시간을 T 라고 하자. 그 경우, 그 좋은 계획의 “탈출 시간”은 T 라고 말한다.다음의 파라미터를 받는 함수 travel_plan(N, M, R, L, K, P)를 작성하라.N - 방의 수. 방은 0 부터 N-1 까지 번호가 붙어 있다.M - 복도의 수. 복도는 0 부터 M-1 까지 번호가 붙어 있다.R - 복도들을 표현하는 정수의 2 차원 배열. 각 i(0≤i<M)에 대해서 복도 i 는 방 R[i][0]와 방 R[i][1]를 연결한다. 동일한 쌍의 방들을 연결하는 복도는 최대 하나이다.L - 복도를 통과하는데 걸리는 시간을 저장한 일차원 배열. 각 i(0≤i<M)에 대해서 L[i](1≤L[i]≤1,000,000,000)의 값은 철수가 복도 i 를 통과하는 데 걸리는 시간이다.K - 탈출방의 수. (1≤K<N)P - 탈출방의 번호들을 가지는 크기 K 인 정수의 일차원 배열. 각 i(0≤i<K)에 대해서 P[i]는 i 번째 탈출방의 번호이다. 방 0 는 탈출방에 포함되지 않는다. (P 에 있는 값들은 모두 다르다.)당신의 함수는 좋은 계획이 존재하는 탈출 시간의 최솟값 T 를 리턴해야 한다. 탈출방이 아닌 방은 최소한 2 개의 복도가 연결되어 있다고 가정해도 좋다. 또한, 모든 경우에 T ≤ 1,000,000,000 이하인 좋은 계획이 존재한다고 가정해도 좋다.travel_plan(N, M, R, L, K, P)의 리턴값을 출력한다.",42.324%,5822,1,20.0,"데이크스트라,그래프 이론,","다익,다익스트라,데이크스트라,그래프이론,"
/problem/5823,코끼리,"N 마리의 코끼리가 무대에서 한 줄로 서서 춤을 추는 코끼리 쇼는 파타야에서는 매우 유명하다.몇 년간의 훈련 후, 코끼리들은 이 쇼에서 많은 놀랄만한 춤들을 출 수 있게 된다. 이 쇼는 일련의 동작으로 이루어짂다. 각 동작에서는, 정확히 한 코끼리만 다른 장소로 이동하는 귀여운 춤을 추는데, 제자리에 있을 수도 있다.쇼 제작자는 전체 쇼의 사진을 포함하는 사진첩을 제작하려 한다. 각 동작마다, 관객들에게 보여지는 모든 코끼리들의 사진을 찍으려고 한다.쇼가 진행되는 동안, 여러 마리의 코끼리들은 같은 장소에 있을 수 있다. 이 경우, 같은 장소에 있는 코끼리들은 단순히 다른 코끼리의 뒤에 서 있게 된다.하나의 카메라는 길이 L 의 선분상에 있는 코끼리들의 사진만 찍을 수 있다(양 끝점 포함). 코끼리들은 무대 전체에 흩어져 있을 수 있으므로, 모든 코끼리들에 대한 동시의 스냅사진을 찍기 위해서는 여러 대의 카메라가 필요할 수도 있다예를 들어, L=10 이고 무대에서 코끼리들의 위치가 10, 15, 17, 그리고 20 이라고 하자. 이 순간에는, 아래의 그림과 같이, 하나의 카메라로 모든 코끼리들의 사진을 찍을 수 있다. (삼각형은 코끼리를 나타내고; 사다리꼴은 카메라를 나타낸다.)그 다음의 동작에서는, 15 에 있던 코끼리가 32 의 위치로 춤추며 이동한다. 이 동작 후의 스냅사진을 찍기 위해서는 적어도 두 대의 카메라가 필요하다.그 다음의 동작에서 10 에 있던 코끼리가 7 의 위치로 이동한다. 이 경우에서는 모든 코끼리들의 사진을 찍기 위해서 세대의 카메라가 필요하다.이 상호작용 태스크에서는, 각 코끼리들의 동작 후의 코끼리 사진을 찍기 위한 최소 수의 카메라를 찾아야 한다. 매 동작마다 카메라의 수는 증가할 수도 있고, 감소할 수도 있으며, 변화가 없을 수도 있음에 주의하라.다음의 함수를 작성하라:함수 init(N,L,X)은 다음의 파라미터를 갖는다:N – 코끼리의 수. 코끼리는 0 이상 N-1 이하의 번호로 나타낸다.L – 하나의 카메라로 찍을 수 있는 선분의 길이. L 은 정수이며, 0 ≤ L ≤ 1 000 000 000 이다.X – 코끼리들의 처음 위치를 나타내는 하나의 일차원 정수 배열. 0 ≤ i < N 에 대하여, 코끼리 i 의 초기위치는 X[i]이고, 정렬이 되어있다. 좀 더 정확하게 말하자면, 0 ≤ X[0] ≤ ... ≤ X[N-1] ≤ 1 000 000 000 이다. 코끼리들의 춤(동작) 후에 위치가 재 배열 될 수 있음에 주의하라.이 함수는 모든 다른 호출 전에 단 한번만 호출되며 어떤 값도 리턴하지 않는다.함수 update(i,y)는 다음의 파라미터를 갖는다:i – 현재의 동작에서 움직이는 코끼리의 번호.y – 현재의 동작 후 변경되는 코끼리 i 의 위치. y 는 정수이며, 0 ≤ y ≤ 1 000 000 000 이다. 이 함수는 여러 번 호출될 수 있다. 각 호출은 (이전의 모든 동작 다음에 나타나는) 한번의 동작을 의미한다. 각 호출은 이 동작 후의 모든 코끼리들의 사진을 찍는데 필요한 카메라의 최소 수를 리턴하여야 한다.update함수를 호출할 때 마다 리턴값을 한 줄에 하나씩 출력한다.",35.122%,5823,1,26.0,"제곱근 분할법,","루트분할법,평방분할법,모,mo,sqrt,"
/problem/7469,K번째 수,"현정이는 자료 구조 프로젝트를 하고 있다. 다른 학생들은 프로젝트 주제로 스택, 큐와 같은 기본 자료 구조를 구현하는 주제를 선택했다. 하지만, 현정이는 새로운 자료 구조를 만들었다.현정이가 만든 자료구조는 배열을 응용하는 것이다. 배열 a[1...n]에는 서로 다른 수가 n개 저장되어 있다. 현정이는 여기에 Q(i,j,k)라는 함수를 구현해 모두를 놀라게 할 것이다.Q(i,j,k): 배열 a[i...j]를 정렬했을 때, k번째 수를 리턴하는 함수예를 들어, a = (1,5,2,6,3,7,4)인 경우 Q(2,5,3)의 답을 구하는 과정을 살펴보자. a[2...5]는 (5,2,6,3)이고, 이 배열을 정렬하면 (2,3,5,6)이 된다. 정렬한 배열에서 3번째 수는 5이다. 따라서 Q(2,5,3)의 리턴값은 5이다.배열 a가 주어지고, Q함수를 호출한 횟수가 주어졌을 때, 각 함수의 리턴값을 출력하는 프로그램을 작성하시오.Q함수를 호출할 때마다 그 함수의 리턴값을 한 줄에 하나씩 출력한다. ",31.800%,7469,1,19.0,"이분 탐색,자료 구조,머지 소트 트리,세그먼트 트리,정렬,","이분탐색,이진탐색,자료구조,자구,병합정렬트리,합병정렬트리,구간트리,세그트리,fenwick,펜윅,"
/problem/7615,해싱,"상근이는 정수를 0부터 m-1까지의 정수로 매핑시키는 해싱 함수 h(y) = a·y + b mod m를 만들었다. x, n, c, d가 주어졌을 때, 해시값 h(x), h(x+1), ..., h(x+n) 중 몇 개가 구간 [c,d]에 포함되는지 구하는 프로그램을 작성하시오.각 테스트 케이스마다 c ≤ a·(x+i)+b mod m ≤ d 을 만족하는 0 ≤ i ≤ n의 개수를 출력한다.",31.250%,7615,1,21.0,0,
/problem/9184,신나는 함수 실행,"재귀 호출만 생각하면 신이 난다! 아닌가요?다음과 같은 재귀함수 w(a, b, c)가 있다.if a <= 0 or b <= 0 or c <= 0, then w(a, b, c) returns:    1if a > 20 or b > 20 or c > 20, then w(a, b, c) returns:    w(20, 20, 20)if a < b and b < c, then w(a, b, c) returns:    w(a, b, c-1) + w(a, b-1, c-1) - w(a, b-1, c)otherwise it returns:    w(a-1, b, c) + w(a-1, b-1, c) + w(a-1, b, c-1) - w(a-1, b-1, c-1)위의 함수를 구현하는 것은 매우 쉽다. 하지만, 그대로 구현하면 값을 구하는데 매우 오랜 시간이 걸린다. (예를 들면, a=15, b=15, c=15)a, b, c가 주어졌을 때, w(a, b, c)를 출력하는 프로그램을 작성하시오.입력으로 주어진 각각의 a, b, c에 대해서, w(a, b, c)를 출력한다.",42.174%,9184,1,9.0,"다이나믹 프로그래밍,재귀,","동적계획법,동적 계획법,다이나믹프로그래밍,"
/problem/9206,나무 말고 꽃,"선영이와 남자친구의 2주년이 얼마 남지 않았다. 선영이는 그를 위해 특별한 것을 사주려고 한다. 남자친구는 나무에 관심이 매우 많다. 하지만, 선영이는 나무는 선물로 매우 크다고 생각한다. 따라서, 꽃을 사주려고 한다.선영이는 모든 꽃에는 그 꽃과 가장 잘 어울리는 꽃병의 부피가 있다고 생각한다. 선영이는 꽃병을 구매하기 위해 인터넷 쇼핑몰에 들어갔다. 쇼핑몰에는 꽃병의 사진과 윤곽 함수가 적혀져 있다. 가장 적합한 꽃병을 찾는 프로그램을 작성하시오.꽃병의 윤곽은 함수 f(x) = a・e-x2+ b・√x로 나타낼 수 있다. 여기서 x는 꽃병의 바닥과 떨어진 수직 거리이다. 꽃병은 이 함수를 x축에 대해서 회전시킨 모양이다. 꽃병의 높이는 h이다.서로 다른 두 꽃병의 부피의 차이는 적어도 10-4이다. 또, 서로 다른 두 꽃병과 선영이가 찾는 꽃병의 부피의 차이도 적어도 10-4 만큼 차이난다.선영이가 찾는 꽃병과 부피 차이가 적은 꽃병의 인덱스를 출력한다. 첫 번째 꽃병의 인덱스는 0이다.",11.809%,9206,1,19.0,"미적분학,수학,수치해석,","미분,적분,수학,"
/problem/9272,상근이의 아이디어,"상근이는 아들에게 다음과 같은 문제를 냈다.\(1 \le n_1 < n_2 \le 10^4\)를 만족하는 두 정수 \(n_1\)과 \(n_2\)가 있다. 함수 \(p:\mathbb{N}^* \rightarrow \mathbb{N}^*\), \(p(n) = 2^n\), \(\forall n \in   \mathbb{N}^*\) 을 이용해 다음 집합을 정의할 수 있다. (\(\mathbb{N}^*\)는 양의 정수의 집합이다)\[S(n_1,n_2)=\left\{ p(p(n))+1 |n_1 \le n \le n_2  \right\} \]다음과 같은 쌍의 집합도 정의할 수 있다.\[T(n_1,n_2)=\left\{ (m_1,m_2) | m_1,m_2 \in  S(n_1,n_2), m_1 < m_2  \right\} \]이제 다음과 같은 식을 만들 수 있다.\[R(n_1,n_2)= \sum_{(m_1,m_2) \in T(n_1,n_2)}{gcd(m_1,m_2)}\]\(gcd(m_1,m_2)\)는 \(m_1\)와 \(m_2\)의 최대 공약수이다.\(n_1\)과 \(n_2\)가 주어졌을 때, \(R(n_1,n_2)\)를 구하는 프로그램을 작성하시오.첫째 줄에 \(R(n_1,n_2)\)의 값을 출력한다.",81.633%,9272,1,8.0,"수학,정수론,",
/problem/9341,ZZ,"ZZ 함수의 정의는 다음과 같다.\(ZZ(0,1) = a\)\(ZZ(0,2) = b\)\(ZZ(0,k) = ZZ(0,k-1) + ZZ(0,k-2); k > 2\)\(ZZ(i,k) = \sum _{j=1} ^{k} {ZZ(i-1,j)} ; i \ge 1, k \ge 1\)네 정수 a, b, c, d가 주어졌을 때, ZZ(c, d)를 찾는 프로그램을 작성하시오.각 테스트 케이스마다 ZZ(c, d) mod 1 000 000 009를 출력한다. ",46.196%,9341,1,19.0,"다이나믹 프로그래밍,분할 정복을 이용한 거듭제곱,수학,","동적계획법,동적 계획법,다이나믹프로그래밍,거듭제곱,제곱,power,square,"
/problem/9371,인코딩 좌표,"상근이는 테러리스트의 전화를 도청하던 중에 큰 공격이 예고되다는 사실을 알게되었다. 테러리스트는 인코딩된 좌표를 서로에게 보내고 있다. 상근이는 이 좌표 중 한 군데에서 공격이 일어날 것이라고 예상하고 있다. 상근이는 좌표를 가로채는데 성공했다.모든 좌표는 x와 y 좌표로 나누어져 있으며, 두 좌표는 모두 소수 P보다 작은 음이 아닌 정수이다. x좌표와 y좌표는 각각 인코딩되며, 인코딩 되는 과정은 동일하다. 좌표 하나를 인코딩하려면 A, B, C, K, N이 필요하고, 다음과 같은 과정이 필요하다.인코딩 과정은 세 함수로 나타낼 수 있고, 다음과 같다.F(n+1) = G(n) + H(n)G(n+1) = K*F(n) + H(n-1)H(n+1) = F(n) + K*G(n)A, B, C는 함수의 초기값이다.F(1) = AG(1) = BH(1) = C좌표는 F(N) mod P가 된다.사실 위의 과정에는 매우 중요한 정보가 하나 빠져있다. G(2)를 계산하려면, H(0)이 필요하다. 하지만, H(0)을 알아낼 수 있는 방법은 없다. H(0)에 대한 유일한 정보는 x와 y를 계산할 때, 동일한 H(0)을 사용한다는 점이다.상근이는 우연히 x좌표를 디코딩하지 않고 얻게 되었다. 이제, x를 이용해 H(0)을 구한 다음, y를 구하는 프로그램을 작성하시오.각 테스트 케이스마다 y좌표를 출력한다. 만약, 가능한 y좌표가 여러 개인 경우에는 “UNKNOWN”를 출력한다.",36.923%,9371,1,17.0,"분할 정복을 이용한 거듭제곱,구현,수학,모듈로 곱셈 역원,정수론,","거듭제곱,제곱,power,square,modinv,"
/problem/9507,Generations of Tribbles,"꿍은 군대에서 진짜 할짓이 없다. 그래서 꿍만의 피보나치를 만들어보려고 한다. 기존의 피보나치는 너무 단순해서 꿍은 좀더 복잡한 피보나치를 만들어보고자 한다. 그래서 다음과 같은 피보나치를 만들었다. 꿍만의 피보나치 함수가 koong(n)이라고 할 때,n < 2 :                         1n = 2 :                         2n = 3 :                         4n > 3 : koong(n − 1) + koong(n − 2) + koong(n − 3) + koong(n − 4)이다.여러분도 꿍 피보나치를 구해보아라.각 테스트 케이스에 대해, 각 줄에 꿍 피보나치값을 출력하라.",73.730%,9507,1,7.0,"다이나믹 프로그래밍,","동적계획법,동적 계획법,다이나믹프로그래밍,"
/problem/10001,Hash,"창영이는 시스템 프로그래밍 숙제에 사용할 Hash 함수를 만들고 있다. 이 함수는 단어를 숫자로 바꾸는 Hash 함수이고, 아래와 같이 재귀적으로 정의된다.f(empty word) = 0f(word + letter) = ((f(word) * 33) XOR ord(letter)) % MOD단어는 알파벳 소문자로만 이루어져 있어야 한다. XOR은 XOR 연산을 나타내며 (0110 XOR 1010 = 1100), ord(letter)는 알파벳의 순서를 나타낸다. (ord(a) = 1, ord(z) = 26) A % B는 A를 B로 나눈 나머지를 나타내며, MOD는 2M이다.M = 10인 경우에 Hash값은 아래와 같다.f(a) = 1f(aa) = 32f(kit) = 438창영이는 길이가 N인 단어 중에서 Hash값이 K인 단어의 개수를 찾으려고 한다. 이러한 단어의 개수를 찾아 출력하는 프로그램을 작성하시오.길이가 N이면서 Hash값이 K인 단어의 개수를 출력한다.",22.876%,10001,1,17.0,"분할 정복을 이용한 거듭제곱,페르마의 소정리,수학,중간에서 만나기,모듈로 곱셈 역원,정수론,","거듭제곱,제곱,power,square,modinv,"
/problem/10072,곤돌라 - 곤돌라 수열 확인,"마오공 곤돌라는 타이페이의 명소 중 하나이다. 곤돌라 시스템은 원형의 레일과, 하나의 정류장이 있고, 1 부터 n까지 순서대로 번호가 붙은 n개의 곤돌라가 모두 단일한 방향으로 레일을 따라 움직이는 형태이다. i번 곤돌라가 정류장을 지난 직후에는 i+1번 곤돌라가 정류장을 지나가게 된다. (단, i=n번 곤돌라가 지나간 직후에 1 번 곤돌라가 지나가게 된다.)곤돌라들은 고장이 나기도 한다. 다행히 무제한으로 많은 곤돌라의 여분이 있고, 여분 곤돌라들은 n+1, n+2과 같이 순차적으로 번호가 붙어 있다. 특정한 곤돌라가 고장이 나면 고장난 곤돌라는 빼고, 동일한 위치에 여분 곤돌라를 배치한다. 여분 곤돌라는 작은 번호부터 사용된다. 예를 들어, 사용하는 곤돌라 수가 총 5 개이고, 1 번 곤돌라가 고장난다면, 그 곤돌라는 6번으로 교체된다.당신은 정류장에 서서 곤돌라들이 지나가는 것을 즐겨 본다. 곤돌라 수열이라는 것은 임의의 시점에서 시작해서 정류장을 지나가는 n개의 곤돌라들의 번호를 순서대로 적은 것이다. 곤돌라 수열을 적기 시작하는 시점 이전에 이미 몇개의 곤돌라가 고장나서 교체되었을 수 있다. 하지만, 곤돌라 수열을 적는 도중에는 아무 곤돌라도 고장이 나지 않는다.전체적으로 곤돌라들의 배치가 동일하더라도 어떤 시점에 곤돌라 수열을 적기 시작하느냐에 따라 서로 다른 곤돌라 수열이 나올수 있다는 점에 주의하자. 예를 들어, 총 5개의 곤돌라들 중 고장난 곤돌라가 없는 경우에 (2, 3, 4, 5, 1) 과 (4, 5, 1, 2, 3) 은 모두 가능한 곤돌라 수열들이다. 하지만, 이경우 (4, 3, 2, 5, 1) 은 가능한 곤돌라 수열이 아니다. (곤돌라 번호의 순서가 잘못되어 있다.)만약 곤돌라 1번 만이 고장난 상황이라면, (4, 5, 6, 2, 3) 의 곤돌라 수열을 만들 수 있다. 만약 이후 4번 곤돌라가 고장난다면, 7번 곤돌라가 그 자리에 있게 되고, (6, 2, 3, 7, 5) 가 가능한 곤돌라 수열이 된다. 만약 7번 곤돌라가 이후에 고장이 난다면, 8번이 그 자리를 차지할 것이고 (3, 8, 5, 6, 2) 가 가능한 곤돌라 수열들 중 하나가 된다.고장난 곤돌라새 곤돌라가능한 곤돌라 수열 중 하나16(4, 5, 6, 2, 3)47(6, 2, 3, 7, 5)78(3, 8, 5, 6, 2)교체 수열이라는 것은 고장난 곤돌라들의 번호를 고장난 순서에 따라 쓴 것이다. 직전의 예에서 교체 수열은 (1, 4, 7) 이다. 교체 수열 e이 곤돌라 수열 g를 만든다고 말을 할 수 있는데, 그것은 초기 상황에서 시작해서 r에 해당하는 방법으로 곤돌라들이 고장난 직후에, g가 가능한 곤돌라 수열들 중 하나인 경우를 의미한다.이 문제에서는 입력 수열이 곤돌라 수열로서 가능한 것인지 확인하여야 한다. 몇 개의 곤돌라가 고장나서 교체된 상태일 수도 있다. 아래 표에는 곤돌라 수열인 예들과 곤돌라 수열이 아닌 예들이 나와 있다. 아래와 같이 선언된 valid 함수를 구현하여야 한다.valid(n, inputSeq)	n: 입력 수열의 길이.inputSeq: 크기 n인 배열; inputSeq[i] 는 입력의 i번 원소이다 (0 ≤ i ≤ n-1).함수는 입력이 곤돌라 수열로서 가능한 경우 1을, 아닌 경우 0을 리턴해야 한다.valid함수의 리턴 값을 출력한다.",4가 3의 직전에 나오는 것은 불가능,10072,1,13.0,"애드 혹,많은 조건 분기,구현,","케이스,케이스워크,케이스 워크,"
/problem/10073,곤돌라 - 교체 수열,"마오공 곤돌라는 타이페이의 명소 중 하나이다. 곤돌라 시스템은 원형의 레일과, 하나의 정류장이 있고, 1 부터 n까지 순서대로 번호가 붙은 n개의 곤돌라가 모두 단일한 방향으로 레일을 따라 움직이는 형태이다. i번 곤돌라가 정류장을 지난 직후에는 i+1번 곤돌라가 정류장을 지나가게 된다. (단, i=n번 곤돌라가 지나간 직후에 1 번 곤돌라가 지나가게 된다.)곤돌라들은 고장이 나기도 한다. 다행히 무제한으로 많은 곤돌라의 여분이 있고, 여분 곤돌라들은 n+1, n+2과 같이 순차적으로 번호가 붙어 있다. 특정한 곤돌라가 고장이 나면 고장난 곤돌라는 빼고, 동일한 위치에 여분 곤돌라를 배치한다. 여분 곤돌라는 작은 번호부터 사용된다. 예를 들어, 사용하는 곤돌라 수가 총 5 개이고, 1 번 곤돌라가 고장난다면, 그 곤돌라는 6번으로 교체된다.당신은 정류장에 서서 곤돌라들이 지나가는 것을 즐겨 본다. 곤돌라 수열이라는 것은 임의의 시점에서 시작해서 정류장을 지나가는 n개의 곤돌라들의 번호를 순서대로 적은 것이다. 곤돌라 수열을 적기 시작하는 시점 이전에 이미 몇개의 곤돌라가 고장나서 교체되었을 수 있다. 하지만, 곤돌라 수열을 적는 도중에는 아무 곤돌라도 고장이 나지 않는다.전체적으로 곤돌라들의 배치가 동일하더라도 어떤 시점에 곤돌라 수열을 적기 시작하느냐에 따라 서로 다른 곤돌라 수열이 나올수 있다는 점에 주의하자. 예를 들어, 총 5개의 곤돌라들 중 고장난 곤돌라가 없는 경우에 (2, 3, 4, 5, 1) 과 (4, 5, 1, 2, 3) 은 모두 가능한 곤돌라 수열들이다. 하지만, 이경우 (4, 3, 2, 5, 1) 은 가능한 곤돌라 수열이 아니다. (곤돌라 번호의 순서가 잘못되어 있다.)만약 곤돌라 1번 만이 고장난 상황이라면, (4, 5, 6, 2, 3) 의 곤돌라 수열을 만들 수 있다. 만약 이후 4번 곤돌라가 고장난다면, 7번 곤돌라가 그 자리에 있게 되고, (6, 2, 3, 7, 5) 가 가능한 곤돌라 수열이 된다. 만약 7번 곤돌라가 이후에 고장이 난다면, 8번이 그 자리를 차지할 것이고 (3, 8, 5, 6, 2) 가 가능한 곤돌라 수열들 중 하나가 된다.고장난 곤돌라새 곤돌라가능한 곤돌라 수열 중 하나16(4, 5, 6, 2, 3)47(6, 2, 3, 7, 5)78(3, 8, 5, 6, 2)교체 수열이라는 것은 고장난 곤돌라들의 번호를 고장난 순서에 따라 쓴 것이다. 직전의 예에서 교체 수열은 (1, 4, 7) 이다. 교체 수열 e이 곤돌라 수열 g를 만든다고 말을 할 수 있는데, 그것은 초기 상황에서 시작해서 r에 해당하는 방법으로 곤돌라들이 고장난 직후에, g가 가능한 곤돌라 수열들 중 하나인 경우를 의미한다.이 문제들에서는 주어진 곤돌라 수열을 만들 수 있는 교체 수열을 생성하여야 한다. 여러 개의 교체 수열이 가능한 경우 그 중 하나를 생성하면 된다. 다음과 같이 선언된 함수 replacement 를 구현해야 한다.replacement(n, gondolaSeq, replacementSeq)n: 입력 곤돌라 수열의 길이이다.gondolaSeq: 크기 n인 배열; gondolaSeq 는 항상 가능한 곤돌라 수열이며, gondolaSeq[i] 는 번 원소이다 (1 ≤ i ≤ n-1).함수는 교체 수열의 길이 l을 리턴해야 한다.replacementSeq: 교체 수열을 저장하기에 충분한 크기의 배열; replacementSeq[i] 에는 계산된 교체 수열의 i번 원소가 저장되어야 한다 (0 ≤ i ≤ l-1).replacement함수의 리턴 값을 출력하고, 공백을 출력한 다음, replacementSeq를 공백으로 구분해 출력한다.","(5, 8)",10073,1,15.0,"해 구성하기,","constructive,컨스트럭티브,구성적,"
/problem/10074,곤돌라 - 교체 수열의 개수 세기,"마오공 곤돌라는 타이페이의 명소 중 하나이다. 곤돌라 시스템은 원형의 레일과, 하나의 정류장이 있고, 1 부터 n까지 순서대로 번호가 붙은 n개의 곤돌라가 모두 단일한 방향으로 레일을 따라 움직이는 형태이다. i번 곤돌라가 정류장을 지난 직후에는 i+1번 곤돌라가 정류장을 지나가게 된다. (단, i=n번 곤돌라가 지나간 직후에 1 번 곤돌라가 지나가게 된다.)곤돌라들은 고장이 나기도 한다. 다행히 무제한으로 많은 곤돌라의 여분이 있고, 여분 곤돌라들은 n+1, n+2과 같이 순차적으로 번호가 붙어 있다. 특정한 곤돌라가 고장이 나면 고장난 곤돌라는 빼고, 동일한 위치에 여분 곤돌라를 배치한다. 여분 곤돌라는 작은 번호부터 사용된다. 예를 들어, 사용하는 곤돌라 수가 총 5 개이고, 1 번 곤돌라가 고장난다면, 그 곤돌라는 6번으로 교체된다.당신은 정류장에 서서 곤돌라들이 지나가는 것을 즐겨 본다. 곤돌라 수열이라는 것은 임의의 시점에서 시작해서 정류장을 지나가는 n개의 곤돌라들의 번호를 순서대로 적은 것이다. 곤돌라 수열을 적기 시작하는 시점 이전에 이미 몇개의 곤돌라가 고장나서 교체되었을 수 있다. 하지만, 곤돌라 수열을 적는 도중에는 아무 곤돌라도 고장이 나지 않는다.전체적으로 곤돌라들의 배치가 동일하더라도 어떤 시점에 곤돌라 수열을 적기 시작하느냐에 따라 서로 다른 곤돌라 수열이 나올수 있다는 점에 주의하자. 예를 들어, 총 5개의 곤돌라들 중 고장난 곤돌라가 없는 경우에 (2, 3, 4, 5, 1) 과 (4, 5, 1, 2, 3) 은 모두 가능한 곤돌라 수열들이다. 하지만, 이경우 (4, 3, 2, 5, 1) 은 가능한 곤돌라 수열이 아니다. (곤돌라 번호의 순서가 잘못되어 있다.)만약 곤돌라 1번 만이 고장난 상황이라면, (4, 5, 6, 2, 3) 의 곤돌라 수열을 만들 수 있다. 만약 이후 4번 곤돌라가 고장난다면, 7번 곤돌라가 그 자리에 있게 되고, (6, 2, 3, 7, 5) 가 가능한 곤돌라 수열이 된다. 만약 7번 곤돌라가 이후에 고장이 난다면, 8번이 그 자리를 차지할 것이고 (3, 8, 5, 6, 2) 가 가능한 곤돌라 수열들 중 하나가 된다.고장난 곤돌라새 곤돌라가능한 곤돌라 수열 중 하나16(4, 5, 6, 2, 3)47(6, 2, 3, 7, 5)78(3, 8, 5, 6, 2)교체 수열이라는 것은 고장난 곤돌라들의 번호를 고장난 순서에 따라 쓴 것이다. 직전의 예에서 교체 수열은 (1, 4, 7) 이다. 교체 수열 e이 곤돌라 수열 g를 만든다고 말을 할 수 있는데, 그것은 초기 상황에서 시작해서 r에 해당하는 방법으로 곤돌라들이 고장난 직후에, g가 가능한 곤돌라 수열들 중 하나인 경우를 의미한다.이 문제에서는 주어진 수열(가능한 곤돌라 수열일 수도 아닐 수도 있음)을 만들 수 있는 교체 수열의 수를 세어서 그 값을 1,000,000,009 로 나눈 나머지를 계산해야 한다. 다음과 같이 선언된 함수 countReplacement 를 구현해야 한다.countReplacement(n, inputSeq)	n: 입력 수열의 길이.inputSeq: 크기 인 배열; inputSeq[i]는 입력 수열의 번 원소이다 (0 ≤ i ≤ n-1).입력이 곤돌라 수열인 경우, 입력의 곤돌라 수열을 만들 수 있는 모든 교체 수열의 수를 센 다음에 (그 수는 매우 클수 있음) 그 결과를 1,000,000,009 로 나눈 나머지를 리턴해야 한다. 만약 입력이 곤돌라 수열이 아닌 경우 0을 리턴해야 한다. 입력이 곤돌라 수열이고 고장난 곤돌라가 하나도 없는 경우는 1을 리턴해야 한다.countReplacement함수의 리턴값을 출력한다.","(1, 2) or (2, 1)",10074,1,18.0,"조합론,분할 정복을 이용한 거듭제곱,수학,","combination,permutation,probability,확률,순열,거듭제곱,제곱,power,square,"
/problem/10244,최대공약수들,"n개의 수로 이루어진 수열 A가 주어질 때, 1≤lo≤hi≤n의 정의역을 가지는 함수 f(lo,hi)는 Alo부터 Ahi까지 모든 원소들의 최대공약수로 정의된다. lo와 hi는 수열의 원소가 아닌 인덱스라는 점에 주의하자. 가능한 모든 lo와 hi의 값을 고려해볼 때, 수열 A에서 각각 다른 f(lo,hi)의 값은 몇 개나 존재할 수 있을까?각각의 테스트 케이스에 대해, 입력된 수열이 가질 수 있는 f(lo,hi)의 서로 다른 값의 개수를 한 개의 정수로 출력한다. 답과 답 사이에는 공백이나 빈 줄은 허용되지 않는다.",49.430%,10244,1,15.0,"유클리드 호제법,수학,정수론,","유클리드알고리즘,"
/problem/10916,Xtreme gcd sum,"간단한 문제입니다. 정수 상수인 a1, b1, ..., an, bn의 값이 주어질 때 아래 소스코드를 실행하면 sum변수에 최종적으로 어떤 값이 저장되는지 구해주세요.very big int sum = 0; for ( int x1 = a1 ; x1 <= b1 ; x1++ )     for ( int x2 = a2 ; x2 <= b2 ; x2++ )         ....             for ( int xn = an ; xn <= bn ; xn++ )                 sum = sum + gcd(x1, x2, ..., xn);너무 간단한가요? 저도 그렇게 생각해요. (웃음)여기서 gcd함수는 x1, x2, ..., xn의 최대공약수를 구하는 함수입니다.C/C++에서는 very big int형 같은 좋은 변수형이 없으므로 sum의 값을 1,000,000,007로 나눈 나머지를 출력한다.",23.871%,10916,1,22.0,"수학,정수론,",
/problem/10919,선물상자,"IOI 2015 개막식이 거의 끝나가고 있다. 개막식이 진행되는 동안, 각 팀은 주최측으로부터 선물상자를 받게 되어 있다. 그러나 모든 자원봉사자들이 개막식에 너무 집중하는 바람에, 선물에 대해서는 완전히 잊고 있었다. 선물을 줘야 한다는 것을 기억하는 사람은 아만 뿐이다. 아만은 열정적인 자원봉사자이며, IOI가 완벽하게 진행되었으면 하는 바램으로 모든 선물을 최소의 시간에 전달하고자 한다.개막식이 진행되는 곳은 L개의 동일한 구역으로 나뉘어진 원 모양이다. 각 구역은 차례로 0부터 L-1까지 번호가 매겨져 있다. 즉, 0 ≤ i ≤ L-2일 때, 구역 i와 구역 i+1는 서로 인접해 있고, 구역 0과 구역 L-1도 서로 인접해 있다. 개막식에 온 팀들은 모두 N개 팀이다. 각 팀은 이 구역들 중 하나에 앉아 있다. 각 구역에는 임의의 수의 팀들이 있을 수 있다. 어떤 구역에는 팀이 전혀 없을 수도 있다.선물은 모두 동일하며, 총 N개가 있다. 처음에, 아만과 모든 선물은 구역 0에 있다. 아만은 각 팀에게 선물을 하나씩 주어야 하며, 선물을 다 나눠준 다음에는 구역 0으로 돌아와야 한다. 구역 0에도 팀들이 있을 수 있음에 주의하자.어떤 순간에도, 아만은 최대 K개의 선물들만을 들 수 있다. 아만은 구역 0에서 선물을 들어야 하고, 드는데는 시간이 들지 않는다. 각각의 선물은 팀에게 전달될 때까지 아만이 들고 있어야 한다. 아만이 하나 이상의 선물을 들고 있고, 아직 선물을 받지 않은 팀(들)이 있는 구역에 도착하면, 아만은 들고 있는 선물을 팀(들)에게 줄 수 있다. 선물을 주는데도 시간이 들지 않는다. 시간이 드는 것은 단지 이동 뿐이다. 아만은 원형인 개막식장에서 양 방향으로 움직일 수 있다. 인접한 구역간을 이동하는데 (시계방향이든 반시계방향이든) 정확히 1초가 걸리며, 선물을 몇 개 들고 있는지와는 관계가 없다.아만이 모든 선물을 전달하고, 처음 위치로 돌아오는데 필요한 최소의 시간을 구하시오.이 예제에서 N = 3팀이 있고, 아만은 동시에 최대 K = 2개의 선물을 들 수 있으며, 구역의 수는 L = 8이다. 팀들은 구역 1, 2, 5에 있다.최적의 해 중 하나가 위 그림에 나와 있다. 처음에 아만은 선물 두 개를 들고, 이를 구역 2에 있는 팀에게 하나를 전달하고, 나머지 하나를 구역 5에 있는 팀에게 준 뒤 구역 0으로 돌아온다. 이 과정은 8초가 걸린다. 다음에 아만은 남은 선물 하나를 구역 1에 있는 팀에게 주고 다시 구역 0으로 돌아온다. 이 과정은 2초가 걸린다. 따라서, 전체 시간은 10초이다.N, K, L과 모든 팀들의 위치가 주어진다. 아만이 모든 선물을 전달하고 구역 으로 돌아오는데 걸리는 시간의 최솟값을 구하시오.이를 위하여 delivery 함수를 구현해야 한다:delivery(N, K, L, positions)N: 팀의 수K: 아만이 한 번에 들 수 있는 선물의 최대 개수L: 개막식장의 구역 수positions: 길이 N인 배열. positions[0], ..., positions[N-1]에 각 팀이 있는 구역 번호가 주어진다. positions의 성분들은 감소하지 않는 순서로 주어진다.이 함수의 리턴값은 아만이 임무를 완수하는데 최소 몇 초가 필요한지이다.delivery(N, K, L, positions)의 리턴값을 출력한다.","1 ≤ N ≤ 107, 1 ≤ K ≤ N, 1 ≤ L ≤ 109
",10919,1,19.0,"다이나믹 프로그래밍,그리디 알고리즘,","동적계획법,동적 계획법,다이나믹프로그래밍,탐욕법,"
/problem/10921,팀들,"0번 부터 N-1번까지 번호가 매겨진 학생 N명이 있다. 선생님은 학생들을 위해 날마다 하나 이상의 프로젝트들을 준비한다. 각 프로젝트는 정해진 날에 학생들끼리 모인 팀에 의해 해결되어야한다. 물론 프로젝트들은 서로 다른 난이도를 가질 수 있다. 선생님은 각 프로젝트 별로 난이도에 따라 맡을 팀의 크기를 정해놓았다.학생들마다 서로 들어갈 수 있는 팀의 크기가 다를 수 있다. 자세히 말하자면 i번 학생은 자신이 속하는 팀의 크기가 A[i]이상 B[i]이하가 되어야 한다. 각 날 별로 한 학생은 최대 하나의 팀에만 속할 수 있으며, 어떤 팀에도 속하지 않은 학생이 나올 수도 있다. 그리고 구성된 하나의 팀은 하나의 프로젝트만 맡는다.선생님은 이미 다음 Q일 동안의 프로젝트들을 계획해놓았다. 선생님의 계획이 성사되도록 학생들이 팀을 구성할 수 있을지 판단하는 프로그램을 작성하시오.N = 4명의 학생이 있고, Q = 2일 동안의 계획이 잡혀있다. 그리고 학생들이 속하는 팀 크기의 제한은 아래 표와 같다.학생0123A1222B2334첫째 날에는 M = 2개의 프로젝트가 계획 되어있다. 그리고 프로젝트를 해결하기 위해 정해놓은 팀의 크기는 K[0] = 1, K[1] = 3이다. 이 계획은 0번 학생이 팀의 크기가 1인 프로젝트에 참여 하고, 나머지 학생들이 팀의 크기가 3인 프로젝트에 참여하면 성사될 수 있다.둘째 날에도 M = 2개의 프로젝트가 계획되어 있으며, 프로젝트를 해결하기 위해 정해놓은 팀의 크기는 K[0] = 1, K[1] = 1이다. 크기가 1인 팀에 들어갈 수 있는 학생이 한 명 밖에 없으므로이 경우에는 계획이 성사될 수 없다.모든 학생에 대한 정보가 주어진다: N, A, B와 총 Q개의 날에 해당하는 정보가 주어지는데, 하루 에 하나씩이다. 각 정보는 그날 주어진 프로젝트의 수 M과 길이 M인 수열 K로 이루어지는데, K는 각 프로젝트에 필요한 팀의 크기를 저장하고 있다. 각각의 날마다, 여러분의 프로그램은 모든 팀을 구성할 수 있는지 여부를 리턴해야 한다.다음 함수 init 와 can을 구현해야 한다:init(N, A, B) — 그레이더는 맨 처음 이 함수를 정확히 한 번만 호출한다.	N: 학생의 수.A: 길이가 N인 배열: A[i]는 학생 i가 들어갈 수 있는 최소의 팀 크기이다.B: 길이가 N인 배열: B[i]는 학생 i가 들어갈 수 있는 최대의 팀 크기이다.이 함수는 리턴 값이 없다.각 i = 0, ..., N-1 인 경우에 대하여 1 ≤ A[i] ≤ B[i] ≤ N이 만족된다.can(M, K) — init을 일단 호출한 뒤, 그레이더는 이 함수를 차례로 Q번 연속으로 호출하는데, 각 날짜에 대해서 한번씩 호출한다.	M: 이날 잡혀 있는 프로젝트의 수.K: 길이 M인 배열로, 각각의 프로젝트에 정해진 팀 크기.이 함수의 리턴값은 만약 모든 팀을 구성할 수 있다면 1이고, 그렇지 못하면 0이다.1 ≤ M ≤ N 을 만족하며, 각각 i = 0, ..., M-1에 대하여 1 ≤ K[i] ≤ N 이다. 모든 K[i] 값들의 총합은 N을 넘을 수 있다.각 날짜에 대해서 can의 리턴값을 출력한다.","1 ≤ N ≤ 500,000, 1 ≤ Q ≤ 200,000, S ≤ 200,000
",10921,1,24.0,"이분 탐색,자료 구조,그리디 알고리즘,머지 소트 트리,퍼시스턴트 세그먼트 트리,세그먼트 트리,정렬,스택,","이분탐색,이진탐색,자료구조,자구,탐욕법,병합정렬트리,합병정렬트리,퍼시스턴트구간트리,구간트리,퍼시스턴트세그트리,구간트리,세그트리,fenwick,펜윅,"
/problem/10922,말,"만수르는 조상들과 마찬가지로 말을 키우는 것을 좋아한다. 그는 카자흐스탄에서 말을 제일 많이 갖고 있다. 그렇지만 꼭 항상 그랬던 것은 아닌데, N년 전에만 해도 만수르는 그저 젊은이일 뿐이어서 말이 한마리밖에 없었다. 만수르는 돈을 많이 벌어서 부자가 되고 싶었다.시간순으로 매 해를 0번 해부터 N-1번 해로 번호를 매기자. (즉, N-1번 해가 가장 최근이다.) 해마다 날씨는 말이 자라는데 영향을 미친다. 만수르가 기억하기로는, i번 해에 말의 마릿수가 늘어난 비율은 양의 정수 X[i]이다. 만약 i번 해 연초에 말이 h마리가 있었다면, 그 해 연말에는 말이 모두 h×X[i]마리가 된다.말은 매해 연말에만 팔 수 있다. 만수르가 기억하기로 i번 해의 말값은 양의 정수 Y[i]였다. 즉, 매해 연말에 갖고 있는 말 중 팔 수 있는 말의 수에는 제약이 없고, 말 한마리 값은 Y[i]로 모두 같다.만수르는 지난 N년 동안, 말을 파는 시기를 잘 정했다면 얼마나 많은 돈을 벌 수 있었을지가 궁금해졌다. 당신이 만수르를 방문했을 때 이 질문을 받게 되었다.저녁동안 만수르의 기억은 점점 정확해져서, 총 M번의 수정을 하게 된다. 수정을 한 번 할 때마다 X[i]의 값 중 하나, 또는 Y[i]의 값 중 하나가 바뀐다. 수정을 한 번 할 때마다 만수르는 말을 팔아 서 벌 수 있는 돈의 최댓값을 물어본다. 만수르가 수정할 때마다, 수정된 내용들은 누적된다. 즉, 만수르에게 대답할 때는 지금까지 만수르가 한 수정들을 모두 반영해야 한다. 한 X[i] 또는 Y[i]가 여러 번 수정되는 경우도 가능하다.만수르의 질문에 대한 답은 매우 큰 수일 수 있다. 큰 수를 다룰 때 생기는 문제를 피하기 위해서, 답을 109+7로 나눈 나머지를 알려주면 된다.N = 3년에 대해서 다음과 같은 정보가 주어졌다고 하자. 012X213Y341이 초기 정보를 가지고, 만수르는 1번 해 연말에 모든 말을 다 팔았다면 가장 많은 돈을 벌 수 있다. 전체 과정은 다음과 같다.처음에 만수르는 말이 한 마리 있다.0번 해 연말에 만수르는 1×X[0] = 2마리의 말이 있다.1번 해 연말에 만수르는 2×X[1] = 2마리의 말이 있다.이제 말 두 마리를 모두 팔 수 있다. 전체 이익은 2×Y[1] = 8이다.이제, M = 1번 수정을 하여 Y[1]이 2로 바뀌었다.수정 후의 정보는 다음과 같다. 012X213Y321이 경우, 최적해 중 하나는 한 마리를 0번 해 연말에 팔고 2번 해 연말에 세 마리를 파는 것이다. 전체 과정은 다음과 같다처음에 만수르는 말이 한 마리 있다.0번 해 연말에 만수르는 1×X[0] = 2마리의 말이 있다.이제 이 중 한 마리를 Y[0] = 3에 팔 수 있고, 한 마리가 남아 있다.1번 해 연말에 만수르는 1×X[1] = 1마리의 말이 있다.2번 해 연말에 만수르는 1×X[2] = 3마리의 말이 있다.이제 말 세 마리를 모두 3×Y[2] = 3에 팔 수 있다. 전체 이익은 3 + 3 = 6이다.N, X, Y와 수정된 내용의 리스트가 주어진다. 첫 번째 수정을 하기 전과, 매번 수정을 한 다음에 대해서 만수르가 말을 팔아서 벌 수 있는 돈의 최댓값을 109+7로 나눈 나머지를 구하라. 이를 위해서 함수 init, updateX, updateY를 구현해야 한다.init(N, X, Y) — 그레이더는 이 함수를 맨 처음 정확히 한 번 호출한다.	N: 전체 해 수X: 길이 N인 배열. 0 ≤ i ≤ N-1일 때, X[i]는 i번 해 연말에 말의 마릿수가 늘어난 비율이다.Y: 길이 N인 배열. 0 ≤ i ≤ N-1일 때, Y[i]는 i번 해 연말에 말 한마리의 값이다.X와 Y는 만수르가 처음에 준 값을 나타낸다. (수정을 하기 전의 값)init 함수가 종료한 후, 배열 X와 Y는 유효한 주소에 있으며, 원한다면 이 배열의 내용을 수정할 수 있다.이 함수는 X와 Y의 초기값을 가지고 만수르가 말을 팔아서 벌 수 있는 돈의 최댓값을 109+7로 나눈 나머지를 리턴해야 한다.updateX(pos, val)	pos: 0, ..., N-1 범위 내의 정수.val: X[pos]의 새로운 값.이 함수는 주어진 정보에 따라 수정을 한 후, 만수르가 말을 팔아서 벌 수 있는 돈의 최댓값을 109+7로 나눈 나머지를 리턴해야 한다.updateY(pos, val)	pos: 0, ..., N-1 범위 내의 정수.val: Y[pos]의 새로운 값.이 함수는 주어진 정보에 따라 수정을 한 후, 만수르가 말을 팔아서 벌 수 있는 돈의 최댓값을 109+7로 나눈 나머지를 리턴해야 한다.모든 X[i]와 Y[i]의 값은 항상 (즉, 처음에도, 매번 수정을 한 다음에도) 1이상 109이하를 만족한다.init을 호출한 후, 그레이더는 updateX와 updateY를 여러 번 호출할 것이다. updateX와 updateY의 전체 호출 회수는 M이다.처음 init의 리턴값을 출력하고, 차례로 updateX와 updateY의 모든 호출에 대한 리턴값을 출력한다.","1 ≤ N ≤ 500,000, 0 ≤ M ≤ 100,000
",10922,1,20.0,"자료 구조,세그먼트 트리,트리를 사용한 집합과 맵,","자료구조,자구,구간트리,세그트리,fenwick,펜윅,집합,맵,셋,딕셔너리,dictionary,map,set,bbst,트리,tree,"
/problem/10923,정렬하기,"아이잔은 N개의 정수 S[0], S[1], ..., S[N-1]로 이루어진 수열 S를 가지고 있다. 수열은 0부터 N-1까지 서로 다른 N개의 정수로 이루어져있다. 아이잔은 두 수의 위치를 바꾸며 이 수열을 오름차순으로 정렬하려고 한다. 아이잔의 오랜 친구인 에르맥도 수열에서 두 수를 바꾸는데, 아이잔과는 다르게 정렬하려는 목적 없이 아무렇게나 바꾼다.아이잔과 에르맥은 라운드를 거치며 수열을 조작한다. 각 라운드마다, 에르맥이 먼저 위치 바꾸기를 하고 그 다음 아이잔이 위치 바꾸기를 한다. 위치 바꾸기에 대해서 좀 더 자세히 말하자면, 바꿀 두 위치를 정하고 그 위치에 있는 값을 맞바꾼다. 이때 정하는 두 위치가 다를 필요는 없다. 만약 정한 두 위치가 같으면 수열에 아무런 변화가 없다.아이잔은 에르맥이 수열 S를 정렬하려는 목적 없이 아무렇게나 바꾼다는 사실을 알고 있다. 더 나아가서 라운드를 시작하기 전부터 에르맥이 어떻게 위치 바꾸기를 할 건지 미리 다 알고 있다. 에르맥은 M 라운드에 대한 계획을 가지고 있다. 라운드의 번호를 순서대로 0 부터 M-1 까지 매겼을 때, i번 라운드에서 에르맥이 바꿀 두 위치는 X[i]와 Y[i]이다.아이잔은 수열 S를 오름차순으로 정렬하길 원한다. 각 라운드를 시작하기 전에 만약 수열이 이미 정렬되어 있다면 라운드를 더 이상 진행하지 않고 멈출 수 있다. 처음 수열 S에 대한 정보와 에르맥이 M 라운드 동안 어떻게 위치 바꾸기를 할지에 대한 정보가 주어졌을 때, 아이잔이 어떻게 위치 바꾸기를 해야할지 구하시오. 언제나 M 라운드 안에 정렬이 가능하도록 입력이 주어진다.만약 어떤 라운드에서 에르맥이 위치 바꾸기를 한 뒤 수열이 정렬되어 있다면, 아이잔은 같은 두 위치를 맞바꿔주면 된다 (예를 들어 0번 위치와 0번 위치). 그러면 이 라운드의 끝에서 수열 S는 정렬되고 아이잔은 멈출 수 있다. 또한 처음부터 수열 S가 정렬되어 있다면 필요한 라운드의 최소 수는 0 이다.예제 1처음 수열 S = 4, 3, 2, 1, 0에르맥은 M = 6라운드를 진행하려 한다.에르맥이 바꿀 위치에 대한 정보 X와 Y는 X = 0, 1, 2, 3, 0, 1이며, Y = 1, 2, 3, 4, 1, 2 이다. 다르게 얘기하면 에르맥은 (0, 1), (1,2), (2,3), (3,4), (0, 1) 그리고 (1, 2) 순서대로 위치를 바꿀 계획이다.이러한 상황에서 아이잔은 3 라운드 만에 수열 S를 0, 1, 2, 3, 4로 정렬할 수 있다. 아이잔은 (0, 4), (1, 3) 그리고 (3, 4) 순서대로 위치 바꾸기를 하면 된다.아래 표는 각 위치 바꾸기마다 수열 S의 내용이 어떻게 바뀌는지 나타내고 있다.라운드사람바꿀 두 위치수열초기  4, 3, 2, 1, 00에르맥(0, 1)3, 4, 2, 1, 00아이잔(0, 4)0, 4, 2, 1, 31에르맥(1, 2)0, 2, 4, 1, 31아이잔(1, 3)0, 1, 4, 2, 32에르맥(2, 3)0, 1, 2, 4, 32아이잔(3, 4)0, 1, 2, 3, 4예제 2처음 수열 S = 3, 0, 4, 2, 1에르맥은 M = 5라운드를 진행하려 한다.에르맥은 (1, 1), (4, 0), (2, 3), (1, 4) 그리고 (0, 4) 순서대로 위치를 바꿀 계획이다.이러한 상황에서 아이잔은 3 라운드 만에 수열 S를 정렬할 수 있다. 아이잔은 (1, 4), (4, 2) 그리고 (2, 2) 순서대로 위치 바꾸기를 하면 된다.아래 표는 각 위치 바꾸기마다 수열 S의 내용이 어떻게 바뀌는지 나타내고 있다.라운드사람바꿀 두 위치수열초기  3, 0, 4, 2, 10에르맥(1, 1)3, 0, 4, 2, 10아이잔(1, 4)3, 1, 4, 2, 01에르맥(4, 0)0, 1, 4, 2, 31아이잔(4, 2)0, 1, 3, 2, 42에르맥(2, 3)0, 1, 2, 3, 42아이잔(2, 2)0, 1, 2, 3, 4수열 S와 정수 M, 그리고 X, Y가 주어진다.아이잔이 수열 S를 정렬하기 위해 어떻게 위치를 바꿀지에 대해 계산하자.다음 함수 findSwapPairs를 구현해야 한다.findSwapPairs(N, S, M, X, Y, P, Q) — 이 함수는 단 한 번 그레이더에 의해 호출된다.	N: 수열 S의 크기S: 처음 수열 S에 대한 정보를 가지고 있는 정수 배열M: 에르맥이 계획한 라운드 수X, Y: 크기가 M인 정수 배열들. 0 ≤ i ≤ M-1 인 i에 대해 i번 라운드에서 에르맥은 두 위치 X[i], Y[i]에 있는 수를 맞바꾼다.P, Q: 정수 배열들. 아이잔이 바꿀 위치에 대한 정보를 위해 필요한 배열이다. R이 여러분이 구한 정렬하기 위해 필요한 라운드 수라고 하자. 0과 R-1 사이의 i에 대해서 i번 라운드에 아이잔이 고른 맞바꿀 두 위치를 P[i]와 Q[i]에 저장한다. 배열 P와 Q는 이미 크기 M으로 메모리가 잡혀있다.이 함수는 위에 정의된 R 값을 리턴해야 한다.M라운드 혹은 보다 더 일찍 정렬 가능하도록 입력이 주어진다.findSwapPairs가 리턴한 값을 출력한다.","0, 1, 2, 3, 4",10923,1,16.0,"애드 혹,해 구성하기,순열 사이클 분할,","constructive,컨스트럭티브,구성적,"
/problem/10924,정렬하기 2,"아이잔은 N개의 정수 S[0], S[1], ..., S[N-1]로 이루어진 수열 S를 가지고 있다. 수열은 0부터 N-1까지 서로 다른 N개의 정수로 이루어져있다. 아이잔은 두 수의 위치를 바꾸며 이 수열을 오름차순으로 정렬하려고 한다. 아이잔의 오랜 친구인 에르맥도 수열에서 두 수를 바꾸는데, 아이잔과는 다르게 정렬하려는 목적 없이 아무렇게나 바꾼다.아이잔과 에르맥은 라운드를 거치며 수열을 조작한다. 각 라운드마다, 에르맥이 먼저 위치 바꾸기를 하고 그 다음 아이잔이 위치 바꾸기를 한다. 위치 바꾸기에 대해서 좀 더 자세히 말하자면, 바꿀 두 위치를 정하고 그 위치에 있는 값을 맞바꾼다. 이때 정하는 두 위치가 다를 필요는 없다. 만약 정한 두 위치가 같으면 수열에 아무런 변화가 없다.아이잔은 에르맥이 수열 S를 정렬하려는 목적 없이 아무렇게나 바꾼다는 사실을 알고 있다. 더 나아가서 라운드를 시작하기 전부터 에르맥이 어떻게 위치 바꾸기를 할 건지 미리 다 알고 있다. 에르맥은 M 라운드에 대한 계획을 가지고 있다. 라운드의 번호를 순서대로 0 부터 M-1 까지 매겼을 때, i번 라운드에서 에르맥이 바꿀 두 위치는 X[i]와 Y[i]이다.아이잔은 수열 S를 오름차순으로 정렬하길 원한다. 각 라운드를 시작하기 전에 만약 수열이 이미 정렬되어 있다면 라운드를 더 이상 진행하지 않고 멈출 수 있다. 처음 수열 S에 대한 정보와 에르맥이 M 라운드 동안 어떻게 위치 바꾸기를 할지에 대한 정보가 주어졌을 때, 아이잔이 어떻게 위치 바꾸기를 해야할지 구하시오. 추가적으로, 어떤 부분 문제에 대해서는 가능한 가장 적은 라운드 만에 정렬을 해야할 수도 있다. 언제나 M 라운드 안에 정렬이 가능하도록 입력이 주어진다.만약 어떤 라운드에서 에르맥이 위치 바꾸기를 한 뒤 수열이 정렬되어 있다면, 아이잔은 같은 두 위치를 맞바꿔주면 된다 (예를 들어 0번 위치와 0번 위치). 그러면 이 라운드의 끝에서 수열 S는 정렬되고 아이잔은 멈출 수 있다. 또한 처음부터 수열 S가 정렬되어 있다면 필요한 라운드의 최소 수는 0 이다.예제 1처음 수열 S = 4, 3, 2, 1, 0에르맥은 M = 6라운드를 진행하려 한다.에르맥이 바꿀 위치에 대한 정보 X와 Y는 X = 0, 1, 2, 3, 0, 1이며, Y = 1, 2, 3, 4, 1, 2 이다. 다르게 얘기하면 에르맥은 (0, 1), (1,2), (2,3), (3,4), (0, 1) 그리고 (1, 2) 순서대로 위치를 바꿀 계획이다.이러한 상황에서 아이잔은 3 라운드 만에 수열 S를 0, 1, 2, 3, 4로 정렬할 수 있다. 아이잔은 (0, 4), (1, 3) 그리고 (3, 4) 순서대로 위치 바꾸기를 하면 된다.아래 표는 각 위치 바꾸기마다 수열 S의 내용이 어떻게 바뀌는지 나타내고 있다.라운드사람바꿀 두 위치수열초기  4, 3, 2, 1, 00에르맥(0, 1)3, 4, 2, 1, 00아이잔(0, 4)0, 4, 2, 1, 31에르맥(1, 2)0, 2, 4, 1, 31아이잔(1, 3)0, 1, 4, 2, 32에르맥(2, 3)0, 1, 2, 4, 32아이잔(3, 4)0, 1, 2, 3, 4예제 2처음 수열 S = 3, 0, 4, 2, 1에르맥은 M = 5라운드를 진행하려 한다.에르맥은 (1, 1), (4, 0), (2, 3), (1, 4) 그리고 (0, 4) 순서대로 위치를 바꿀 계획이다.이러한 상황에서 아이잔은 3 라운드 만에 수열 S를 정렬할 수 있다. 아이잔은 (1, 4), (4, 2) 그리고 (2, 2) 순서대로 위치 바꾸기를 하면 된다.아래 표는 각 위치 바꾸기마다 수열 S의 내용이 어떻게 바뀌는지 나타내고 있다.라운드사람바꿀 두 위치수열초기  3, 0, 4, 2, 10에르맥(1, 1)3, 0, 4, 2, 10아이잔(1, 4)3, 1, 4, 2, 01에르맥(4, 0)0, 1, 4, 2, 31아이잔(4, 2)0, 1, 3, 2, 42에르맥(2, 3)0, 1, 2, 3, 42아이잔(2, 2)0, 1, 2, 3, 4수열 S와 정수 M, 그리고 X, Y가 주어진다.아이잔이 수열 S를 정렬하기 위해 어떻게 위치를 바꿀지에 대해 계산하자. 정렬할 수 있는 가능한 가장 적은 라운드 안에 정렬 해야한다.다음 함수 findSwapPairs를 구현해야 한다.findSwapPairs(N, S, M, X, Y, P, Q) — 이 함수는 단 한 번 그레이더에 의해 호출된다.	N: 수열 S의 크기S: 처음 수열 S에 대한 정보를 가지고 있는 정수 배열M: 에르맥이 계획한 라운드 수X, Y: 크기가 M인 정수 배열들. 0 ≤ i ≤ M-1 인 i에 대해 i번 라운드에서 에르맥은 두 위치 X[i], Y[i]에 있는 수를 맞바꾼다.P, Q: 정수 배열들. 아이잔이 바꿀 위치에 대한 정보를 위해 필요한 배열이다. R이 여러분이 구한 정렬하기 위해 필요한 라운드 수라고 하자. 0과 R-1 사이의 i에 대해서 i번 라운드에 아이잔이 고른 맞바꿀 두 위치를 P[i]와 Q[i]에 저장한다. 배열 P와 Q는 이미 크기 M으로 메모리가 잡혀있다.이 함수는 위에 정의된 R 값을 리턴해야 한다.M라운드 혹은 보다 더 일찍 정렬 가능하도록 입력이 주어진다.findSwapPairs가 리턴한 값을 출력한다.","6 ≤ N ≤ 200,000, M = 3N, R은 가능한 작은 값이어야 한다.
",10924,1,21.0,"매개 변수 탐색,순열 사이클 분할,","파라메트릭,"
/problem/11027,교환,"길이 N의 배열 A와 정수 M이 있고. 지학이는 다음과 같은 프로그램을 짰다.for i<-1 to M do     for j<-i+1 to N do          if A[i]>A[j] then             swap(A[i],A[j])지학이는 이 프로그램에서 swap 함수가 몇번 작동되는지 궁금해서 여러분을 찾았다. 몇번 작동하는가?각 테스트 케이스마다 교환 횟수를 한 줄에 출력하라.",19.355%,11027,1,21.0,"자료 구조,세그먼트 트리,정렬,","자료구조,자구,구간트리,세그트리,fenwick,펜윅,"
/problem/11328,Strfry,"C 언어 프로그래밍에서 문자열(string)은 native한 자료형이 아니다. 사실, 문자열은 그저, 문자열의 끝을 표시하기 위한 말단의 NULL이 사용된, 문자들로 이루어진 문자열일 뿐이다. 하지만 프로그래밍 언어에서 문자열을 다루는 것은 매우 중요하기 때문에, C 표준 라이브러리는 문자열을 다루는 데에 매우 유용한 함수들을 제공하고 있다 : 그들 중에는 strcpy, strcmp, strtol, strtok, strlen, strcat 가 있다.하지만, 잘 알려져 있지 않으며, 잘 사용되지도 않는 함수가 하나 있다 : strfry 함수다. strfry 함수는 입력된 문자열을 무작위로 재배열하여 새로운 문자열을 만들어낸다. (역자 주 : 여기에서 입력된 문자열과 새로 재배열된 문자열이 다를 필요는 없다.)두 개의 문자열에 대해, 2번째 문자열이 1번째 문자열에 strfry 함수를 적용하여 얻어질 수 있는지 판단하라.각각의 테스트 케이스에 대해, 2번째 문자열이 1번째 문자열에 strfry 함수를 적용하여 얻어질 수 있는지의 여부를 ""Impossible""(불가능) 또는 ""Possible""(가능)으로 나타내시오. (따옴표는 제외하고 출력한다.)",40.722%,11328,1,4.0,"구현,문자열,","스트링,"
/problem/11390,맛있는 과자,"엘리가 좋아하는 과자는 직각삼각형 모양이고, 빗변을 제외한 다른 두 변의 길이가 각각 a와 b이다. 어느 날 엘리는 이 과자를 많이 많이 먹을 수 있는 방법을 떠올리고 자신의 천재성에 전율했다.엘리는 빗변의 양 끝점이 아닌 점에서 빗변으로 과자를 자르면 직각삼각형 두 개를 만들 수 있다는 것을 알았다! 사실 이렇게 잘라봐야 과자의 총 면적은 같지만, 어린 엘리는 과자가 두 개가 되었다는 사실이 너무 행복했고 이런 방법을 떠올린 자신이 너무 기특했다. 그리고 또 생각했다. 직각삼각형 모양 과자가 두 개가 되었으니까 이 두 개를 아까처럼 자르면 직각삼각형 모양 과자가 네 개… 여덟 개… 2N개! 즉 엘리가 하나의 직각삼각형 모양 과자를 가지고 시작해서 자신이 가진 모든 과자를 잘라 과자의 개수를 두 배로 불리는 것을 N번 반복하면 엘리가 가진 직각삼각형 모양 과자의 개수는 2N개가 되는 것이다! 이렇게 자르는 것은 엘리가 가진 놀라운 힘을 이용하면 간단한 것이었고, 엘리는 이미 이런 식으로 과자들을 자르는 행위를 N번 반복해 2N개의 조각을 가지고 있다.엘리는 이 과자들을 모두 먹고 싶었지만 모두 먹기에는 너무 조각이 많다고 생각해서 2N개의 조각들 중 크기(=면적)가 K번째로 큰 한 조각은 바보 피터에게 주기로 했다. 피터가 받게 될 과자의 면적이 얼마지 구하는 프로그램을 작성하라.첫 번째 줄에 피터가 받게 될 과자의 크기(=면적)를 출력한다. 다만 이 값이 너무 작을 수 있으므로, 면적에 자연 로그(\(\ln{}\))을 취한 값을 출력한다. (즉 면적이 S라면, \(\ln{S}\)의 값을 출력해야 한다.) math.h 또는 cmath 헤더에 있는 log 함수(레퍼런스)가 자연 로그를 계산하는 함수이다.",43.182%,11390,1,14.0,"조합론,기하학,수학,","combination,permutation,probability,확률,순열,"
/problem/11691,"LCM(i, j)","재현이는 다음과 같은 소스를 작성했다.long long mod = 1000000007;long long all_pair_lcm(int n) {    long long ans = 0;    for (int i=1; i<=n-1; i++) {        for (int j=i+1; j<=n; j++) {            ans += lcm(i, j);            ans %= mod;        }    }    return ans;}n이 큰 경우에 위의 소스를 그대로 실행하면 시간초과가 난다.n이 주어졌을 때, all_pair_lcm(n)을 리턴값을 출력하는 프로그램을 작성하시오.lcm(i, j)는 i와 j의 최소공배수를 구하는 함수이다.첫째 줄에 all_pair_lcm(n)을 리턴값을 출력한다.",38.189%,11691,1,21.0,"수학,정수론,",
/problem/11692,시그마 함수,"시그마 함수 σ(n)은 정수 n의 약수의 합을 구하는 함수이다.예를 들어, σ(2) = 1+2 = 3이고, σ(6) = 1+2+3+6 = 12, σ(12) = 1+2+3+4+6+12 = 28 이다.m이 주어졌을 때, 1 ≤ n ≤ m인 모든 n의 σ(n) 중에서 값이 짝수인 것이 몇 개 있는지 구하는 프로그램을 작성하시오.첫째 줄에 1 ≤ n ≤ m인 모든 n의 σ(n) 중에서 값이 짝수인 것의 개수를 출력한다.",58.462%,11692,1,13.0,"수학,정수론,",
/problem/11897,간선 파괴,"승현이는 곧 개최되는 KOI 전국본선을 대비하기 위해 그래프 이론을 공부하고 있습니다. 요즘 승현이는 깊이우선탐색(DFS)과 너비우선탐색(BFS)의 매력에 푹 빠져 있고, 이를 이용한 문제들을 풀고 있다고 합니다. 지금 승현이는 V개 정점과 E개 간선으로 구성된 무향 그래프가 주어질 때 컴포넌트의 수를 세는 문제를 풀고 있습니다. 문제에서는 편의상 정점들에는 1,2,⋯,V의 번호를, 간선들에는 1,2,⋯,E의 번호를 붙이고, 중복된 간선은 없다고 가정했습니다.참고: 여기서 무향 그래프가 간선으로 서로 연결되지 않은 몇 개의 그룹으로 나뉘어 있을 때, 각 연결된 정점들의 부분집합을 컴포넌트라고 합니다. 예로 들어, 아래 [그림 1]에서는 {1,2,5,8}, {3}, {4,6,7}이 각각 하나의 컴포넌트를 이루고 있습니다. [그림 2]와 같이 그래프 전체가 하나의 컴포넌트로 구성되어 있을 수도 있습니다.승현이는 당연히 문제를 보자마자 코딩을 시작하여 DFS를 사용한 올바른 코드를 작성했지만 0점을 받았습니다. 승현이의 선생님께서 코드를 보고 ""재귀 함수를 사용했다""면서 채점조차 하지 않았기 때문입니다.(?) 화가 난 승현이는 주어진 그래프에서 l, l+1, l+2, ..., r-1, r번 간선들을 destroy(l, r) 함수로 파괴하기 시작합니다. (번호가 연속적인 이유는 파괴하기 편해서라고 합니다.)[그림 3] 위 그림에서 간선 위에 쓰인 빨간색 번호는 그 간선의 번호를 의미합니다. 승현이가 destroy(3, 5)를 호출하여 3, 4, 5번 간선이 파괴되었습니다.그러나 승현이보다 유능한 프로그래머인 여러분은 재귀 함수를 이용하지 않고 컴포넌트의 수를 구할 수 있기 때문에, 간선이 파괴된 그래프의 컴포넌트 수를 구한 뒤 recover(l, r) 함수를 호출해 파괴된 l, l+1, l+2, ..., r-1, r번 간선들을 복구하여 승현이를 약올리고자 합니다.[그림 4] 위 그림에서 여러분은 파괴된 그래프의 컴포넌트 수(2)를 구한 뒤 recover(3, 5) 함수를 호출하여 간선을 복원했습니다.그러자 승현이는 destroy 함수를 계속 호출했고, 이에 일일이 대응하기에 지친 여러분은 프로그램을 작성하여 이 복잡한 작업을 대신 하게 하려고 합니다. 이제 프로그램을 작성하면 되겠네요! :)여러분은 승현이가 destroy 함수를 호출할 때마다 파괴된 그래프의 컴포넌트 수를 구하여 한 줄에 하나씩 출력한 뒤, 그래프를 다시 복원해야 합니다. 승현이는 자비롭기 때문에 여러분이 그래프를 복구한 후에야 destroy 함수를 호출합니다.",24.427%,11897,1,20.0,"자료 구조,분리 집합,그래프 이론,","자료구조,자구,union,find,유니온,파인드,그래프이론,"
/problem/12855,홍준이는 FFT를 좋아해,"홍준이는 Fast Fourier Transformation(FFT)을 좋아하고 즐겨 사용해요.FFT는 convolution을 계산하는 알고리즘입니다. 길이가 n이고 0번째 원소부터 n-1번째 원소까지 있는 수열 a, b가 있고 c가 다음과 같이 정의될 때 c를 빠르게 계산해줍니다.\[c_i = \sum_{j=0}^{i}{a_jb_{i-j}}\]홍준이는 이 식을 조금 바꾸어보았습니다.\[c_i = \max(a_jb_{i-j}) (0 \le j \le i)\]계산하기가 편하도록 홍준이는 수열 a는 1부터 n까지의 원소만 가지고, 수열 b는 0 또는 1인 원소만 가지는 경우만 고려합니다. 수열 a와 수열 b가 주어졌을 때, 홍준이를 대신에 수열 c를 계산해주는 프로그램을 작성하세요.홍준이는 게을러서 수열 a와 수열 b조차 그 원소들을 다 알려주기 귀찮아서, 세 개의 정수 n, d, x로 여러분이 수열 a와 b를 직접 생성하길 바랍니다. 수열 a와 b를 계산하는 의사코드는 다음과 같습니다. ‘%’ 연산은 나머지를 구하는 연산이고, ‘swap( )’은 값을 교환하는 함수입니다.//x is 64-bit variable;function getNextX() {    x = (x * 37 + 10007) % 1000000007;    return x;}function initAB() {    for(i = 0; i < n; i = i + 1){        a[i] = i + 1;    }    for(i = 0; i < n; i = i + 1){        swap(a[i], a[getNextX() % (i + 1)]);    }    for(i = 0; i < n; i = i + 1){        if (i < d)            b[i] = 1;        else            b[i] = 0;    }    for(i = 0; i < n; i = i + 1){        swap(b[i], b[getNextX() % (i + 1)]);    }}수열 c의 원소들을 0번째 원소부터 n-1번째 원소까지 차례대로 공백을 사이에 두고 출력한다.",29.730%,12855,1,19.0,"무작위화,제곱근 분할법,","랜덤,루트분할법,평방분할법,모,mo,sqrt,"
/problem/12917,문자열 함수 계산,"문자열 T가 주어진다. 문자열 S에 대한 비용 함수 F(S) = (S의 길이) × (T에서 S가 등장하는 횟수)로 정의한다. T에서 S가 등장한다는 의미는 S가 T의 부분문자열로 존재한다는 의미이다. 예를 들어, T = ""aaaaa"", S = ""aaa""이면, T에서 S가 3번 등장하기 때문에, F(S) = 3 × 3 = 9가 된다. 소문자로만 이루어진 문자열 T가 주어졌을 때, T의 모든 부분문자열 중에서 비용 함수의 값이 최대인 것을 구해보자T의 모든 부분문자열 중에서 비용 함수의 최댓값을 출력한다.",28.659%,12917,1,21.0,"자료 구조,스택,문자열,접미사 배열과 LCP 배열,","자료구조,자구,스트링,"
/problem/12980,좋아하는 수열,"BOJ 알고리즘 캠프에 참가하는 사람들은 수열을 좋아한다. 각 사람은 수열을 얼마나 좋아하는지 나타내는 함수를 가지고 있다.캠프의 강사인 성관이가 제일 좋아하는 수열은 오름차순으로 정렬되어 있는 수열이다. 성관이는 수열 S를 보면, 머리속으로 i < j이면서 S[i] < S[j]인 (i, j) 쌍의 개수를 보는 즉시 계산해낸다. 이 값을 성관이가 수열을 좋아하는 ""점수""라고 한다.홍준이는 아침에 오자마자 1부터 N으로 이루어진 순열을 칠판에 적어놓았다. 성관이는 301호에 들어오자마자 칠판을 바라보았고, 그 즉시 적혀있는 순열의 점수를 계산해냈다. 점심을 먹으면서 홍준이가 적은 순열이 무엇인지 다시 한 번 생각해 보려고 했다. 하지만, ""점수""는 기억이 나지만 순열은 전혀 기억이 나지 않았다.점심을 먹는 내내 칠판에 적혀있는 순열이 무엇인지 궁금했던 성관이는 점심을 먹고 301호에 들어오자마자 칠판을 쳐다보았다. 칠판에는 순열이 적혀있었지만, 일부 수는 지워져 있었다. 성관이는 이제 홍준이가 적은 순열이 무엇이었는지를 아침에 계산한 ""점수""를 이용해서 다시 만들어보려고 한다.성관이가 아침에 계산한 ""점수""와 현재 칠판에 적혀있는 순열이 주어졌을 때, 순열을 만들 수 있는 방법의 수를 구하는 프로그램을 작성하시오.첫째 줄에 점수가 S가 되게 순열을 채울 수 있는 방법을 출력한다.",67.925%,12980,1,11.0,"브루트포스 알고리즘,","완전탐색,완전 탐색,브루트포스,bruteforce,brute force,완탐,"
/problem/13010,h(n),"성관이는 양의 정수에서 동작하는 함수 h를 공부하고 있다.먼저, d(n)을 n의 서로 다른 양의 약수의 개수로 정의한다.h(n) = nd(n)이다. 즉, n을 d(n)만큼 제곱한 것이 h(n) 이다.예를 들어, d(6) = 4이기 때문에, h(6) = 64 = 1296이 된다.정수 n이 주어졌을 때, h(x) = n을 만족하는 가장 작은 x를 찾는 프로그램을 작성하시오.첫째 줄에 h(x) = n을 만족하는 가장 작은 x를 출력한다. 만약, 그러한 x가 없으면 -1을 출력한다.",15.108%,13010,1,14.0,"이분 탐색,브루트포스 알고리즘,수학,정수론,","이분탐색,이진탐색,완전탐색,완전 탐색,브루트포스,bruteforce,brute force,완탐,"
/problem/13130,FunctionCup,"민혁이는 집합 S = 1, 2, …, N에 대해서 함수 f : S -> S를 만들었다. 민혁이가 만든 함수는 재미있는 성질을 갖고 있다.1) f(f(…f(1)…)) = 1 (단, f는 총 A1개)2) f(f(…f(2)…)) = 2 (단, f는 총 A2개)…N) f(f(…f(N)…)) = N (단, f는 총 AN개)민혁이는 이런 성질을 만족하는 서로 다른 함수를 총 몇 개나 만들 수 있을지 궁금해졌다. 민혁이를 도와 A1, A2, …, AN이 주어졌을 때 서로 다른 함수를 총 몇 개 만들 수 있는지 구하는 프로그램을 작성하여라. 두 함수 g, h에 대해서 g(x)≠h(x)를 만족하는 x가 있다면 g, h는 서로 다른 함수이다.첫 번째 줄에 조건을 만족하도록 함수를 만드는 방법의 수를 출력한다.",69.388%,13130,1,20.0,"비트마스킹,조합론,다이나믹 프로그래밍,비트필드를 이용한 다이나믹 프로그래밍,수학,","비트필드,combination,permutation,probability,확률,순열,동적계획법,동적 계획법,다이나믹프로그래밍,동적계획법,비트마스크,비트dp,"
/problem/13180,순열,"길이가 N 인 순열이란, 1 이상 N 이하의 자연수 N 개로 이루어진, 같은 수가 두 번 이상 등장하지 않는 수열을 의미한다. 길이가 N 인 순열의 종류는 총 N!개가 있다.이 순열에서 K-minsum이라는 것을 정의할 것이다. 순열 A 가 있고, 각 원소를 순서대로 나열하면 A1, A2, ..., AN일 때, 순열 A 의 K-minsum은\[\text{K-minsum}(A) = \sum_{i=1}^{N}{\sum_{j=i+K}^{N}{\text{min}(A_i, A_{i+1}, \cdots, A_{j-1}, A_j)}}\]이다. min은 인자로 나열된 수 중의 최솟값을 구하는 함수이다. K 가 주어질 때, 길이가 N인 모든 N!개의 순열에 대해 K-minsum을 구해 그 합을 출력하는 프로그램을 작성하라.길이가 N 인 모든 N!개의 순열에 대해 K-minsum을 구해 그 합을 출력한다. 합이 매우 커질 수 있으므로 1,000,000,007로 나눈 나머지를 출력해야 한다.",85.714%,13180,1,20.0,"조합론,확장 유클리드 호제법,수학,모듈로 곱셈 역원,정수론,","combination,permutation,probability,확률,순열,확장유클리드알고리즘,egcd,modinv,"
/problem/13318,위험한 해싱,"string matching 알고리즘에는 여러 가지가 있다. KMP 알고리즘이나 Boyer­Moore 알고리즘이 그 예시이다. 하지만 지구이는 KMP를 이해할 수 없었고, Boyer­Moore는 시간복잡도가 너무 컸다. 결국 지구이는 틀릴 확률이 있지만, 간단한 방법인 해싱을 즐겨 사용하게 되었다. 해싱은 문자열을 숫자 하나로 바꾸는 해시 함수를 하나 정의한 후, 이 값이 같은지 다른지를 통해 문자열이 같은지 판별하는 방법이다.지구이는 해시 함수를 다음과 같이 정의했다.길이가 n인 문자열 d[0] ~ d[n­1]와 임의의 숫자 p에 대하여 해시 함수 값은 아래와 같다. (d[i]는 해당 문자의 ASCII 코드 값이다.)H(p, d) = p0 * d[0] + p1 * d[1] + ... + pn-1 * d[n­1] (mod (10^9 + 7))지구이는 Codeforces 대회에서 H(29, d)를 해시 함수로 사용하였다. 이는 H(29, d) = H(29, e)인 두 문자열 d, e가 있다면, d, e는 같은 문자열로 판별하는 것을 의미한다. 하지만 우연히 같은 룸에 도토리가 있었고, 도토리는 해시 값이 같은 두 문자열을 찾아 핵을 성공시켰다.결국 지구이는 그 문제를 풀지 못했으며, 도토리에게 해싱이 너무 약했기 때문에 틀렸다는 사실을 듣게 되었다. 그 후로 지구이는 해시 함수로 H(29, d) 뿐만이 아니라, p의 값이 31, 37, 41, 43, 47, 53, 59, 61, 67인 해시 함수도 사용하기로 했다. 즉, 문자열 각각에 대하여 10개의 해시 함수를 계산한 후, 모든 해시 함수의 값이 같을 때만 두 문자열이 같다고 판별하는 것이다.이제 지구이는 자신이 틀릴 리가 없다고 생각하고 있다. 해시 함수 10개의 값이 같은 문자열 2개를 만들어 KMP의 아름다움을 보여주자!지구이의 코드는 여기에 있다.첫 번째 줄에 문자열 A를 출력한다.",59.375%,13318,1,24.0,"해 구성하기,해싱,수학,정수론,","constructive,컨스트럭티브,구성적,"
/problem/13713,문자열과 쿼리,"문자열 S = S1S2...SN이 주어진다. 함수 F(i)는 S와 S1S2...Si의 가장 긴 공통 접미사의 길이로 정의된다.예를 들어, S = ""zaaxbaacbaa""인 경우에, F(1) = 0, F(2) = 1, F(3) = 2이다.문자열 S와 쿼리 M개가 주어졌을 때, 각각의 쿼리에 대해서, F(i)를 구하는 프로그램을 작성하시오.각각의 쿼리 i에 대해서, F(i)를 출력한다.",45.421%,13713,1,16.0,"문자열,z,","스트링,"
/problem/13726,랜덤 소트 2,"랜덤 소트는 크기가 N인 순열 P를 아래와 같은 알고리즘을 이용해서 정렬하는 방법이다.function random_sort(permutation P) {	swaps = 0;	while (not sorted P) {		(i, j) = random pair (1 <= i < j <= n)		swap(P[i], P[j])		swaps = swaps + 1;	}	return swaps;}순열 P가 주어졌을 때, random_sort 함수의 리턴값의 기댓값을 구하는 프로그램을 작성하시오.입력으로 주어진 순열 P를 random_sort 함수로 정렬할 때, 리턴값의 기댓값을 출력한다. 절대/상대 오차는 10-6까지 허용한다.",100.000%,13726,1,0.0,0,
/problem/14181,함수와 쿼리,"다음과 같은 함수가 있다.f(1, j) = a[j], 1 ≤ j ≤ nf(i, j) = min(f(i-1, j), f(i-1, j-1)) + a[j], 2 ≤ i ≤ n, i ≤ j ≤ n여기서 a는 길이가 n인 배열이다.배열 a의 값과 쿼리 xi, yi가 주어졌을 때, f(xi, yi)값을 출력하는 프로그램을 작성하시오.각각의 쿼리마다 f(xi, yi)를 한 줄에 하나씩 순서대로 출력한다.",37.500%,14181,1,23.0,"볼록 껍질을 이용한 최적화,자료 구조,세그먼트 트리,","컨벡스헐트릭,컨벡스헐최적화,자료구조,자구,구간트리,세그트리,fenwick,펜윅,"
/problem/14205,함수,"이 문제에서 함수란 1부터 n까지의 정수와 1부터 n까지의 정수가 매핑되어 있는 함수를 의미한다. 예를 들어, n = 3인 경우에 가능한 함수 g의 한 예는 g(1) = 1, g(2) = 3, g(3) = 1이다.fj(x)란 다음과 같이 정의되어 있다.올바른 x에 대해서, f0(x) = x올바른 x와 j에 대해서, fj+1(x) = fj(f(x))다음과 같은 새로운 표현이 정의되어 있다.G(f, w)는 1보다 크거나 같고, n보다 작거나 같은 x에 대해서, fr(x)값의 집합을 의미한다. 이때, r은 w보다 크거나 같아야 한다.S(f, w)는 G(f, w)의 크기이다.Z(f)는 모든 음이아닌 정수 w에 대해서, S(f, w)값의 최솟값이다.A(y)는 Z(f) = y인 함수 f의 집합이다.n과 k가 주어졌을 때, A(k)의 크기를 1,000,000,007로 나눈 나머지를 구하는 프로그램을 작성하시오.첫째 줄에 A(k)의 크기를 1,000,000,007로 나눈 나머지를 출력한다.",58.333%,14205,1,21.0,"조합론,다이나믹 프로그래밍,수학,모듈로 곱셈 역원,정수론,","combination,permutation,probability,확률,순열,동적계획법,동적 계획법,다이나믹프로그래밍,modinv,"
/problem/14272,f(X) = A + X + B + X + C,"f(X) = A + X + B + X + C로 정의되어 있는 함수가 있다. 여기서 X는 문자열이고, +는 문자열 연결을 나타내는 연산이다. A, B, C는 비어있지 않은 상수 문자열이다.다섯 문자열 A, B, C, S, F와 정수 K가 주어진다.이때, fK(S)에 F가 부분 문자열로 총 몇 번 등장하는지 구하는 프로그램을 작성하시오.f1(X) = f(X)이고, fK(X) = f(fK-1(X))와 같다.첫째 줄에 fK(S)에 F가 부분 문자열로 등장하는 횟수의 1,000,000,007로 나눈 나머지를 출력한다. ",33.333%,14272,1,22.0,"KMP,문자열,","스트링,"
/problem/14392,문자열 테이블,"두 문자열 s와 t가 주어진다. s와 t의 모든 문자는 다르다. s에 등장하는 모든 문자는 t에 등장하지 않으며, t에 등장하는 모든 문자는 s에도 등장하지 않는다.s의 길이를 N, t의 길이를 M이라고 한다. 또, 다음과 같이 정의되는 2차원 배열 table이 있다.table[i][0] = s[i-1] (1 ≤ i ≤ N)table[0][j] = t[j-1] (1 ≤ j ≤ M)table[i][j] = min(table[i-1][j], table[i][j-1]) + max(table[i-1][j], table[i][j-1]) (1 ≤ i ≤ N, 1 ≤ j ≤ M)min은 두 문자열 중 사전 순으로 앞서는 것을 리턴하는 함수이며, max는 두 문자열 중 사전 순으로 뒤에 있는 것을 리턴하는 함수이다. 또, A+B는 문자열A의 뒤에 B를 연결하는 연산이다.table[N][M]의 부분 문자열을 구하는 프로그램을 작성하시오. 이때, 부분 문자열의 길이가 너무 길어질 수 있기 때문에, pos번째부터 min(50, L-pos)개의 문자를 출력한다. 여기서 L은 table[N][M]의 길이이다.첫째 줄에 table[N][M]의 pos번째부터 min(50, L-pos)개수 만큼 부분 문자열을 출력한다.",60.000%,14392,1,0.0,0,
/problem/14494,다이나믹이 뭐예요?,"안녕하세요~ 저는 오늘 다이나믹 프로그래밍(동적 계획법)을 설명하기 위해 등장한 욱제예요! 다이나믹은 이름이 엄청 거창하지만 사실 이름에 비해 개념은 간단하답니다. 다이나믹의 기본 아이디어는 바로 이전에 계산한 값을 사용해서 (= 이미 계산된 값을 사용해서, 어려운 말로 메모이제이션 한다고 해요) 반복되는 똑같은 연산 횟수를 줄이는 거예요.예를 들어서, 5번째 피보나치 수열을 구하는 F(5)의 동작 과정을 살펴볼게요.같은 함수가 불필요하게 많이 호출되는 것을 볼 수 있죠? F(2)와 F(3)을 미리 구해놓고 F(4)를 구할 땐 미리 구해둔 F(2)와 F(3)의 값을 이용하면 불필요한 호출을 줄일 수 있어요. 조금 엄밀하게 이야기 해볼게요. 수학적으로 피보나치 수열은 F(n) = F(n-1) + F(n-2)로 정의할 수 있죠? 이 식을 세우는 과정을 점화식을 세운다고 해요. 문제의 조건에 맞는 수식을 만들고 그 수식을 그대로 코드에 옮기면 아주 쉽게 다이나믹을 구현할 수 있어요.물론 다차원 배열로도 가능해요! 오른쪽, 아래쪽으로만 움직일 수 있을 때, D[1][1]에서 D[x][y]까지 도달하는 경우의 수를 구하는 문제는 일일히 모든 경우를 다 계산할 필요 없이, D[i][j] = (i, j)에 도달하는 누적 경우의 수 = D[i-1][j] + D[i][j-1]를 세워서 해결할 수도 있죠.어때요? 다이나믹 어렵지 않죠? 이제 문제를 풀어볼게요!“→, ↓, ↘의 세 방향만 사용해서 한 번에 한 칸씩 이동할 때, 왼쪽 위 (1, 1)에서 출발하여 오른쪽 아래 (n, m)에 도착하는 경우의 수를 구하여라.”시작!(1, 1)에서 (n, m)에 도달하는 경우의 수를 구하여라. 단, 경우의 수가 엄청 커질 수 있으므로 경우의 수를 1,000,000,007(=109+7)로 나눈 나머지를 출력한다.",70.526%,14494,1,8.0,"다이나믹 프로그래밍,","동적계획법,동적 계획법,다이나믹프로그래밍,"
/problem/14608,구분구적법 (Small),"어떤 함수의 적분값은 다음과 같이 근사가 가능하다.\[\int_a^b{f(x) dx} \approx  \sum_{k=0}^{n-1}{f(a + k \Delta x + \epsilon) \Delta x }\]\[\Delta x = \frac{b-a}{n} \]\[ 0 \le \epsilon \le \Delta x\](훈련소에서) 신나게 적분 계산을 하던 민규는 문득 ϵ을 잘 정해주면 이 근삿값이 실제 적분값과 일치하게 만들 수 있지 않을까 하는 생각이 들었다. 그런데 이를 확인하기 위해서는 소수점 계산이 필요하기 때문에 손으로 푸는 데는 한계가 있다는 것을 깨달았고, 여러분에게 이를 위한 프로그램을 만들어달라고 요청했다.구분구적법을 통해 계산한 근삿값이 적분값과 일치하게 만드는 ϵ을 한 줄에 출력한다.",64.885%,14608,1,6.0,"이분 탐색,미적분학,구현,수학,","이분탐색,이진탐색,미분,적분,"
/problem/14609,구분구적법 (Large),"어떤 함수의 적분값은 다음과 같이 근사가 가능하다.\[\int_a^b{f(x) dx} \approx  \sum_{k=0}^{n-1}{f(a + k \Delta x + \epsilon) \Delta x } \]\[ \Delta x = \frac{b-a}{n} \]\[ 0 \le \epsilon \le \Delta x\](훈련소에서) 신나게 적분 계산을 하던 민규는 문득 ϵ을 잘 정해주면 이 근삿값이 실제 적분값과 일치하게 만들 수 있지 않을까 하는 생각이 들었다. 그런데 이를 확인하기 위해서는 소수점 계산이 필요하기 때문에 손으로 푸는 데는 한계가 있다는 것을 깨달았고, 여러분에게 이를 위한 프로그램을 만들어달라고 요청했다.구분구적법을 통해 계산한 근삿값이 적분값과 일치하게 만드는 ϵ을 한 줄에 출력한다.",62.308%,14609,1,11.0,"이분 탐색,미적분학,수학,","이분탐색,이진탐색,미분,적분,"
/problem/14721,성적표,"동하는 이번 학기에도 F 학점을 받아 학사경고를 받았다. 더 이상 학사경고를 받지 않기 위해 동하는 공부를 하기로 결심했다.동하는 공부를 얼만큼 하면 얼만큼 성적이 나오는지 궁금했다. 그래서 동하는 N명의 학생들에 대해 공부시간과 그에 따른 시험점수를 조사했다.동하는 i번째 학생은 xi시간의 공부를 했고, yi점의 점수를 받았다는 사실을 알았다.이 데이터로부터 공부를 x시간 했으면 시험 성적은 f(x) = ax + b일 것이라고 추정하려 한다. 동하를 위해 a와 b를 구해주자.공부시간에 따른 시험성적을 예측하는 함수 f(x)는, 데이터 (xi, yi)에 대해, f(xi)와 yi의 차가 작아야 할 것이다. (I = 1, 2, 3, …, N)이 개념을 수학적으로 형식화한 것이 RSS(Residual Sum of Squares)이다. RSS가 작으면 예측모형이 데이터에 잘 맞는 것이라고 할 수 있다.\[\text{RSS} = \sum_{i=1}^{n}{(y_i - f(x_i))^2}\]100이하의 모든 양의 정수 a와 b중, RSS를 최소화하는 a와 b를 구하여라. 오버플로우에 주의하여라.RSS가 최소인 a와 b를 한 줄에 공백으로 구분하여 출력하여라.",36.130%,14721,1,6.0,"브루트포스 알고리즘,","완전탐색,완전 탐색,브루트포스,bruteforce,brute force,완탐,"
/problem/14730,謎紛芥索紀 (Small),"성민이는 이번 학기에 미적분학 과목을 수강하고 있다. 다항함수의 미분 단원 과제를 하던 도중 미분을 하기가 귀찮아진 성민이는 미분하려는 함수 f(x)가 주어지면, 미분 된 함수 f’(x)를 자동으로 구해주는 프로그램을 만들어서 계산을 줄일 생각을 하였다. 우리도 성민이가 원하는 프로그램을 한번 같이 만들어보도록 하자.f’(1)의 값을 첫째 줄에 출력한다.",85.321%,14730,1,6.0,"미적분학,수학,","미분,적분,"
/problem/14731,謎紛芥索紀 (Large),"성민이는 이번 학기에 미적분학 과목을 수강하고 있다. 다항함수의 미분 단원 과제를 하던 도중 미분을 하기가 귀찮아진 성민이는 미분하려는 함수 f(x)가 주어지면, 미분 된 함수 f’(x)를 자동으로 구해주는 프로그램을 만들어서 계산을 줄일 생각을 하였다. 우리도 성민이가 원하는 프로그램을 한번 같이 만들어보도록 하자.f’(2)의 값을 109+7로 나눈 나머지를 첫째 줄에 출력한다.",22.145%,14731,1,10.0,"미적분학,분할 정복을 이용한 거듭제곱,수학,","미분,적분,거듭제곱,제곱,power,square,"
/problem/14879,수열의 좋음,"N개의 정수로 이루어진 수열 A = A0, A1, ..., AN-1이 있다. 부분 수열, 증가 부분 수열, 연속 부분 수열에 대한 정의는 다음과 같다.부분 수열: 수열 A에서 0개 또는 그 이상의 수를 지워서 만들 수 있는 수열. 이때, 지워지지 않은 수의 순서를 바꾸면 안 된다. 부분 수열의 크기는 0일 수 있으며, 이때는 비어있는 부분 수열이라고 부른다.증가 부분 수열: 길이가 0보다 큰 부분 수열 중에서, 각각의 수가 앞에 있는 수보다 커야한다.연속 부분 수열: 부분 수열 중에서, 지워지지 않은 수가 원래 수열 A에서 연속되어 있는 경우를 의미한다. A의 l번째 수부터 r번째 수까지로 이루어진 연속 부분 수열은 A[l, r](= Al, Al+1, ..., Ar)로 표현한다. (l ≤ r) A = [2, 1, 3]인 경우에 부분 수열은 [], [2], [1], [3], [2, 1], [2, 3], [1, 3], [2, 1, 3], 연속 부분 수열은 [2], [1], [3], [2, 1], [1, 3], [2, 1, 3]이 있다. 증가 부분 수열은 [2], [1], [3], [2, 3], [1, 3]이 있다.수열에서 정의할 수 있는 함수는 총 3가지가 있으며, 다음과 같다.sum(l, r) = Al + Al+1 + ... + Arinc(l, r) = A[l, r]의 증가 부분 수열 중에서, 수열에 포함된 수의 합이 가장 큰 합f(l, r) = sum(l, r) - inc(l, r)수열의 좋음 g는 다음과 같이 정의할 수 있다.g = max(f(l, r)) (0 ≤ l ≤ r < n)즉, g는 A의 모든 연속 부분 수열의 f(l, r) 중에서 가장 큰 값이다.정수 m을 f(l, r) = g인 가장 작은 연속 부분 수열의 길이라고 하자.A가 주어졌을 때, 먼저 g값을 찾고, r - l + 1 = m이고, f(l, r) = g인 연속 부분 수열의 개수를 구하는 프로그램을 작성하시오.총 두 개의 정수를 공백으로 구분해 출력한다. 첫 번째 정수는 입력으로 주어진 수열의 g값이고, 두 번째 정수는 r - l + 1 = m이고, f(l, r) = g인 연속 부분 수열의 개수이다.",0.000%,14879,1,0.0,0,
/problem/14894,퀵 소트 cnt++,"구사과는 N개의 서로 다른 양의 정수를 정렬하기 위해 아래와 같은 C++ 코드를 작성했다.long long cnt = 0;vector<int> sort(vector<int> &a) {    vector<int> less, greater;    if (a.size() <= 1) return a;    int pivot = a[(a.size()-1)/2];    int n = a.size();    for (int i=0; i<n; i++) {        cnt += 1;        if (a[i] < pivot) {            less.push_back(a[i]);        } else if (a[i] > pivot) {            greater.push_back(a[i]);        }    }    sort(less); sort(greater);    vector<int> ans;    ans.insert(ans.end(), less.begin(), less.end());    ans.push_back(pivot);    ans.insert(ans.end(), greater.begin(), greater.end());    return ans;}서로 다른 자연수 N개로 이루어진 배열 A가 주어졌을 때, 이를 sort 함수를 이용해서 정렬했을 때, cnt에 들어있는 값을 구하는 프로그램을 작성하시오.입력으로 주어진 수를 sort 함수를 이용해 정렬했을 때, cnt에 들어있는 값을 출력한다.",56.250%,14894,1,21.0,"자료 구조,분할 정복,퍼시스턴트 세그먼트 트리,세그먼트 트리,","자료구조,자구,dnc,퍼시스턴트구간트리,구간트리,퍼시스턴트세그트리,구간트리,세그트리,fenwick,펜윅,"
/problem/14914,사과와 바나나 나눠주기,"아름이는 친구들과 사과와 바나나를 많이 가지고 있지만, 과일을 좋아하지 않아서 자신의 분량을 남겨두지 않고 친구들에게 모두 나누어 준다. 아름이는 항상 공평하게 사과와 바나나를 나누어 주며, 절대 잘라서 주지 않는다.예를 들어, 사과 8개와 바나나 4개를 가지고 있다면, 공평하게 나누어 주는 방법은 다음과 같이 3가지 경우 밖에 없다.한 친구가 사과 8개와 바나나 4개를 모두 받는다.두 친구가 각각 사과 4개와 바나나 2개씩을 받는다.네 친구가 각각 사과 2개와 바나나 1개씩을 받는다.아름이가 나누어 줄 수 있는 모든 경우를 출력하는 함수를 작성하시오.아름이가 나누어 줄 수 있는 경우를 모두 출력해야 하며, 각 경우마다 친구의 수, 사과 개수, 바나나 개수 차례로 한 줄에 각각 빈칸으로 구분하여 출력한다. 각 경우마다 중복없이 한 번만 출력되어야 하며, 경우의 순서는 친구의 수가 증가하는 순으로 한다.",75.825%,14914,1,4.0,"사칙연산,브루트포스 알고리즘,수학,","덧셈,뺄셈,곱셈,나눗셈,더하기,빼기,곱하기,나누기,완전탐색,완전 탐색,브루트포스,bruteforce,brute force,완탐,"
/problem/14935,FA,"함수 F(x)는 입력으로 주어진 수 x의 첫 자리와 수 x의 자리수를 곱한 결과를 반환하는 함수이다.예를 들어 x = 932 일때 F(x)는 9×3으로 27을 반환한다.입력받은 x에 대해서 함수 F를 수행하고, 나온 결과값에 다시 함수 F를 수행하는 것을 반복한다. 계속 반복해서 수행했을 때 어느 시점에서부터 동일한 수가 나오는 경우, 입력 x를 FA수 라고 한다.입력 x가 주어졌을때 이 수가 FA 수인지 출력하라.정수 x가 FA수 라면 FA를 출력하고, 아니라면 NFA를 출력한다.",83.388%,14935,1,2.0,"애드 혹,구현,수학,",
/problem/14941,호기심,"남규는 호기심이 많다. 호기심이 많은 남규는 a와 b 사이의 소수들의 합과 차를 이용한 특수한 함수 F를 만들었다. 남규는 이 특수한 함수의 결과값을 알고 싶다.함수 F(a,b)는 a와 b 사이의 소수를 순서대로 다음과 같은 규칙에 따라 계산하고, 그 값을 반환한다.3×A1 - A2 + 3×A3 - A4 + 3×A5 - A6 ..... An (a ≤ A1 < … < An ≤ b , Ai는 소수이다.)질문이 F(3, 7) 이라면 3과 7 사이에는 3, 5, 7 총 3개의 소수가 있고, 규칙에 따라 계산한 결과는3×3 - 5 + 3×7 = 25 이다.남규가 물어본 질문 a, b에 대한 답변 F(a, b)을 각 줄에 하나씩 순서대로 출력한다.",31.844%,14941,1,14.0,"이분 탐색,수학,정수론,누적 합,소수 판정,에라토스테네스의 체,","이분탐색,이진탐색,구간합,부분합,rangesum,소수,소수판별,소수판정,prime,sieve,에라체,소수,prime,"
/problem/15596,정수 N개의 합,"정수 n개가 주어졌을 때, n개의 합을 구하는 함수를 작성하시오.작성해야 하는 함수는 다음과 같다.C, C11, C (Clang), C11 (Clang): long long sum(int *a, int n);a: 합을 구해야 하는 정수 n개가 저장되어 있는 배열 (0 ≤ a[i] ≤ 1,000,000, 1 ≤ n ≤ 3,000,000)n: 합을 구해야 하는 정수의 개수리턴값: a에 포함되어 있는 정수 n개의 합C++, C++11, C++14, C++17, C++ (Clang), C++11 (Clang), C++14 (Clang), C++17 (Clang): long long sum(std::vector<int> &a);a: 합을 구해야 하는 정수 n개가 저장되어 있는 배열 (0 ≤ a[i] ≤ 1,000,000, 1 ≤ n ≤ 3,000,000)리턴값: a에 포함되어 있는 정수 n개의 합Python 2, Python 3, PyPy, PyPy3: def solve(a: list) -> inta: 합을 구해야 하는 정수 n개가 저장되어 있는 리스트 (0 ≤ a[i] ≤ 1,000,000, 1 ≤ n ≤ 3,000,000)리턴값: a에 포함되어 있는 정수 n개의 합 (정수)Java: long sum(int[] a); (클래스 이름: Test)	a: 합을 구해야 하는 정수 n개가 저장되어 있는 배열 (0 ≤ a[i] ≤ 1,000,000, 1 ≤ n ≤ 3,000,000)리턴값: a에 포함되어 있는 정수 n개의 합Go: sum(a []int) inta: 합을 구해야 하는 정수 n개가 저장되어 있는 배열 (0 ≤ a[i] ≤ 1,000,000, 1 ≤ n ≤ 3,000,000)리턴값: a에 포함되어 있는 정수 n개의 합",50.431%,15596,1,4.0,"사칙연산,구현,수학,","덧셈,뺄셈,곱셈,나눗셈,더하기,빼기,곱하기,나누기,"
/problem/15687,직사각형,"직사각형의 정보를 저장할 클래스 Rectangle을 구현하시오.C++14, C++17	클래스 이름: Rectangle생성자Rectangle(width, height): 직사각형의 가로 길이를 width, 세로 길이를 height 설정한다. width는 1,000보다 작거나 같은 자연수, height는 2,000보다 작거나 같은 자연수이다.멤버 변수		int width: 직사각형의 가로 길이int height: 직사각형의 세로 길이멤버 함수		int get_width() const: 직사각형의 가로 길이를 리턴한다.int get_height() const: 직사각형의 세로 길이를 리턴한다.void set_width(int width): 직사각형의 가로 길이를 width로 변경한다. 만약, width가 0보다 작거나 같거나, 1,000보다 크면 변경하지 않는다.void set_height(int height): 직사각형의 세로 길이를 height로 변경한다. 만약, height가 0보다 작거나 같거나, 2,000보다 크면 변경하지 않는다.int area() const: 직사각형의 넓이를 리턴한다.int perimeter() const: 직사각형의 둘레 길이를 리턴한다.bool is_square() const: 정사각형이면 true, 아니면 false를 리턴한다.",31.954%,15687,1,6.0,"기하학,구현,",
/problem/15725,다항함수의 미분,다항식(polynomial)은 문자의 거듭제곱의 상수 배들의 합을 표현하는 수식이다. 예를 들어 x2 - 2x + 3 같은 식을 의미한다. 그 중 변수가 하나인 것을 일변수 다항식이라고 하고 보통 다음과 같이 표현한다.f(x) = anxn + an-1xn-1 + ... + a2x2 + a1x + a0최대 일차 일변수 다항식이 주어졌을 때 그 함수를 미분한 결과를 출력하는 프로그램을 작성하시오.주어진 일변수 다항식을 미분한 결과를 출력한다.,32.384%,15725,1,7.0,"미적분학,많은 조건 분기,구현,수학,파싱,문자열,","미분,적분,케이스,케이스워크,케이스 워크,스트링,"
/problem/15825,System Call,"유닉스 계열의 운영체제에서는 파일을 읽기 위해 read()라는 시스템 함수(System Call)을 제공한다. 이 함수는 우리가 버퍼를 전달해주면 그 크기 만큼 파일을 읽어서 기록해준다. 만약 파일이 너무 크다면 read() 함수를 여러 번 호출해야 모두 읽을 수 있을 것이다.민규는 리눅스에서 여러 개의 파일을 읽는 프로그램을 구현하려고 한다. 우리가 아는 사실은 버퍼의 크기가 K바이트일때 read() 함수가 수행되는데 걸리는 시간은 (T + K)라는 것이다. 여기서 T는 함수를 한 번 호출하는데 고정적으로 걸리는 시간이다. 이때 주의해야 할 점은 read()함수의 수행 시간은 버퍼의 크기에 의해서만 결정된다는 것이다. 예를 들어 버퍼의 크기가 10바이트라면 3바이트를 읽건 7바이트를 읽건 상관없이 (T + 10)의 시간이 걸린다.위의 결과를 분석해보면 버퍼의 크기에 따라 전체 파일을 읽는데 걸리는 시간이 줄어들 수 있다는 것을 알 수 있다. 프로그래밍이 익숙치 않은 민규는 버퍼의 크기를 고정해놓고 코드를 짜기로 결정했는데, 버퍼의 크기를 얼마나 정해야 프로그램의 수행 시간을 최소화할 수 있을까?주어진 파일을 읽는데 걸리는 가장 짧은 시간과 이를 달성하기 위해 지정해줘야 하는 버퍼의 크기를 출력한다. 만약 해당 시간에 가능한 경우가 여러 가지라면 버퍼의 크기가 가장 작은 경우를 출력한다.",15.566%,15825,1,18.0,"수학,",
/problem/15829,Hashing,"APC에 온 것을 환영한다. 만약 여러분이 학교에서 자료구조를 수강했다면 해시 함수에 대해 배웠을 것이다. 해시 함수란 임의의 길이의 입력을 받아서 고정된 길이의 출력을 내보내는 함수로 정의한다. 해시 함수는 무궁무진한 응용 분야를 갖는데, 대표적으로 자료의 저장과 탐색에 쓰인다.이 문제에서는 여러분이 앞으로 유용하게 쓸 수 있는 해시 함수를 하나 가르쳐주고자 한다. 먼저, 편의상 입력으로 들어오는 문자열에는 영문 소문자(a, b, ..., z)로만 구성되어있다고 가정하자. 영어에는 총 26개의 알파벳이 존재하므로 a에는 1, b에는 2, c에는 3, ..., z에는 26으로 고유한 번호를 부여할 수 있다. 결과적으로 우리는 하나의 문자열을 수열로 변환할 수 있다. 예를 들어서 문자열 ""abba""은 수열 1, 2, 2, 1로 나타낼 수 있다.해시 값을 계산하기 위해서 우리는 문자열 혹은 수열을 하나의 정수로 치환하려고 한다. 간단하게는 수열의 값을 모두 더할 수도 있다. 해시 함수의 정의에서 유한한 범위의 출력을 가져야 한다고 했으니까 적당히 큰 수 M으로 나눠주자. 짜잔! 해시 함수가 완성되었다. 이를 수식으로 표현하면 아래와 같다.\[H = \sum_{i=0}^{l-1}{a_i} \mod M\]해시 함수의 입력으로 들어올 수 있는 문자열의 종류는 무한하지만 출력 범위는 정해져있다. 다들 비둘기 집의 원리에 대해서는 한 번쯤 들어봤을 것이다. 그 원리에 의하면 서로 다른 문자열이더라도 동일한 해시 값을 가질 수 있다. 이를 해시 충돌이라고 하는데, 좋은 해시 함수는 최대한 충돌이 적게 일어나야 한다. 위에서 정의한 해시 함수는 알파벳의 순서만 바꿔도 충돌이 일어나기 때문에 나쁜 해시 함수이다. 그러니까 조금 더 개선해보자.어떻게 하면 순서가 달라졌을때 출력값도 달라지게 할 수 있을까? 머리를 굴리면 수열의 각 항마다 고유한 계수를 부여하면 된다는 아이디어를 생각해볼 수 있다. 가장 대표적인 방법은 항의 번호에 해당하는 만큼 특정한 숫자를 거듭제곱해서 곱해준 다음 더하는 것이 있다. 이를 수식으로 표현하면 아래와 같다.\[H = \sum_{i=0}^{l-1}{a_ir^i} \mod M\]보통 r과 M은 서로소인 숫자로 정하는 것이 일반적이다. 우리가 직접 정하라고 하면 힘들테니까 r의 값은 26보다 큰 소수인 31로 하고 M의 값은 1234567891(놀랍게도 소수이다!!)로 하자.이제 여러분이 할 일은 위 식을 통해 주어진 문자열의 해시 값을 계산하는 것이다. 그리고 이 함수는 간단해 보여도 자주 쓰이니까 기억해뒀다가 잘 써먹도록 하자.문제에서 주어진 해시함수와 입력으로 주어진 문자열을 사용해 계산한 해시 값을 정수로 출력한다.",30.625%,15829,1,4.0,"해싱,구현,문자열,","스트링,"
/problem/15916,가희는 그래플러야!!,"그래프와 관련된 문제입니다.arr_y[0] = 0이라고 하고, arr_y[i] = yi라고 해 봅시다. (단 0<i<=n) 조가희는 아래와 같은 일을 수행해서, 구간 [0,n]에서 정의되는 함수 f(x)를 그렸습니다.for(int i=1;i<=n;i++)    (i-1,arr[i-1].y)와 (i,arr[i].y)를 잇는 선분을 그립니다.예를 들어, n=2이고, arr_y[3]={0,3,2}라고 해 봅시다. 이 경우 함수 f(x)는 위 그림과 같이 그려질 겁니다. 조가희는 구간 [0,n]에서 정의되는 함수 y=f(x)와 y=kx가 (0,0) 말고 또 다른 점에서 만나는지 궁금해졌습니다. 여러분이 궁금증을 해결해 주세요.(0,0) 말고 또 다른 점에서 만나면 T를, 그렇지 않다면 F를 출력하세요.",33.333%,15916,1,10.0,"기하학,수학,",
/problem/15942,Thinking Heap,"Binary heap은 Heap을 구현하는 방법의 하나이며 Complete binary tree 형태로 만들어진다. Complete binary tree는 Binary tree의 종류 중 하나로, 마지막 레벨을 제외한 나머지 레벨에는 노드가 꽉 차 있고 마지막 레벨에는 노드들이 왼쪽으로 쏠려있는 모습을 하고 있다.<그림> Complete binary tree의 예Complete binary tree는 1차원 배열을 이용하면 쉽게 구현할 수 있다. Complete binary tree의 각 노드에 아래 그림과 같은 식으로 번호를 붙이고 이를 1차원 배열에서의 index로 삼으면 자연스럽게 구현할 수 있다.<그림> Complete binary tree에 번호를 붙인 모습이를 이용하면 Binary min-heap에 원소를 삽입하는 알고리즘을 간단하게 구현할 수 있다. 아래 코드는 삽입 알고리즘을 C++로 구현한 코드이다(코드의 자잘한 문제들은 신경 쓰지 않기로 한다). 코드의 insert_heap() 함수를 호출하면 우리가 만든 Binary min-heap에 원소가 적절히 삽입된다.<그림> Binary min-heap에 원소를 삽입하는 알고리즘을 구현한 코드비어있는 Binary min-heap에 1 이상 N 이하의 서로 다른 자연수 N개를 insert_heap() 함수를 이용해 삽입할 것이다. N개의 자연수를 전부 다 삽입한 후에, 자연수 k가 heap 배열의 p번째(배열의 맨 처음 공간을 0번째로 생각한다)에 위치하도록 하고 싶다. 이렇게 만드는 삽입 순서를 찾는 프로그램을 작성하시오.자연수 k가 heap 배열의 p번째에 위치하도록 하는 삽입 순서가 존재한다면 i번째 줄에 i번째로 삽입할 수를 출력한다. 가능한 삽입 순서가 여러 가지라면 그중 아무거나 하나를 출력해도 된다. 만약 그렇게 만드는 삽입 순서가 존재하지 않는다면 첫 번째 줄에 -1을 출력한다.",34.865%,15942,1,14.0,"해 구성하기,그리디 알고리즘,","constructive,컨스트럭티브,구성적,탐욕법,"
/problem/16141,정수론과 응용: 레시테이션,"정수론과 응용 조교를 맡게 된 청응이는 바뻐 레시테이션 문제를 준비할 여를이 없었다. 수강생들이 이번 주 수업 때 오일러 피 함수(Euler's totient function, $\varphi$)를 배운 것을 알고 어떤 $n$을 주면 $\varphi(n)$을 구하라는 문제를 많이 내는 것으로 넘어가려고 했다.\begin{equation*}\varphi(n)=\left|\left\{k\in\mathbb{N}\::\:k\leq n,\:\gcd(k,n)=1\right\}\right|\end{equation*}그러나 이 문제는 소인수분해만 하면 구하는 공식이 너무 잘 알려져 있어 레시테이션 시간을 전부 넘기지 못한다는 것을 깨달았다. 그래서 오일러 피 함수를 일반화한 요르단 함수(Jordan's totient function)를 구하라는 문제를 준비했다.\begin{equation*}\varphi(n,v)=\left|\left\{(k_1,k_2,\cdots,k_v)\in\mathbb{N}^v\::\:\forall i,\:k_i\leq n,\:\gcd(k_1,k_2,\cdots,k_v,n)=1\right\}\right|\end{equation*}그러나 이 문제도 너무 쉽게 풀릴 것이라는 고민에 빠졌다. 그래서 더 어려운 문제를 생각하던 도중 가우스와 관련된 유명한 일화가 생각났다.""가우스가 어렸을 때, 가우스의 지도 교사였던 뷔트너 선생님이 $1$부터 $100$까지 수들의 합을 구하라고 했고, 가우스는 제일 빠르게 $5050$이라는 답을 냈다.""이에 영감을 받아 $\sum\limits_{i=1}^n\sum\limits_{u=1}^{v}\varphi(i,u)$를 구하라고 문제를 냈다. 이제 이 문제를 푸는 것은 여러분 몫이다. $n$과 $v$가 주어지면 $\sum\limits_{i=1}^n\sum\limits_{u=1}^{v}\varphi(i,u)$를 구하는 프로그램을 작성하시오.$\sum\limits_{i=1}^n\sum\limits_{u=1}^{v}\varphi(i,u)$를 출력한다. 답이 몹시 커질 수 있으니 $10^9+7$로 나눈 나머지를 출력하라.",25.000%,16141,1,24.0,"수학,뫼비우스 반전 공식,정수론,","mobius,"
/problem/16164,Möbius Madness,"Möbius 함수 $\mu(n)$은 정수론에서 다루는 중요한 multiplicative function 중 하나다.$\mu(n)$의 값은 양의 정수 $n$에 대하여 다음과 같이 정의된다. $n$이 제곱 인수가 없는 양의 정수고, $k$개의 소인수를 가진다면, $\mu(n)=(-1)^k$이다. 특히, $\mu(1)=1$이다.$n$이 제곱 인수가 없는 양의 정수가 아니라면, $\mu(n)=0$이다. 주어진 양의 정수 $N, L, K$에 대하여, 다음 값을 계산해보자. 값이 커지므로, $10^9+7$로 나눈 나머지를 출력한다. \begin{equation*}\displaystyle \sum_{d=1}^N \mu(L \cdot d) \left \lfloor \frac{N}{d} \right \rfloor^K\end{equation*}$\displaystyle \sum_{d=1}^N \mu(L \cdot d) \left \lfloor \frac{N}{d} \right \rfloor^K$의 값을 $10^9+7$로 나눈 나머지를 출력한다.",10.837%,16164,1,24.0,"수학,정수론,",
/problem/16455,K번째 수 찾는 함수,"크기가 N인 수열 A1, A2, ..., AN이 주어진다. A를 오름차순 정렬했을 때, 앞에서부터 K번째 있는 수를 리턴하는 함수를 작성하시오.작성해야 하는 함수는 다음과 같다. N은 n, A는 a, K는 k로 주어진다.C, C11, C (Clang), C11 (Clang): int kth(int *a, int n, int k);C++, C++11, C++14, C++17, C++ (Clang), C++11 (Clang), C++14 (Clang), C++17 (Clang): int kth(std::vector<int> &a, int k);Java, Java (OpenJDK): int kth(int[] a, int k); (클래스 이름: Test)PyPy2, PyPy3: def kth(a: list, k : int) -> intGo: kth(a []int, k int) int",21.230%,16455,1,12.0,"정렬,",
/problem/16488,피카츄가 낸 어려운 문제,"맨날 학교 칠판에 이등변삼각형을 그리고 노는 피카츄가 어느 날, 칠판에 변 AB와 변 AC의 길이가 모두 N인 이등변 삼각형을 그린 다음, 친구들에게 아래와 같은 문제를 냈다.이등변삼각형 ABC에서 변 BC 위에 점 P1, P2, ··· , PK을 잡는다. (B ≠ Pi ≠ C (i = 1, 2, ··· , K))i = 1, 2, ··· , K에 대하여 함수 F(i)를 (선분 APi의 길이)²+(선분 BPi의 길이)×(선분 CPi의 길이)로 정의한다.이때, F(1)+F(2)+···+F(K)의 값은 얼마인지 구하시오.피카츄의 친구들은 문제 조차도 이해를 못하고 있다! 우리가 대신해서 피카츄가 낸 문제를 해결해 보자.첫째 줄에 문제에서 요구하는 정답을 x라고 할 때, x보다 크지 않은 최대의 정수를 출력한다.",68.665%,16488,1,7.0,"기하학,수학,",
/problem/16646,Game with Polynomials,"이 문제에서편의상 $0^{0} := 1$로 둡니다.$p = 10^{9} + 7$로 고정합니다. 이 수는 소수입니다.모든 다항식 계산은 $\mathbb{Z}_{p}$에서 이루어집니다. 즉,	$(-2x)$는 $(p - 2)x$와 같은 다항식입니다.$(x + p - 1)$과 $(x + 2)$를 더하면 $(2x + 1)$입니다.키파는 이런 인터랙티브 문제를 내려고 했습니다.다음과 같은 함수를 호출할 수 있습니다:evaluate(x): x를 다항식 $Q(x)$에 대입한 후 $p$로 나눈 나머지를 돌려줍니다.evaluate 함수의 호출을 최대 $2N$번 할 수 있습니다. 당신의 프로그램은 입력으로 $N$을 받아 $Q(x)$의 계수를 출력해야 합니다.그런데, 테스트 케이스를 준비하면서 최대 $2N$개의 수에 대해 차수가 $N$인 다항식을 평가하는 것은 $\mathcal{O}(N^{2})$이라는 것을 깨달았습니다! 키파는evaluate의 각 call은 $\mathcal{O}(\log N)$만에 돌아옴이 보장되고, F 어쩌구 알고리즘을 사용하면 값을 알 때 다항식을 $N \log N$에 구할 수 있기 때문에, 전체 시간복잡도는 $\mathcal{O}(N \log N)$입니다!라고 에디토리얼에 쓰고 싶었기 때문에, 다음과 같이 다항식 $Q(x)$를 만들었습니다:차수가 $N$이고 최대 $\left\lceil\log_{2}(N+1)\right\rceil$개의 계수만이 0이 아닌 다항식 $P(x)$를 준비합니다.어떤 상수 $c$에 대해, $P(x + c) =: Q(x)$를 계산합니다.이렇게 만들 수 있는 다항식 $Q(x)$를 키파 다항식이라고 부릅시다.테스트 케이스가 너무 약하죠? 문제의 검수진인 실버는 검수비를 많이 받기 위해 키파 다항식 $Q(x)$의 계수가 주어졌을 때 $c$와 $P(x)$를 빠르게 구하는 코드를 짜서 키파의 뚝배기를 깨고 싶었습니다. 그러나 실버는 이 일을 하기에는 너무 귀찮았기 때문에, 여러분에게 이 일을 떠넘겼습니다. 이 일을 해결해 줄 수 있나요?첫째 줄에 $0$이 아닌 항의 개수 $k$와 $P(x + c) = Q(x)$를 만족하는 $c$를 출력합니다. $k$는 $\left\lceil\log_{2}(N+1)\right\rceil$보다 작거나 같은 양의 정수여야 하며, $c$는 $0$ 이상 $p$ 미만의 정수여야 합니다.",26.667%,16646,1,27.0,"수학,정수론,",
/problem/16902,mex,"mex는 어떤 수열에 포함되지 않은 수 중에서 가장 작은 음이 아닌 정수를 찾는 함수이다. 예를 들어, mex([1,2,3]) = 0, mex([5,0,1,1,4]) = 2, mex([0,5,2,1,5,0,1,2]) = 3이다.크기가 N이고 음이 아닌 정수로 이루어진 수열 A와 M개의 쿼리가 주어진다. 쿼리는 정수 x로 이루어져 있고, 다음을 순서대로 수행해야 한다.수열 A에 속한 각각의 원소를 x와 xor한다.mex(A)를 출력한다.A의 원소를 x와 xor할 때, A의 원소의 값이 실제로 바뀐다고 가정한다.각 쿼리를 순서대로 수행하고, mex(A)를 출력한다.",51.639%,16902,1,19.0,"자료 구조,세그먼트 트리,트리,트라이,","자료구조,자구,구간트리,세그트리,fenwick,펜윅,trees,"
/problem/16910,mex와 쿼리,"mex는 어떤 수열에 포함되지 않은 수 중에서 가장 작은 자연수를 찾는 함수이다. 예를 들어, mex([1,2,3]) = 4, mex([5,3,1,1,4]) = 2, mex([1,5,2,1,5,2,1,2]) = 3이다.비어있는 배열 A와 쿼리 N개가 주어졌을 때, 쿼리를 수행해보자. 쿼리는 총 3가지가 있으며, 아래와 같다.1 l r: 구간 [l, r]에 속하는 모든 자연수를 배열 A에 추가한다. 배열에 이미 있는 자연수는 또 추가하지 않는다.2 l r: 구간 [l, r]에 속하는 모든 자연수를 배열 A에서 제거한다.3 l r: 구간 [l, r]에 속하는 모든 자연수 x에 대해서, 다음을 수행한다.	x가 배열 A에 있으면, 배열에서 제거한다.x가 배열 A에 없으면, 배열에 추가한다.각 쿼리를 수행한 다음에 mex(A)를 구해보자.각각의 쿼리를 수행한 후에 mex(A)를 출력한다.",21.957%,16910,1,21.0,"값 / 좌표 압축,자료 구조,느리게 갱신되는 세그먼트 트리,세그먼트 트리,","zip,자료구조,자구,레이지,레이지프로퍼게이션,레이지프로파게이션,구간트리,fenwick,펜윅,구간트리,세그트리,fenwick,펜윅,"
/problem/16964,DFS 스페셜 저지,"BOJ에서 정답이 여러가지인 경우에는 스페셜 저지를 사용한다. 스페셜 저지는 유저가 출력한 답을 검증하는 코드를 통해서 정답 유무를 결정하는 방식이다. 오늘은 스페셜 저지 코드를 하나 만들어보려고 한다.정점의 개수가 N이고, 정점에 1부터 N까지 번호가 매겨져있는 양방향 그래프가 있을 때, DFS 알고리즘은 다음과 같은 형태로 이루어져 있다.void dfs(int x) {    if (check[x] == true) {        return;    }    check[x] = true;    // x를 방문    for (int y : x와 인접한 정점) {        if (check[y] == false) {            dfs(y);        }    }}이 문제에서 시작 정점은 1이기 때문에 가장 처음에 호출하는 함수는 dfs(1)이다. DFS 방문 순서는 dfs함수에서 // x를 방문 이라고 적힌 곳에 도착한 정점 번호를 순서대로 나열한 것이다.트리가 주어졌을 때, 올바른 DFS 방문 순서인지 구해보자.입력으로 주어진 DFS 방문 순서가 올바른 순서면 1, 아니면 0을 출력한다.",36.604%,16964,1,13.0,"자료 구조,깊이 우선 탐색,그래프 이론,그래프 탐색,정렬,","자료구조,자구,depth first,depthfirst,그래프이론,bfs,dfs,"
/problem/17072,아스키 아트,"위와 같이, 아스키 문자로 그린 그림을 ‘아스키 아트’ 라고 한다. 우리가 알고 있는 일반적인 그림 파일(.jpg, .png 등)들은 기본적으로 해상도에 맞게 픽셀 단위로 분할된 2차원 그리드에 대해 각 픽셀의 정보를 담는 방식으로 저장된다. 이 정보에는 여러 가지가 있으나, 그중 ‘R’, ‘G’, ‘B’ 값은 ‘Red’, ‘Green’, ‘Blue’의 3색이 각각 어느 정도 섞여 있는지를 나타내 주는 지표이며, 각 값은 0 이상 255 이하의 범위에 있는 정숫값을 가진다.아스키 아트는 격자 그리드에서 픽셀 하나 단위로 문자를 할당하여 그림을 그리는 방식이기 때문에, 우리가 알고 있는 모든 그림 파일은 아스키 아트로 다시 그릴 수가 있다. 그러나 여러 색을 가질 수 있는 그림 파일에 비해, 아스키 아트는 색상을 조절할 수 없고, 각 픽셀 내부의 채도만 조정할 수 있다. 원본 이미지가 흑백 이미지였다면 제법 비슷하게 바꿀 수 있으나, 여러 색으로 이루어졌다면 원본 이미지의 느낌을 살리기 힘들 것이다.하지만 이미지를 흑백 이미지로 바꾸는 필터를 통해 원본 이미지를 흑백 이미지로 바꾸고, 그 이후 아스키 아트로 변환할 수 있다면 퀄리티가 높아질 수 있다.아래는 이미지 하나가 아스키 아트로 변하는 예시를 보여준다.        어떤 그림 하나를 흑백 이미지로 바꾸기 위해 각 픽셀마다 R, G, B 3색이 어떤 비율로 혼합될지 결정하는 Intensity function을 사용한다. Intensity function은 0 이상 255 이하의 정수 R, G, B의 값을 받아 정수 하나를 리턴하는 함수로, 아래와 같이 정의한다.$$ I(R,G,B)=2126R+7152G+ 722B $$위의 함수의 결과값은 0 이상 2,550,000 이하의 값을 가지게 되며, 값이 높을수록 흰색에 가깝고, 값이 낮을수록 검은색에 가까운 픽셀이 된다.아스키 아트는 intensity function에 따라 정수 하나로 변환된 각 픽셀을 아래의 기준에 맞추어 변환하면 완성된다.Intensity변환 문자아스키 코드0 이상 ~ 510,000 미만#35510,000 이상 ~ 1,020,000 미만o (알파벳 소문자)1111,020,000 이상 ~ 1,530,000 미만+431,530,000 이상 ~ 2,040,000 미만-452,040,000 이상.46지금까지의 작업을 잘 따라왔다면, 훌륭한 ASCII Art Generator를 하나 만들 수 있을 것이다.원본 이미지 하나의 해상도와 각 픽셀별 R,G,B 값이 주어지면, 이미지의 아스키 아트를 출력하는 프로그램을 작성해 보자.N×M 격자 형태로, 입력된 그림을 아스키 아트로 변환하여 출력한다.",46,17072,1,5.0,"구현,",
/problem/17084,"f(k, n)","1 이상의 정수 n에 대하여 수열 fib(n)이 다음과 같이 정의되어있다.위 수열은 피보나치 수열로 너무 잘 알려져 있기 때문에 영훈이는 1 이상인 정수 n, k 에 대한 함수 f(k, n) 를 다음과 같이 정의했다.영훈이는 임의의 p×p 행렬 T가 주어졌을 때, 다음 조건을 만족시키는 순서쌍 (x, y)의 갯수가 궁금해졌다.ti-1, j-1  := 행렬 T의 i번째 행, j번째 열의 원소f(x+i, y+j) = ti, j      (for all  0 ≤  i, j  < p)1 ≤  x, y  ≤  n - p + 1택희 : ..이 문제는 너무 많은 수학 지식을 요구하니까 출제하지 말자.영훈 : 아냐, 잘 봐. 이게 무슨 뜻이냐면..택희 : ??영훈 : ??택희 : 괜찮은 문제였구나..문제의 정답을 출력한다.",18.310%,17084,1,17.0,"구현,수학,",
/problem/17110,Africa 2,"구데기컵 2018의 첫 번째 문제였던 Africa는 첫 문제답게 문제를 잘 읽기만 하면 정답을 받을 수 있는 쉬운 문제였다. 문제에 적힌 조건을 모두 파악한 브라이언은 바로 코드를 짰고, 예제 입력을 넣었을 때 예제 출력과 같은 결과가 나오는 것을 보고 바로 제출했으나, '틀렸습니다'를 받았다.자신의 코드가 틀릴 리 없다고 생각했던 브라이언은 채점 시스템에 문제가 있을 것이라 확신하고 같은 코드를 여러 번 제출했으나, 결과는 바뀌지 않았다. 결국 그는 '맞왜틀'을 외치며 출제자에게 항의를 했고, 출제자에게서 문제에는 오류가 없다는 (예상 가능한) 답변을 받았다. 친절한 출제자는 불필요한 정보를 추가로 알려줬는데, 전체 테스트 케이스 중 정확히 절반에 대해서만 정답을 출력하고 나머지 절반은 오답을 출력한다는 것이다. 그리고 여러 번 채점해도 각 테스트 케이스에 대한 결과는 바뀌지 않았다고 한다.이 이야기를 들은 당신은 과연 어떤 코드를 제출했길래 이런 아름다운 상황이 발생하게 되었는지 궁금해졌다. 그 코드를 재현할 수 있겠는가?당신의 프로그램은 다음을 모두 만족해야 한다.- 예제 입력을 넣을 경우 '맞았습니다!!'를 받을 수 있어야 한다.- 전체 채점 데이터 중 정확히 절반은 정답, 나머지 절반은 오답이어야 한다. 이때 오답은 출력 결과가 정답과 다름을 의미하며 시간 초과 등이 발생하면 안 된다.- 같은 입력에 대해서는 항상 같은 출력이 나와야 한다. 즉, 랜덤 함수 등을 사용하면 안 된다.- 채점 데이터는 Africa 채점에 사용되고 있거나 곧 사용될 것과 같다. 채점 데이터의 수는 짝수임이 보장된다.채점 결과는 다음과 같다.- 전체 데이터의 수를 2n이라고 할 때, 맞은 테스트 케이스의 수가 n±k인 경우 점수는 100-k점이 되며, 100점이면서 위에 언급한 조건을 모두 만족하면 정답이다.문제에 해당하는 답을 출력한다. 문제 해결에 필요한 모든 정보는 이 문제에서 제시되는 것을 기준으로 한다.",4.662%,17110,1,0.0,0,
/problem/17115,Kudeki Chain,"보통 백준 온라인 저지와 같은 사이트에서 문제를 풀며 코드를 작성할 때는 버전 관리 도구(Version Control System, VCS)를 필요로 하지 않는다. 하지만 소프트웨어를 개발하는 과정에서, 여러 명의 개발자와 협업하며 소스 코드를 관리하기 위해서는 VCS를 사용하는 것이 필수적이다.개발자들은 전세계의 개발자들과 협업하며 오픈소스 소프트웨어를 개발하기 위해 git과 같은 VCS를 사용하고 있다. git이 처음 출시된 것은 2005년의 일이지만, 2008년 GitHub과 같이 웹사이트에 git 저장소를 관리할 수 있게 된 뒤로, 리눅스, 비트코인과 같은 수많은 오픈소스 소프트웨어들이 GitHub을 통해 개발되고 있다.비트코인과 같은 블록체인 기술에 익숙한 사람이라면 hash가 무엇인지 알 것이다. hash는 임의의 길이의 문자열을 받아, 제한된 길이의 문자열을 만들어내는 함수다. 이 hash 함수가 가져야 할 중요한 조건 중 하나는, 문자열이 단 한 글자만 바뀌더라도 함숫값은 크게 변해야 한다는 것이다. 바로 이 점 덕분에, 이전에 있었던 거래의 기록을 조금이라도 변형하려는 시도가 불가능하여 블록체인 기술이 가능하게 된 것이다.블록체인 뿐만 아니라 git도 각 commit에 대해 hash를 매긴다. 각 commit에 대해 hash가 어떻게 계산되는지는 https://gist.github.com/masak/2415865 에 잘 설명되어있다.비트코인을 채굴하듯이, 우리도 간단히 git을 이용해 채굴(?)을 해보자. N번째 commit은 그의 hash가 반드시 N개의 0으로 시작해야 한다. git에서 사용되는 sha1 hash의 길이는 40자이므로, 이론적으로 최대 40명의 사람이 이 문제에 대해 ""맞았습니다!!""를 받을 수 있다.https://github.com/seungwonpark/kudeki-chain 을 fork해서, success.txt의 내용을 자신의 BOJ 아이디로 바꾸는 commit을 한 뒤, commit hash가 N개의 0로 시작하게 될 때까지 수많은 시도(git amend)를 하다가, 성공하면 pull request를 하여 본 저장소의 master 브랜치에 merge되면 된다.https://github.com/seungwonpark/kudeki-chain/blob/master/success.txt 에 자신의 BOJ 아이디가 나와있는 상태에서, 이 문제에 아무거나 출력하는 코드를 제출하면 된다.",86.667%,17115,1,0.0,"런타임 전의 전처리,브루트포스 알고리즘,","lookup table,db,database,완전탐색,완전 탐색,브루트포스,bruteforce,brute force,완탐,"
/problem/17126,연산,"값이 0으로 초기화되어 있고 인덱스는 0으로 시작하는 정수 배열 A에 대해 다음 세 함수가 주어진다.더하기 (key, value) : A[key]의 값을 value만큼 더한다. 리턴하는 값은 A[key]가 아니라, 배열 A 값 전체의 합이다.구간합 (key1, key2) : key1 ≤ i ≤ key2 인 모든 i에 대한 A[i]의 구간합을 리턴한다. (key1 ≤ key2)삭제 (key) : A[key]의 값을 0으로 만든다. 리턴하는 값은 역시 해당 연산 이후 배열 A 값 전체의 합이다.연산을 수행할 때마다, 리턴값을 출력하는 프로그램을 작성하시오.예를 들어 아래와 같은 12개의 연산을 순서대로 적용한다고 해보자. 화살표 이후에 나타나는 값이 바로 당신의 프로그램이 출력해야하는 값이다.더하기 (key=27, value=30) → 30더하기 (key=25, value= 40) → 70삭제 (key=17) → 70더하기 (key=17, value=20) → 90더하기 (key=5, value=50) → 140구간합 (key1=10, key2=20) → 20구간합 (key1=25, key2=30) → 70삭제 (key=25) → 100삭제 (key=17) → 80더하기 (key=27, value=20) → 100구간합 (key1=10, key2=20) → 0구간합 (key1=25, key2=30) → 50총 n개의 연산이 주어졌을 때, 각 연산을 적용한 이후 올바른 값을 출력하는 프로그램을 작성하시오.한 줄에 각 함수의 리턴값을 공백으로 구분해서 출력해야 한다.",56.522%,17126,1,17.0,"임의 정밀도 / 큰 수 연산,값 / 좌표 압축,자료 구조,세그먼트 트리,정렬,","빅인티저,빅데시멀,biginteger,bigdecimal,zip,자료구조,자구,구간트리,세그트리,fenwick,펜윅,"
/problem/17175,피보나치는 지겨웡~,"혁진이는 알고리즘 문제를 만들라는 독촉을 받아 스트레스다. 하지만 피보나치 문제는 너무 많이 봐서 지겹기 그지없다. 그러나 문제를 만들 시간이 없는 혁진이는 피보나치 문제를 응용해서 문제를 만들려 한다.int fibonacci(int n) { // 호출  if (n < 2) {    return n;  }    return fibonacci(n-2) + fibonacci(n-1);}위와 같이 코딩하였을 때 fibonacci(n)를 입력했을 때에 fibonacci 함수가 호출되는 횟수를 계산해보자.fibonacci 함수가 호출된 횟수를 출력한다.",42.473%,17175,1,8.0,"다이나믹 프로그래밍,","동적계획법,동적 계획법,다이나믹프로그래밍,"
/problem/17214,다항 함수의 적분,"다항식(polynomial)은 문자의 거듭제곱의 상수 배들의 합을 표현하는 수식이다. 예를 들어 x2+2x+3 같은 식을 의미한다. 그중 변수가 하나인 것을 일변수 다항식이라고 하고 이는 다음과 같이 표현한다.f(x) = axn + bxn-1+...+cx+d최대 일차 일변수 다항식이 주어졌을 때 그 함수를 적분한 결과를 출력하는 프로그램을 작성하시오.주어진 일변수 다항식을 적분한 결과를 입력 형식과 동일하게 출력한다. 적분상수는 ""W""로 x2은 ""xx""로 표현한다.",21.065%,17214,1,11.0,"미적분학,많은 조건 분기,수학,파싱,문자열,","미분,적분,케이스,케이스워크,케이스 워크,스트링,"
/problem/17257,불확정성이 넘쳐흘러,"욱제는 대회 참가자들을 괴롭히기 위해 길이 N의 특이한 수열을 만들었다! 신기하게도, 이 수열의 원소들은 우리가 들여다보기 전까지는 확률적으로 존재할 뿐이며 여러 자연수들이 중첩된 상태로 존재한다. 이 수열의 원소들을 확정하기 위해서는 관측이라는 특별한 과정이 필요하다. 자연수 Y ≥2 와 닫힌 구간 [ℓ, r] 에 대해, 관측 및 관측의 결과값이 다음과 같이 정의된다.수열의 ℓ번째 원소부터 r번째 원소를 각각 Aℓ, Aℓ+1, ..., Ar라는 확률변수로 놓자. 어떤 Ai 를 관측하는 순간, Ai 는 닫힌 구간 [1, Y]에 속한 임의의 자연수로 고정되어 Bi가 된다. (어떤 자연수가 고정될 확률은 모두 1/Y로 같다) 관측은 각 원소마다 독립적으로 시행하며, 이를 통해 Aℓ, Aℓ+1, ..., Ar에서 Bℓ,, Bℓ+1, ..., Br를 얻어낼 수 있다. 관측의 결과값이란 Bℓ, Bℓ+1, ... , Br의 최대공약수를 뜻한다. 관측된 원소들은 곧바로 원래 상태로 돌아가 다시 확률적으로만 존재하게 되며, 이후의 관측에 어떠한 영향도 주지 않는다.욱제는 이 수열을 이용해서 다음과 같은 특이한 함수를 정의했다.\[f_Y(i, j) = \begin{cases} 0 & \text{if $i > j$} \\ \text{[i, j]를 관측한 결과가 Y와 서로소일 확률 } & \text{otherwise} \end{cases}\]이때 다음을 만족하는 정수 Z를 구해보자.\[\sum\limits_{i=1}^{N}{\sum\limits_{j=1}^{N}{f_Y (i, j)}} = {Z\over Y^N}\]Z는 굉장히 커질 수 있으므로, 109 + 9로 나눈 나머지를 구해 출력한다.정수 Z를 109 + 9로 나눈 나머지를 출력한다.",39.175%,17257,1,19.0,"포함 배제의 원리,수학,정수론,",
/problem/17368,교점 세기,"자연상수 $e = 2.7182818284590452353602874\cdots$는 자연로그의 밑(base of the natural logarithm)으로, 아래와 같이 표현할 수 있음이 알려져 있다.$$e = \lim_{t \rightarrow \infty} \left(1+\frac{1}{t}\right)^t = \sum_{k=0}^{\infty} \frac{1}{k!}$$정의역이 집합 $X$이고 공역이 집합 $Y$인 함수 $f : X \rightarrow Y$의 그래프는 입력과 출력의 순서쌍으로 이루어진 집합, 즉$$\left\{ \left(x, f(x)\right) : x \in X\right\}$$로 정의된다. $X$와 $Y$가 모두 실수로 이루어진 집합이라면, 함수의 그래프에 속한 점들을 2차원 좌표평면 위에 나타낼 수 있다.이 문제에서 다룰 함수는 ""y=e?(ax)""과 같은 꼴이다. 여기서 ?는 곱셈 연산자 *, 나눗셈 연산자 /, 거듭제곱 연산자 ^ 중 하나이고, a는 정수이다. 단, 연산자가 /인 경우 a는 0이 아님이 보장된다.함수의 정의역은 ?가 * 또는 ^인 경우 전체 실수 집합($\mathbb{R}$)이고, /인 경우 0을 제외한 모든 실수($\mathbb{R} \setminus \{0\}$)이다. 함수의 공역은 실수 집합($\mathbb{R}$)이다. 모든 경우에 대해 함수의 정의역과 공역은 실수로 이루어진 집합이므로, 이 문제에서 다룰 모든 함수는 좌표평면 위에 그래프를 그릴 수 있다.아래 그림은 연산자 ?와 정수 a의 값에 따라 달라지는 함수의 그래프 몇 가지를 나타낸다.여러분은 위 그림과 같이 좌표평면 위에 주어진 함수들의 그래프를 모두 그렸을 때, 서로 다른 교점의 개수를 세는 프로그램을 작성해야 한다. 여기서 어떤 점이 교점이라는 것은 이 점이 주어진 함수 중 2개 이상의 그래프에 동시에 포함되어 있다는 것이다. 즉, 어떤 점이 3개 이상의 그래프에 동시에 포함되어 있더라도 한 번만 세어야 한다. 위 그림에서는 교점이 2개 있다.첫 번째 줄에 좌표평면 위에 주어진 모든 함수의 그래프를 그렸을 때 나타나는 교점의 수를 출력한다.",23.256%,17368,1,21.0,"많은 조건 분기,수학,","케이스,케이스워크,케이스 워크,"
/problem/17435,합성함수와 쿼리,"함수 f : {1, 2, ..., m}→{1, 2, ..., m}이 있다. 이때 fn : {1, 2, ..., m}→{1, 2, ..., m}을 다음과 같이 정의하자.f1(x) = f(x)fn+1(x) = f(fn(x))예를 들어 f4(1) = f(f(f(f(1))))이다.n과 x가 주어질 때 fn(x)를 계산하는 쿼리를 수행하는 프로그램을 작성하시오.주어지는 n, x마다 fn(x)를 출력한다.",52.248%,17435,1,15.0,"자료 구조,희소 배열,","자료구조,자구,스파스어레이,sparse table,"
/problem/17478,재귀함수가 뭔가요?,평소에 질문을 잘 받아주기로 유명한 중앙대학교의 JH 교수님은 학생들로부터 재귀함수가 무엇인지에 대하여 많은 질문을 받아왔다.매번 질문을 잘 받아주셨던 JH 교수님이지만 그는 중앙대학교가 자신과 맞는가에 대한 고민을 항상 해왔다.중앙대학교와 자신의 길이 맞지 않다고 생각한 JH 교수님은 결국 중앙대학교를 떠나기로 결정하였다.떠나기 전까지도 제자들을 생각하셨던 JH 교수님은 재귀함수가 무엇인지 물어보는 학생들을 위한 작은 선물로 자동 응답 챗봇을 준비하기로 했다.JH 교수님이 만들 챗봇의 응답을 출력하는 프로그램을 만들어보자.출력 예시를 보고 재귀 횟수에 따른 챗봇의 응답을 출력한다.,38.718%,17478,1,6.0,"구현,재귀,",
/problem/17623,괄호,"6개의 문자 ‘(’, ‘)’, ‘{’, ‘}’, ‘[’, ‘]’ 로 이루어진 올바른 괄호 문자열 W에 대하여 정수의 ‘괄호값’을 지정하는 함수 val(W)가 정의되어 있다. 먼저 올바른 괄호 문자열부터 정의해보자.한 쌍의 괄호로 구성된 길이 2인 문자열, 즉 ‘()’, ‘[]’, ‘{}’은 모두 올바른 괄호 문자열이다. 이것을 단위 괄호라고 한다. X, Y가 올바른 괄호 문자열인 경우, 아래와 같은 작업을 통하여 만들어지는 새로운 문자열은 모두 올바른 괄호 문자열이 된다.XY // 올바른 두 괄호 문자열의 접합(concatenation).(X), {X}, [X] // 올바른 괄호 문자열 전체를 다시 괄호로 감쌈.올바른 괄호 문자열과 아닌 예가 다음에 있다. 단 괄호 문자 사이에 공백은 없다.올바른 예: ({}{}[(())]), (()), {}[][(())]올바르지 못한 예: {[(())], (([)])), {{{}}(), )]{}이제 괄호값 val()의 계산 방법을 설명한다. 3 종류의 단위 괄호 (), {}, []의 괄호값은 각각 1, 2, 3으로 정의되어 있다. 즉 문자열이 X=‘()’, Y=‘{}’, Z=‘[]’이면 val(X) = 1, val(Y) = 2, val(Z) = 3이다. 만일 X, Y가 올바른 문자열이라고 할 때 이 둘을 순차적으로 연결한 문자열 Z=XY의 괄호값은 다음과 같이 계산된다.val(Z) = val(X) + val(Y)만일 어떤 올바른 문자열 X가 A=‘(X)’, B=‘{X}’, C=‘[X]’와 같이 (), {}, []로 둘러싸여 있을 경우에 A, B, C의 괄호값은 다음과 같이 계산된다.val(A) = 2·val(X), val(B) = 3·val(X), val(C) = 5·val(X)그런데 괄호값이 k인 문자열은 유일하지 않다. 예를 들어 ‘[]’, ‘{}()’, ‘()()()’ 모두는 괄호값이 3을 가지는 문자열이다. 다음 표는 올바른 괄호 문자열에 대응하는 괄호값 val(X)의 예를 보여준다.올바른 괄호 문자열 Xval(X)(()())2(1+1) = 4[[[]]]3×5×5 = 75[][][]{()}3+3+3+3(1) = 12((())[{}])()2(2+5×2)+1 = 25올바른 괄호 문자열 X를 숫자로도 표현할 수 있다. 괄호 문자열을 숫자로 바꾸는 방법은 각 괄호 문자에 대하여 아래 표와 같이 1에서 6까지의 숫자로 대치해 십진수로 읽은 값이다.문자(){}[]대치문자123456괄호 문자열 X를 위에 설명한 방식으로 변환시킨 값을 dmap(X)로 표시한다. 몇몇 올바른 괄호 문자열 X에 대해서 dmap(X)을 나타낸 표가 아래에 있다.val(R)=3 문자열dmap(R)()()()121212{}()3412(){}1234[]56val(R)=4 문자열dmap(R)({})1342()()()()12121212()[]1256{}{}3434여러분은 주어진 정수 N에 대하여 val(X) = N을 만족하는 올바른 괄호 문자열 중에서 dmap(X) 값이 최소인 X를 찾아서 출력해야 한다. 출력 문자열은 공백 없이 괄호 문자로만 구성되어야 한다.각 테스트케이스마다 val(X) = N을 만족하는 올바른 괄호 문자열 X 중에서 dmap(X)가 최소인 문자열을 찾아서 한 줄에 하나씩 공백 없이 출력한다.",3434,17623,1,14.0,"다이나믹 프로그래밍,","동적계획법,동적 계획법,다이나믹프로그래밍,"
/problem/18158,What an Easy Problem,"이제부터 여러분은 교준이와 간단한 가위바위보 게임을 하게 된다. 교준이는 가위바위보를 하기 전에 다음과 같은 심리전을 펼친다.가위바위보 전에 ""교준이는 '가위'를 낼거야!"" 라고 말한 경우 실제로 교준이는 '주먹'을 낸다.가위바위보 전에 ""교준이는 '보'를 낼거야!"" 라고 말한 경우 실제로 교준이는 '보'를 낸다.가위바위보 전에 ""교준이는 '주먹'을 낼거야!"" 라고 말한 경우 실제로 교준이는 '가위'를 낸다.이제부터 교준이와 총 T번의 가위바위보를 하게 된다. 다만 여러분은 T번의 가위바위보를 모두 교준이에게 져야 한다.교준이와 가위바위보를 하는 프로그램을 작성하시오.Sample Grader는 다음과 같은 정보를 Standard Output을 통하여 출력한다. 여러분은 어떠한 출력도 하면 안된다. 첫 번째 줄부터 T개의 줄에 걸쳐, 함수 janken이 반환한 값을 출력한다.", ,18158,1,4.0,"구현,",
/problem/18167,Functional Analysis,"오늘도 프로그램을 분석하는 키파는, PS-Lang에 메모이제이션 기능을 지원하기 위해 프로그램을 분석한 뒤 다음과 같은 구조를 만들었습니다. (newline은 강제 개행 문자(line feed)을 의미합니다.)α-list = ε | α α-listα-space = α space-listprogram = func-space-listcommand = func | define | refer | blockfunc = ""FUNCTION"" space-list name space-list blockdefine = ""DEFINE"" space-list namerefer = ""REFER"" space-list nameblock = ""{"" space-list command-space-list space-list ""}""name = alphabet alphabet-listalphabet = ""a"" | ""b"" | ""c"" | ... | ""z""space = "" "" | newline모든 define 및 func의 변수 v에 대해 v의 scope S(v)는 프로그램의 parse tree 상에서 v의 조상 중 가장 아래에 있는 block을 의미합니다. function은 scope 전에 오는 이름이 define된 것과 같은 효과를 가집니다(따라서 재귀 호출을 할 수 있습니다). C/C++에서와 마찬가지로, 다음과 같은 두 가지 프로그램은 허용하지 않습니다:재정의 오류. define 혹은 func의 변수 v에 대해 v의 이름을 N(v)라 하면, define 혹은 func의 변수 v, w에 대해 N(v) = N(w)이면서 S(v) = S(w)인 경우입니다.자유로운 변수 오류. refer의 변수 v에 대해 parse tree를 전위 순회할 때 define(N(v))가 현재 노드보다 앞에 한 번도 나타나지 않는 경우입니다.어떤 함수에 메모이제이션을 적용할지 알기 위해서 키파는 그냥 다음과 같이 생각하기로 했습니다: 함수가 함수 밖에 있는 (자기 자신이 아닌) 변수를 참조하지 않으면 순수 함수로 정의합니다. 순수 함수이면 함수의 인자에만 결괏값이 영향을 받기 때문에, 호출 시 메모이제이션을 적용할 수 있습니다.키파를 위해 프로그램이 주어지면 함수들이 순수 함수인지를 판단하는 프로그램을 만들어 줍시다.프로그램을 분석한 결과를 다음과 같이 출력합니다.",17.391%,18167,1,23.0,"파싱,문자열,","스트링,"
/problem/18168,Game with Polynomials 2,"이 문제에서편의상 00: = 1로 둡니다.p = 998244353로 고정합니다. 이 수는 소수입니다.키파는 이런 인터랙티브 문제를 내려고 했습니다.다음과 같은 함수를 호출할 수 있습니다:evaluate(x): x를 다항식 Q(x)에 대입한 후 p로 나눈 나머지를 돌려줍니다.evaluate 함수의 호출을 최대 q번 할 수 있습니다. 당신의 프로그램은 입력으로 n을 받아 Q(x)의 계수를 p로 나눈 나머지를 출력해야 합니다.그런데, 테스트 케이스를 준비하면서 최대 q개의 수에 대해 차수가 n인 다항식을 평범하게 평가하는 것은 O(qn)이라는 것을 깨달았습니다! 작년처럼 편법을 쓰지 않으려고, 키파는 유능한 PSer인 캬륜하에게 어떻게든 이 문제의 빠른 인터랙터를 짜 달라고 부탁했습니다.곤경에 처한 캬륜하는 여러분에게 도움을 청했습니다. 캬륜하 대신 인터랙터를 짜 줍시다!총 q개의 줄에 정수 하나씩을 출력합니다. i번째 줄에 출력하는 정수는",k=0,18168,1,25.0,"분할 정복,고속 푸리에 변환,수학,다중 대입값 계산,","dnc,푸리에변환,컨볼루션,convolution,"
/problem/18374,함수의 맛,"인덱스 트리 상인 탐레프는 인덱스국의 멸망 이후로 아무도 인덱스 트리를 사주지 않자, 인기 간식인 함수 f : {1, ..., N} → {1, ..., N}을 만들어 파는 중이다.레프가 파는 함수에서 자연수 1, ..., N의 맛은 각각 A1, ...,AN으로 알려져 있는데, 이 값은 재료의 품질에 따라서 매일 바뀐다. 함수를 먹을 때는 마음에 드는 자연수 x를 정해서 x, f(x), f(f(x)), ...를 차례로 먹으면 되는데, 같은 수를 여러 번 먹지는 않는다. 즉, i = 1, ..., N에 대해 i = fk(x)인 k ≥ 0이 존재한다면 자연수 i를 먹는다. 이렇게 먹었을 때 느끼는 함수의 맛은 먹은 모든 자연수의 맛을 합한 값이다.레프는 숙련된 주방장이 아니기 때문에, 종종 f의 구조를 바꿔버리기도 한다. 대신 레프는 손님의 ""x부터 먹기 시작하면 이 함수의 맛은 얼마인가요?""라는 질문에 빠르게 답할 수 있는 기계를 만들기로 했다.3번 쿼리에 대한 답을 순서대로 한 줄에 하나씩 출력한다.",24.419%,18374,1,26.0,"링크/컷 트리,트리,","link cut tree,linkcuttree,링크컷,trees,"
/problem/19299,New Occurrences,"두 문자열 $S$와 $P$에 대해, $S$에서 $P$가 등장하는 횟수를 나타내는 함수 $f(S, P)$가 있다. 즉 $f(S, P)$는 $P$가 $S$에서 연속한 부분 문자열로 등장하는 횟수를 나타낸다. 예를 들어 $f($""ababa""$,$""aba""$) = 2$이고, $f($""aaaaa""$,$""aa""$) = 4$이다.여기에 더해서, 어떤 문자열 $S$에 대해서 가능한 모든 문자열의 등장횟수 제곱의 합을 나타내는 함수 $g(S)$가 있다. 즉, $g(S)$는 가능한 모든 문자열 $P$에 대해서 $[f(S,P)]^2$의 합을 구한 값이다.$N$개의 문자로 이루어진 문자열 $S = c_1c_2 \cdots c_N$이 주어진다. $R_i = g(c_1c_2 \cdots c_i)$ ($S$의 처음 $i$자리에 대한 등장횟수 제곱의 합)이라고 하면, $R$값의 변화치를 통해 문자열의 뒤쪽에 한 글자가 추가될 때 마다 새롭게 찾을 수 있는 부분문자열이 얼마나 많아지는지 짐작해볼 수 있다. 이를 위해 $R_1$에서 $R_N$까지를 모두 구하는 프로그램을 작성하라.$N$개의 줄에 걸쳐 정답을 출력한다. $i$번째 줄에는 $R_i$만이 출력되어야 한다.",75.000%,19299,1,24.0,"자료 구조,분할 정복,세그먼트 트리,문자열,접미사 배열과 LCP 배열,","자료구조,자구,dnc,구간트리,세그트리,fenwick,펜윅,스트링,"
/problem/19544,함수 복원,"자연수 $N$이 주어질 때, $1$ 이상 $N$ 이하의 자연수 $i$에 대해 정의되는 함수 $f$가 있다. 모든 $i$에 대해 $f\left(i\right)$ 또한 $1$ 이상 $N$ 이하의 자연수다.$f$에 대한 함수 그래프를 정점 $i$에서 정점 $f\left(i\right)$로 향하는 단방향 간선들로 이루어진 그래프라 부르자. 이 그래프는 $f$에 따라 유일하게 결정됨을 알 수 있다.우리는 함수 $f$를 알지 못하지만, $f$에 대한 함수 그래프에서 모든 정점에 대한 도달 가능성 정보를 가지고 있다. 정점 $u$에서 정점 $v$에 도달 가능하다는 것은 $0$개 이상의 간선을 통해 정점 $u$에서 정점 $v$로 갈 수 있다는 뜻이다.함수 $f$로 가능한 경우의 수를 구하여라.함수 $f$로 가능한 경우의 수를 $10^9 + 7$로 나눈 나머지를 출력한다. ",48.295%,19544,1,16.0,"조합론,그래프 이론,수학,","combination,permutation,probability,확률,순열,그래프이론,"
/problem/19562,Matrix and Queries,"행렬식은 선형대수학에서 다루는 중요한 대상 중 하나이다.자연수 $n$에 대하여, $S_n$은 $\{1, 2, \cdots n\}$에서 $\{1, 2, \cdots n\}$으로 가는 모든 전단사함수의 집합이다. $\sigma \in S_n$에 대하여, $\text{inv}(\sigma)$는 $1 \le i < j \le n$과 $\sigma(i) > \sigma(j)$를 모두 만족하는 $(i, j)$의 개수이다.이때, $n \times n$ 행렬 $A$의 각 원소를 $a_{i, j}$라 하면, $A$의 행렬식은 $\text{det}(A) = \sum_{\sigma \in S_n} (-1)^{\text{inv} (\sigma) } \prod_{i=1}^n a_{i, \sigma(i)}$이다.각 원소가 정수인 $N \times N$ 행렬 $A$가 있을 때, 다음 쿼리를 $Q$개 처리해보자.정수 $x$가 입력되면, $A - xI$의 행렬식의 값을 출력한다. 단, $I$는 $N \times N$ 단위행렬이다.값이 지나치게 커질 수 있으므로, $998244353$으로 나눈 나머지를 출력하도록 한다.각 쿼리의 답을 순서대로 사이에 공백을 두고 한 줄에 출력한다.",23.684%,19562,1,25.0,"가우스 소거법,선형대수학,수학,","선형대수,"
/problem/19577,수학은 재밌어,"오일러는 수학을 정말 좋아해서 하루 종일 수학 공부만 하는 수학쟁이이다.어느 날 오일러는 수학 공부를 하기 위해서 수학 책을 읽고 있던 중에 오일러 피 함수에 대해서 설명하는 부분을 보게 되었다. 오일러 피 함수는 다음과 같이 설명이 되어 있었다.오일러 피 함수란 φ(n)으로 표기하며 1부터 n까지의 양의 정수 중에서 n과 서로소인 수의 개수를 나타내는 함수이다.예를 들면 φ(6)은 1부터 6까지의 수 중 6과 서로소인 수의 개수를 말하는데 이는 1과 5로 두 개가 있으므로 φ(6) = 2이다.오일러는 책의 내용을 곰곰이 읽던 중 어떤 문제가 떠올랐다. 문제의 내용은 다음과 같다.어떤 양의 정수 n이 있다고 할 때, xφ(x) = n을 만족하는 양의 정수 x가 존재하는가?고민에 빠진 오일러를 본 당신은 오일러의 궁금증을 해결해주기 위해서 직접 문제를 풀기로 결심했다. 그러므로 당신은 xφ(x) = n을 만족하는 x를 구하는 프로그램을 작성하면 된다.xφ(x) = n을 만족하는 양의 정수 x가 존재하면 최소의 x를, 존재하지 않으면 −1을 출력한다.",33.700%,19577,1,16.0,"오일러 피 함수,수학,정수론,","오일러 파이,토션트,eulerphi,euler phi,"
/problem/19597,문자열 뒤집기,"영어 알파벳 대문자로만 구성된 문자열이 N개 있다 (S[1], S[2], ..., S[N] 이라 칭하자).Reverse(T)는 임의의 문자열 T를 뒤집은 문자열 이라 하자 (명백히, 모든 문자열 T에 대해 Reverse(Reverse(T)) = T 이다). 가령 Reverse(""ABC"") = ""CBA"" 이다.당신은 N개의 문자열 각각에 Reverse() 함수를 적용할지 말지 고를 수 있고, 이를 통해 문자열이 사전순으로 정렬되도록 하고 싶다 (문자열이 N개 이므로 2N 가지의 방법이 존재한다).각 문자열에 Reverse() 함수를 적용한 경우를 '1' 적용하지 않은 경우를 '0'으로 나타내면, 길이가 N인 0-1문자열이 된다 - 이를 ""리버스 문자열"" 이라 하자. (리버스 문자열은 길이가 N인 0-1 문자열이다).예를 들어 N = 3이고 S[1] = ""ABC"", S[2] = ""XC"", S[3] = ""DZ"" 라 하자.리버스 문자열이 ""000""인 경우: 세 문자열은 원래 문자열인 ""ABC"", ""XC"", ""DZ"" 가 되고 사전순으로 정렬되지 않은 상태이다 (S[3]이 S[2]보다 앞선다).리버스 문자열이 ""001""인 경우: 3번 문자열에만 Reverse() 함수를 적용하면 세 문자열은 ""ABC"", ""XC"", ""ZD"" 가 되어 사전순으로 정렬된다.리버스 문자열이 ""010""인 경우: 2번 문자열에만 Reverse() 함수를 적용하면 세 문자열은 ""ABC"", ""CX"", ""DZ""가 되어 사전순으로 정렬된다.리버스 문자열이 ""101""인 경우: 1번과 3번 문자열에 Reverse() 함수를 적용하면 ""CBA"", ""XC"", ""ZD""가 되어 사전순으로 정렬된다.이 외에도 다른 방법으로 세 문자열을 사전순으로 정렬할 수 있다.입력으로 주어진 N개의 문자열을 사전순으로 정렬하는 리버스 문자열이 항상 존재한다는 가정하에, 그러한 리버스 문자열 중 사전순으로 가장 앞서는 리버스 문자열을 출력하시오.각 테스트 케이스에 대해 조건을 만족하는 리버스 문자열 중 사전순으로 가장 앞서는 리버스 문자열을 출력한다.",32.967%,19597,1,11.0,"백트래킹,그리디 알고리즘,문자열,","백트래킹,퇴각검색,퇴각 검색,탐욕법,스트링,"
/problem/20054,트리 가짓수 세기,"이진 검색 트리(BST, Binary Search Tree)는 모든 노드가 최대 $2$개의 자식 노드를 가지고 있는 트리이다. 만약 어떤 노드에 쓰여 있는 수가 $X$라면, 그 노드의 왼쪽 서브트리에는 $X$보다 작은 수, 오른쪽 서브트리에는 $X$보다 큰 수만 저장되어 있어야 한다.다음은 BST의 삽입하는 함수를 수도-코드(pseudo code)로 작성한 것이다.insert(number X, node N)    if X가 노드 N에 있는 수보다 작다면        if N의 왼쪽 자식이 없다면            X를 포함하는 새 노드를 만든 뒤, N의 왼쪽 자식으로 만든다        else            insert(X, N의 왼쪽 자식)    else (X가 노드 N에 있는 수보다 크다면)        if N의 오른쪽 자식이 없다면            X를 포함하는 새 노드를 만든 뒤, N의 오른쪽 자식으로 만든다        else            insert(X, N의 오른쪽 자식)첫 번째로 삽입하는 수를 루트로 놓고, 그 뒤로 삽입하는 모든 수 X에 대해서 insert(X, root)를 호출하게 된다.트리의 높이는 루트 노드로부터 리프 노드까지의 경로 중 가장 긴 경로 위에 존재하는 노드의 개수를 뜻한다. (리프 노드는 자식 노드가 없는 것을 의미한다.)$1$부터 $N$까지의 수를 BST에 삽입하려고 한다. 삽입 순서를 자유롭게 정할 수 있을 때 만들어지는 높이가 $K$ 이하인 BST의 가짓수를 구해보자. (BST의 루트 노드는 높이가 1로 가정한다.)$2$ $1$ $3$ 순으로 넣었을 때 생성되는 BST와 $2$ $3$ $1$ 순으로 넣었을 때 생성되는 BST는 같은 경우이고, $3$ $2$ $1$ $4$와 $2$ $1$ $3$ $4$ 순으로 넣었을 때 생성되는 BST는 서로 다른 경우이다.구하려는 경우의 수는 매우 커질 수 있으므로 답을 $10^9+7$로 나눈 나머지를 출력한다.만들어지는 BST의 경우의 수를 $10^9+7$로 나눈 나머지를 출력한다.",42.241%,20054,1,16.0,"다이나믹 프로그래밍,수학,","동적계획법,동적 계획법,다이나믹프로그래밍,"
/problem/20504,I번은 쉬운 문제,"2030년, Farmer John은 선린 인터넷 컴퍼니에서 소프트웨어 개발자이자 검색 팀장으로 근무하고 있다. John의 강한 의지에 따라 검색 팀에서는 모든 소프트웨어의 개발을 테스트 주도 개발(test-driven development) 형태로 수행하고 있다.검색팀에서는 효율적인 검색을 위해 새로운 프로그램을 만들고 있고, 이 프로그램은 여러 함수로 구성되어 있다. 하나의 함수는 실행되는 동안 0개 이상의 다른 함수를 호출하게 된다.예를 들어, 프로그램이 다음과 같이 3개의 함수 f, g, h로 이루어져 있다면, f를 호출했을 때는 호출될 가능성이 있는 추가적인 함수가 없고, g를 호출했을 때는 f가 호출될 가능성이 존재하며, h를 실행했을 때는 f, g, h가 호출될 가능성이 존재한다.function<void> f(x: int) {    // do something (다른 함수를 호출하지는 않는다.)}function<void> g(x: int) {    // do something (다른 함수를 호출하지는 않는다.)    if (condition1) f(x);}function<int> h(x: int) {    if (condition2) f(x);    else g(x);    if (condition3) h(x-1);    return x;}이 프로그램의 테스트를 위해 여러 테스트 케이스가 만들어져 있고, 하나의 테스트 케이스는 어떤 함수 하나를 호출하는 방식으로 구성되어 있다. 하지만, 모든 테스트 케이스를 실행하기에는 테스트 케이스의 수가 많아 비효율적이다. 따라서, John은 테스트 케이스 중 일부만을 선택해 실행해보되, 선택한 테스트 케이스를 실행하는 과정에서 모든 함수가 호출될 가능성이 존재하도록 하고자 한다.각 함수마다 실행 과정에서 호출할 가능성이 있는 함수들의 목록이 주어질 때, John이 선택해야 하는 테스트 케이스의 최소 개수를 구하여라.John이 선택해야 하는 테스트 케이스의 최소 개수를 출력한다.",44.907%,20504,1,17.0,"그래프 이론,강한 연결 요소,","그래프이론,"
/problem/20953,고고학자 예린,"예린은 고고학자이다. 예린은 강원대학교 백록관 지하에서 고인돌이 발견되었다는 소식을 듣고 누구보다 빠르게 백록관에 도착하였다. 고인돌을 본 순간 예린은 놀라 자빠질 수밖에 없었다. 고인돌에 의미를 알 수 없는 문자들이 가득 새겨져 있었기 때문이다. 예린은 이 문자들을 누구보다 빠르게 그리고 남들과는 다르게 해석하기로 결심하였다.열심히 연구한 결과 예린은 이 문자들이 어셈블리 언어의 함수 코드를 의미함을 발견하였다. 아래 코드는 고인돌의 어셈블리 언어 코드와 동일한 기능을 하는 C 코드이다.int dolmen(int a, int b) {    int sum, i, j, k;    sum = 0;    for (i = 0; i < a + b; i++) {        for (j = 0; j < a + b; j++) {            for (k = 0; k < j; k++) {                sum++;            }        }    }    return sum;}정수 a와 b가 주어졌을 때, 함수 dolmen(a, b)의 실행 결과를 구하는 프로그램을 작성하시오.각 테스트 케이스에 대한 답을 한 줄에 하나씩 출력한다.",37.228%,20953,1,4.0,"수학,",
/problem/20954,택배 기사 민서,"민서는 택배 기사이다. 활기차게 월요일을 맞은 민서는 놀라 자빠질 수밖에 없었다. 코로나19 사태로 인하여 비대면 활동이 확산되면서 택배 물량이 급증하였기 때문이다. 민서에게 배정된 택배는 거의 무한개에 가까웠고 이대로라면 과로사를 피할 수 없을 것이다. 민서는 건강을 위하여 오늘까지만 열심히 일하고 내일부터는 택배 기사 대신 교수를 하기로 결심하였다.민서가 사는 동네는 수직선으로 표현할 수 있으며, 민서는 수직선의 원점, 즉 수직선의 좌표 0에서 배달을 준비하고 있다. 각 택배에는 0번부터 차례대로 번호가 매겨져 있으며, 택배의 목적지는 수직선 위의 좌표로 표현할 수 있다. i번 택배의 목적지 Di는 다음과 같다.$$D_i=(-1)^i×2^{\left\lfloor\frac{i}{2}\right\rfloor}$$여기서 ⌊x⌋는 바닥 함수로, x보다 크지 않은, 즉 x 이하의 정수 중 가장 큰 정수를 의미한다. 예를 들어, 3번 택배의 목적지 D3은 다음과 같이 계산할 수 있다.$$D_3=(-1)^3×2^{\left\lfloor\frac{3}{2}\right\rfloor}=-2$$민서는 수직선의 원점에서 출발하여 0번 택배부터 차례대로 배달을 시작한다. 택배를 배달하기 위해서는 현재 위치로부터 택배의 목적지까지 이동해야 한다. 민서는 현재 좌표에서 인접한 좌표로, 즉 현재 좌표에서 1만큼 차이 나는 좌표로 이동할 수 있으며, 이때 1초의 시간이 소요된다. 또한 민서는 항상 최단 경로로 이동한다.민서는 온종일 쉬지도 않고 열심히 택배를 배달하고 있다. 문득 민서는 수직선 위의 특정 좌표 x에 처음으로 도달하는 시점이 언제인지 궁금해졌다.좌표 x가 주어졌을 때, 해당 좌표에 처음으로 도달하는 시점을 구하는 프로그램을 작성하시오.각 테스트 케이스에 대한 답을 한 줄에 하나씩 출력한다.",51.807%,20954,1,9.0,"수학,",
/problem/21863,__builtout_popcount,"GCC 내장 함수 중, __builtin_popcount(unsigned int x) 라는 함수가 존재한다. 이 함수는 unsigned int 형식인 x라는 값의 1비트가 몇 개 있는지를 구한다.예를 들어,__builtin_popcount(3) = 2,__builtin_popcount(4) = 1,__builtin_popcount(-1) = 32 (unsigned int 이므로)등의 값이 나온다.65536 bit 짜리 정수에 대해서 이와 같은 기능을 하는 __builtout_popcount 함수를 구현해보자! 단, bit값을 확인하는 연산은 최대 20번까지만 수행할 수 있다.자세한 사항은 CUSTOM_BITSET::getbit 의 구현내용과, main 에서 정답 판정을 하는 부분을 살펴보자.",18.898%,21863,1,19.0,"비트마스킹,","비트필드,"
/problem/21864,이산로그가 장난이냐?,"BOJ에서 어떤 문제를 풀었던 Sait2000은 입력 범위를 늘려서 장난 아니고 이산로그를 구해야 하는 문제를 만들기로 했습니다.M = 1018 + 31은 소수이고, g = 42는 M의 원시근입니다. 즉, g1 mod M, g2 mod M ... gM - 1 mod M은 각각 서로 다른 [1; M) 범위의 정수입니다. f(x)를 gp mod M = x를 만족하는 최소의 양의 정수 p로 정의합니다. 그러면 f는 [1; M)에서 [1; M)으로 가는 전단사함수(일대일 대응)입니다.수열 {an}을 다음과 같이 정의합니다.a0 = 960002411612632915ai + 1 = f(ai)n이 주어졌을 때, an을 찾아봅시다.an을 출력합니다.",83.333%,21864,1,24.0,"이산 로그,수학,정수론,런타임 전의 전처리,","order,lookup table,db,database,"
/problem/21868,미적분학 입문하기,"$\displaystyle \lim_{x \to x_0} f(x) = L$ : For a given $\epsilon > 0$, there exists a $\delta > 0$ such that $0 < \left| x- x_0 \right| < \delta$, then $\left| f(x) - L \right| < \epsilon$이공계 대학생들은 대학교에 입학하면 반드시 입실론-델타 논법을 배운다. 위의 식은 입실론-델타 논법을 이용한 극한의 정의다.21학번 신입생들이 수강하고 있는 연세대학교 공학수학 I의 2차 퀴즈가 저번 주에 있었다. 국렬이는 연세대학교 신입생들에게 극한의 정의에 관한 내용을 되새겨주기 위해서 이 문제를 출제했다.문제는 간단하다. 양수 $\epsilon$과 정수 $x_0$, 그리고 일차 이하의 다항함수 $f(x)$가 주어졌을 때, $\displaystyle \lim_{x \to x_0} f(x)$의 값인 $L$을 찾고, $\left| f(x) - L \right| < \epsilon$을 만족하는 양수 $\delta$의 최댓값을 구해보자.첫 번째 줄에 극한값 $L$을 출력한다.",37.758%,21868,1,9.0,"미적분학,수학,","미분,적분,"
/problem/21874,모자 게임,"CS-House에서는 매주 목요일에 연세대학교 컴퓨터과학과에 대한 여러 이야기를 팟캐스트 형식으로 다룬다. 2021년 3월 18일에 진행한 CS-House에서는 ICPC World Final에 진출한 윤인섭 선배가 게스트로 나와서 알고리즘 및 Competitive Programming에 대해서 이야기를 했다. 이야기 도중에 시청자들과 함께 재미있는 문제들을 풀어보는 시간을 가졌는데, 그 문제 중 하나를 변형해서 연세대학교 신입생 프로그래밍 경진대회에 내기로 했다. 다음과 같은 문제를 생각해보자.그림과 같이 $N$명의 사람이 앞을 보고 일렬로 서있다. 각 사람은 맨 뒷사람을 제외하고 $0$ 이상 $63$ 이하의 정수가 적힌 모자를 쓰고 있다.각 사람은 자신보다 앞에 있는 사람의 모자에 적힌 수를 모두 볼 수 있지만, 자신을 포함해서 뒤에 있는 사람의 모자에 적힌 수는 볼 수 없다.게임이 시작되면 맨 뒷 사람부터 순서대로 $0$ 이상 $63$ 이하의 정수 중 하나를 말한다.게임을 시작하기 전 $N$명의 사람들이 모여 작전을 세우려고 한다. 자신이 말한 수와 자신의 모자에 적힌 수가 동일한 사람이 최대한 많아지도록 작전을 세워보자.구현이 문제를 풀기 위해서는 hat.cpp 파일을 제출해야 한다. hat.cpp 파일에 포함되어야 하는 함수는 다음과 같다..void init(int N);프로그램이 실행된 직후, 한 번만 호출된다. N은 일렬로 서있는 사람의 수를 의미한다.int call(vector<int> F, vector<int> B, int num);앞에서부터 (num+1)번째에 서있는 사람이 말해야 하는 수를 return한다. num은 $0$ 이상 $N-1$ 이하의 정수다.F는 앞에 있는 사람들이 쓴 모자의 수를 저장한 길이 $N$의 정수 배열이다. F[i]에는 i+1번째 사람이 쓴 모자의 수가 저장되어 있다. 만약 num+1번째 사람이 i+1번째 사람이 쓴 모자의 수를 볼 수 없다면 해당 배열 값은 $0$이다.B는 뒤에 있는 사람들이 말한 수를 저장한 길이 $N$의 정수 배열이다. B[i]에는 i+1번째 사람이 말한 수가 저장되어 있다. 만약 num+1번째 사람이 말하기 전에 i+1번째 사람이 말하는 차례가 오지 않았다면 해당 배열 값은 $0$이다.각 게임마다 call은 총 $N$번 호출된다. call이 호출될 때 마다 num에는 $N-1$부터 $0$까지 수가 순서대로 들어간다.총 $T$번의 모자 게임이 동시에 진행되며, 각 게임별로 $N-1$명이 자신이 쓴 모자에 적힌 수와 동일한 수를 말해야 맞았습니다!!를 받을 수 있다. Grader가 실행 도중 틀렸습니다라고 판정한 경우, 그 즉시 프로그램이 종료된다.",46.774%,21874,1,14.0,"애드 혹,수학,",
/problem/22029,철도,"사이가 나쁜 A, B 두 나라가 있다. A나라는 B나라를 침략하기 위해 B나라의 철도망을 알아내려 한다. B나라에 여러 차례 스파이를 보냈지만 항상 의미있는 정보를 캐기 전 잡혔기 때문에, A나라가 알고 있는 정보는 다음이 전부이다. B나라의 철도망은 모두 $N$개의 역으로 이루어져 있고, 각 역은 $1$부터 $N$까지 번호가 붙어 있다.서로 다른 어떤 두 역을 고르더라도 직접 철로로 이어져 있거나, 철로로 이어진 다른 역(들)을 통해서 이어져 있다. 어떤 두 역을 고르더라도 이 둘을 연결하는 경로는 정확히 하나이다.자신과 자신을 철로로 직접 이은 경우는 없다. 스파이를 보내는 것은 한계가 있음을 깨닫고, A나라는 B나라 철도회사 고위 간부를 매수하여 철도망을 그린 그림을 얻어내려고 한다. 이 그림을 직접 보내면 배신자가 누구인지 알려질 것이므로, 배신자는 다음과 같이 그림을 고쳐서 A나라에 보낼 것이다.철도망을 그린 그림 위에 $K$개의 가짜 철로를 그린다. 즉, 그림에서 철로로 직접 연결되지 않은 서로 다른 두 역 $a$와 $b$를 골라서, 이 둘을 가짜 철로로 직접 잇는다. 이를 $K$번 반복한다.하나의 역에 특별한 표시를 한다.마지막으로, 역들의 번호를 모두 지운다. 배신자는 최종적으로 얻은 그림을 A나라에 전송한다. 이 정보만으로는 B나라의 철도망을 그린 그림이라는 것을 알기 어렵기 때문에, 비밀 정보가 유출되었다는 사실을 아무도 모를 것이다.   이 계획이 성공하기 위해서는 다음과 같은 문제가 해결되어야 한다. A나라가 받은 그림에는 역들의 번호가 지워져 있고, 또한 어느 철로가 진짜이고 가짜인지 표시되어 있지 않다. 알 수 있는 것은 어느 역에 특별한 표시가 되어 있는지, 그리고 가짜 철로를 총 $K$군데 놓았다는 사실뿐이다.  따라서, 보내는 쪽에서는 받는 쪽이 그림만 보고 어느 철로가 진짜이고 어느 철로가 가짜인지 알 수 있도록 적절한 위치에 가짜 철로를 놓고, 적절한 역에 특별한 표시를 해야 한다.또한 받는 쪽에서는 보내는 쪽이 그림을 고친 방법을 이해하고, 받은 그림에서 원래 철도망을 그린 그림을 구해야 한다.위에서 설명한 것처럼, 철도망을 그린 그림을 고치는 함수와, 이 그림으로부터 진짜 철도망을 구하는 함수 둘이 필요하다. A나라는 여러분에게 이 일을 맡기려고 한다.","추가적인 제약 조건이 없다.
",22029,1,19.0,"너비 우선 탐색,해 구성하기,깊이 우선 탐색,그래프 이론,그래프 탐색,트리,","breadthfirst,breadth first,constructive,컨스트럭티브,구성적,depth first,depthfirst,그래프이론,bfs,dfs,trees,"
/problem/22849,수식 알아맞히기 퀴즈 게임,"정수론 시험을 망친 시루와 루시는 정수론을 배우기 위해서 깊은 산속에 사는 정수론 도사 ahgus를 찾아갔다. ahgus는 퀴즈 게임을 통해서 제자를 받기로 결심했다.그에게는 사랑하는 소수 $p$와 다음과 같은 함수가 있다.$$f(x) = \sum_{i=1}^{p-1} a_{i}i^{x} \, (0 \leq a_{i} \leq p-1)$$그는 둘에게 함숫값 $f(1)$, $f(2)$, $\cdots$, $f(p-1)$을 각각 $p$로 나눈 나머지를 알려주었다. 그리고 그는 자신이 사랑하는 함수를 알아맞히는 사람만이 자신의 제자가 될 자격이 있다고 말하였다.시루와 루시를 도와서 함수를 계산해주자!$a_1$, $a_2$, ..., $a_{p-1}$을 출력한다. 모든 $a_i$는 항상 유일하게 존재하며 정수임을 증명할 수 있다.",23.529%,22849,1,25.0,"고속 푸리에 변환,수학,정수론,","푸리에변환,컨볼루션,convolution,"
/problem/23838,웜뱃,"브리즈번 시는 돌연변이로 거대해진 웜뱃(호주에 사는 너구리 비슷한 동물)에 장악당했다. 당신의 임무는 사람들을 구조하는 것이다.브리즈번 시의 도로는 커다란 격자 모양으로 되어 있다. 동서 방향으로 놓인 수평 도로는 R 개가 있고, 북쪽에서 남쪽 방향으로 차례로 번호가 0, …, (R - 1) 로 매겨져 있다. 또한, 남북 방향으로 놓인 수직 도로는 C 개가 있고, 서쪽에서 동쪽 방향으로 차례로 번호가 0, …, (C - 1) 로 매겨져 있다. 다음 그림은 이렇게 번호가 매겨진 도로의 예이다.웜뱃은 북쪽에서부터 쳐들어오고 있고, 사람들은 남쪽으로 도망친다. 사람들은 가로 방향으로는 어느 쪽이든 움직일 수 있지만, 세로 방향으로는 안전한 방향인 남쪽으로만 움직일 수 있다.수평 도로 P 와 수직 도로 Q 의 교차로는 (P, Q) 로 표현한다. 두 교차로 사이 세그먼트에는 웜뱃들이 있을 수 있고, 몇 마리의 웜뱃이 있는지는 시간이 흐르면서 변할 수 있다. 여러분의 임무는 북쪽(수평 도로 0 번)의 주어진 교차로에 도착한 사람을 남쪽(수평 도로 R - 1 번)의 주어진 교차로로 가는 길을 알려주는 것인데, 이 경로를 지날 때 가능한 한 적은 수의 웜뱃을 만나야 한다.먼저, 격자의 크기와 각 도로 세그먼트에 웜뱃이 몇 마리가 있는지가 주어진다. 다음에는 E 개의 이벤트가 차례로 주어지는데, 각 이벤트는 아래 두 가지 중 하나의 형태이다.change: 어떤 도로 세그먼트에 있는 웜뱃의 마릿수가 바뀐다.escape: 사람 한 명이 수평 도로 0 번의 주어진 교차로로 도착하고, 이 사람을 가장 적은 수의 웜뱃을 만나면서 수평 도로 R - 1 의 주어진 교차로로 보내는 경로를 구해야 한다.이러한 이벤트는 다음과 같이 정의되는 함수 init(), changeH(), changeV(), escape()을 사용하여 처리해야 한다.","추가적인 입력 제한 사항이 없다.
",23838,1,26.0,"자료 구조,다이나믹 프로그래밍,크누스 최적화,세그먼트 트리,제곱근 분할법,","자료구조,자구,동적계획법,동적 계획법,다이나믹프로그래밍,구간트리,세그트리,fenwick,펜윅,루트분할법,평방분할법,모,mo,sqrt,"
/problem/23894,합성함수와 쿼리 2,"함수 $f : \{1, 2, \cdots, N\} → \{1, 2, \cdots, N\}$의 각각의 함숫값 $f(1), f(2), \cdots, f(N)$이 주어진다. 이 때, 다음 쿼리를 수행하는 프로그램을 작성하시오.1 x : $f(1)$의 값을 $x$로 변경한다.2 m x : $f^m (x)$의 값을 출력한다.여기서 $f^m$은 $f$를 $m$번 합성한 함수로, $f^1 (x) = f(x)$이고 $m \ge 2$인 모든 자연수 $m$에 대해 $f^m (x) = (f \circ f^{m-1})(x) = f( f^{m-1} (x) ) $를 만족한다.2번 쿼리의 결과를 한 줄에 하나씩 출력한다.","추가적인 제한이 없다.
",23894,1,18.0,"자료 구조,그래프 이론,그래프 탐색,희소 배열,","자료구조,자구,그래프이론,bfs,dfs,스파스어레이,sparse table,"
/problem/24275,공정한 동전,"한별이는 던졌을 때마다 앞면과 뒷면이 나올 확률이 같은 동전 하나를 가지고 있다. 한별이와 히나는 내기를 하는데, 내기는 $N$ 개의 단계로 이루어지며, 올해가 $2022$년인 만큼 각 라운드는 동전을 $2022$번 던져서 나온 앞면과 뒷면 수를 따라서 게임이 진행된다. $i$ 번째 단계에서 나온 앞면의 수를 $A_i$라고 하자.히나는 내기에서 져서 한별이의 동전을 의심하기 시작했다. 그래서 한별이의 동전이 앞면과 뒷면이 나올 확률이 같지 않다고 주장하려고 한다. 이 주장에 대한 근거를 마련하려면 우연히 앞면 혹은 뒷면 쪽으로 치우쳐져 나올 확률, 즉 유의확률(p-value)이 낮다는 것을 보여야 한다. 히나는 유의확률을 계산하는 함수 $p(N, K)$를 $N$ 번 동전을 던져서 평균적으로 앞면이 나와야 하는 횟수인 $N/2$와 실제로 앞면이 나온 횟수 $K$가 얼마나 많이 차이가 나는지를 가지고 계산하기로 했다. $N$ 개의 동전을 던져서 $X$ 번 앞면이 나왔다면 평균적으로 앞면이 나와야 하는 횟수인 $N/2$와 $\left|N/2-X\right|$만큼 차이가 난다는 사실을 바탕으로, $p(N, K)$를 앞면과 뒷면이 나올 확률이 같은 동전을 $N$ 번 던졌을 때, 앞면이 나온 횟수와 $N/2$가 $\left|N/2-K\right|$ 이상 차이가 날 확률로 정의하자.가령이면 동전을 $3$번 던져서 앞면이 $0$번 나올 확률과 $3$번 나올 확률은 $1/8$, $1$번 나올 확률과 $2$번 나올 확률은 $3/8$이다. $p(3, 3)$은 $3$번 동전을 던졌을 때, 앞면이 나온 횟수와 $3/2$가 $\left|3/2-3\right|$ 이상 차이가 날 확률로 정의되고, 이 경우는 앞면이 $0$번 나온 경우와 $3$번 나온 경우가 해당하기 때문에, $p(3, 3) =1/8+1/8=1/4$이다.히나는 게임에서 $L$ 번째부터 $R$ 번째까지 단계가 중요하다고 주장하고, 해당 결과를 유의확률을 계산하는 데에 사용하기로 했다. $L$ 번째부터 $R$ 번째 단계까지의 결과만 사용해서 계산된 유의확률은 $p$ 함수의 정의에 따라 $p\left(2022(R-L+1), A_L+\cdots+A_R\right)$로 정의되며, 히나는 이 유의확률로 가능한 최솟값 $\min_{1 \le L \le R \le N} p\left(2022(R-L+1), A_L+\cdots+A_R\right)$를 구하고 싶다.$\min_{1 \le L \le R \le N} p\left(2022(R-L+1), A_L+\cdots+A_R\right)$를 출력하여라. 정답과의 절대오차는 $10^{-6}$ 이하여야 한다.",22.727%,24275,1,27.0,"볼록 껍질을 이용한 최적화,분할 정복,수학,매개 변수 탐색,통계학,","컨벡스헐트릭,컨벡스헐최적화,dnc,파라메트릭,average,평균,variance,분산,표준편차,표준 편차,"
/problem/24313,알고리즘 수업 - 점근적 표기 1,"오늘도 서준이는 점근적 표기 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.알고리즘의 소요 시간을 나타내는 O-표기법(빅-오)을 다음과 같이 정의하자.O(g(n)) = {f(n) | 모든 n ≥ n0에 대하여 f(n) ≤ c × g(n)인 양의 상수 c와 n0가 존재한다}이 정의는 실제 O-표기법(https://en.wikipedia.org/wiki/Big_O_notation)과 다를 수 있다.함수 f(n) = a1n + a0, 양의 정수 c, n0가 주어질 경우 O(n) 정의를 만족하는지 알아보자.f(n), c, n0가 O(n) 정의를 만족하면 1, 아니면 0을 출력한다.",34.171%,24313,1,6.0,"수학,",
/problem/24314,알고리즘 수업 - 점근적 표기 2,"오늘도 서준이는 점근적 표기 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.알고리즘의 소요 시간을 나타내는 Ω-표기법(빅-오메가)을 다음과 같이 정의한다.Ω(g(n)) = {f(n) | 모든 n ≥ n0에 대하여 c × g(n) ≤ f(n)인 양의 상수 c와 n0가 존재한다}이 정의는 실제 Ω-표기법(https://en.wikipedia.org/wiki/Big_O_notation)과 다를 수 있다.함수 f(n) = a1n + a0, 양의 정수 c, n0가 주어질 경우 Ω(n) 정의를 만족하는지 알아보자.f(n), c, n0가 Ω(n) 정의를 만족하면 1, 아니면 0을 출력한다.",70.270%,24314,1,7.0,"수학,",
/problem/24315,알고리즘 수업 - 점근적 표기 3,"오늘도 서준이는 점근적 표기 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.알고리즘의 소요 시간을 나타내는 Θ-표기법(빅-쎄타)을 다음과 같이 정의한다.Θ(g(n)) = {f(n) | 모든 n ≥ n0에 대하여 c1 × g(n) ≤ f(n) ≤ c2 × g(n)인 양의 상수 c1, c2, n0가 존재한다}이 정의는 실제 Θ-표기법(https://en.wikipedia.org/wiki/Big_O_notation)과 다를 수 있다.함수 f(n) = a1n + a0, 양의 정수 c1, c2, n0가 주어질 경우 Θ(n) 정의를 만족하는지 알아보자.f(n), c1, c2, n0가 Θ(n) 정의를 만족하면 1, 아니면 0을 출력한다.",82.270%,24315,1,7.0,"수학,",
/problem/24368,알고리즘 수업 - 점근적 표기 4,"오늘도 서준이는 점근적 표기 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.알고리즘의 소요 시간을 나타내는 O-표기법(빅-오)은 다음과 같이 정의한다.O(g(n)) = {f(n) | 모든 n ≥ n0에 대하여 f(n) ≤ c × g(n)인 양의 상수 c와 n0가 존재한다}이 정의는 실제 O-표기법(https://en.wikipedia.org/wiki/Big_O_notation)과 다를 수 있다.함수 f(n) = a2n2 + a1n + a0, 양의 정수 c, n0가 주어질 경우 O(n2) 정의를 만족하는지 알아보자.f(n), c, n0가 O(n2) 정의를 만족하면 1, 아니면 0을 출력한다.",12.787%,24368,1,10.0,"많은 조건 분기,수학,","케이스,케이스워크,케이스 워크,"
/problem/24369,알고리즘 수업 - 점근적 표기 5,"오늘도 서준이는 점근적 표기 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.알고리즘의 소요 시간을 나타내는 Ω-표기법(빅-오메가)을 다음과 같이 정의한다.Ω(g(n)) = {f(n) | 모든 n ≥ n0에 대하여 c × g(n) ≤ f(n)인 양의 상수 c와 n0가 존재한다}이 정의는 실제 Ω-표기법(https://en.wikipedia.org/wiki/Big_O_notation)과 다를 수 있다.함수 f(n) = a2n2 + a1n + a0, 양의 정수 c, n0가 주어질 경우 Ω(n2) 정의를 만족하는지 알아보자.f(n), c, n0가 Ω(n2) 정의를 만족하면 1, 아니면 0을 출력한다.",44.000%,24369,1,10.0,"많은 조건 분기,수학,","케이스,케이스워크,케이스 워크,"
/problem/24370,알고리즘 수업 - 점근적 표기 6,"오늘도 서준이는 점근적 표기 수업 조교를 하고 있다. 아빠가 수업한 내용을 학생들이 잘 이해했는지 문제를 통해서 확인해보자.알고리즘의 소요 시간을 나타내는 Θ-표기법(빅-쎄타)을 다음과 같이 정의한다.Θ(g(n)) = {f(n) | 모든 n ≥ n0에 대하여 c1 × g(n) ≤ f(n) ≤ c2 × g(n)인 양의 상수 c1, c2, n0가 존재한다}이 정의는 실제 Θ-표기법(https://en.wikipedia.org/wiki/Big_O_notation)과 다를 수 있다.함수 f(n) = a2n2 + a1n + a0, 양의 정수 c1, c2, n0가 주어질 경우 Θ(n2) 정의를 만족하는지 알아보자.f(n), c1, c2, n0가 Θ(n2) 정의를 만족하면 1, 아니면 0을 출력한다.",43.590%,24370,1,10.0,"많은 조건 분기,수학,","케이스,케이스워크,케이스 워크,"
/problem/24518,잘 알려진 합 구하기,"함수 $f(x)$를 $N$을 $x$로 나눴을 때의 몫으로, $g(x)$를 $x$를 $M$으로 나눴을 때의 나머지로 정의하자.다음 값을 $1\,000\,000\,007$로 나눈 나머지를 구하라.$$\sum_{i=1}^N f(i)×g(i)$$주어진 수식의 값을 $1\,000\,000\,007$로 나눈 나머지를 출력한다.",31.863%,24518,1,16.0,"수학,정수론,",
/problem/24652,수열 선물하기,"하이비의 생일이 점점 다가오고 있다. PS를 하는 사람은 다들 알겠지만, 생일인 사람에게는 그 사람이 좋아하는 수열을 선물해줘야 한다.하이비가 올해 받고 싶어하는 선물은 다음 조건을 만족하는 수열 A이다.A는 1부터 N까지의 정수가 정확히 한 번씩 등장하는 길이 N의 수열이어야 한다.A에 있는 모든 수로 이진 탐색을 수행했을 때, 정확히 K개의 수를 찾을 수 있어야 한다.	즉, 아래 정의되어있는 함수 f에 대하여 f(A[1]), f(A[2]), ..., f(A[N])을 모두 시행했을 때, true가 반환되는 횟수가 정확히 K번이어야 한다.		// C++ 이진 탐색bool f(int x){    int l = 1, r = N;    while (l <= r){        int mid = (l+r) / 2;        if (A[mid] == x){ return true; } // 값이 중앙값과 같으면 '찾았음'으로 판정        if (x < A[mid]){ r = mid-1; }    // 값이 중앙값보다 작으면 [l, mid) 구간을 탐색        if (A[mid] < x){ l = mid+1; }    // 값이 중앙값보다 크면 (mid, r] 구간을 탐색    }    return false;                        // [l, r] 구간에 남은 수가 없다면 '찾지 못함'으로 판정}하이비의 친구 바이히는 위 조건을 만족하는 수열 A를 선물하기로 했으나, 이를 손으로 직접 만들기는 귀찮아서 프로그램을 사용해 수열을 만들기로 했다. 하지만 PS 초보인 바이히는 결국 그러한 프로그램을 만드는 데 실패했고, 당신에게 도움을 청해왔다.바이히를 위해 N과 K가 주어질 때, 하이비에게 선물로 줄 수 있는 수열 A를 아무거나 하나 만들어주자.만약 조건을 만족하는 수열이 존재한다면 첫째 줄에 ""YES""를 출력하고, 둘째 줄에 그러한 수열 중 아무거나 하나를 출력한다. 만약 조건을 만족하는 수열이 존재하지 않는다면 첫째 줄에 ""NO""를 출력한다.",75.862%,24652,1,15.0,"이분 탐색,해 구성하기,","이분탐색,이진탐색,constructive,컨스트럭티브,구성적,"
/problem/24726,미적분학 입문하기 2,"연세대학교 1학년 이공계생들은 ""미분적분학과벡터해석"", 또는 ""공학수학""을 배우게 된다. 해당 과목에서 회전체의 부피에 대한 내용을 배운다. 닫힌 구간 $[a,b]$에서의 함수 $r(x)$를 $x$축을 기준으로 회전시켰을 때 나오는 회전체의 부피는 $\displaystyle \pi \int_{a}^{b} \{r(x)\}^2 dx$로 구할 수 있다.주어진 제 1사분면에 있는 삼각형을 $x$축과 $y$축을 기준으로 각각 회전시켰을 때 나오는 두 회전체의 부피를 위의 공식을 참고해서 구해보자.주어진 삼각형을 $x$축으로 회전시켰을 때 나오는 회전체의 부피와 $y$축으로 회전시켰을 때 나오는 회전체의 부피를 공백을 사이에 두고 출력한다. 절대/상대 오차는 $10^{-6}$까지 허용한다.",70.899%,24726,1,12.0,"미적분학,기하학,수학,","미분,적분,"
/problem/24732,잠자는 규리,"2019년 송도의 세미나실에서는 오늘도 연세대학교 컴퓨터과학과 학생들이 모여 과제를 하고 있다. 이때 잔뜩 술에 취한 규리(당시 새내기)가 등장해 과제를 시작했다. 규리는 너무 졸린 나머지 아래의 코드를 작성하고 잠이 들었다.규리의 코드는 맞는 답을 리턴한다. 단지 과제에 주어진 $N$이 너무 컸기 때문에 시간 제한 안에 돌아가지 않을 뿐이다. 당신은 규리의 화면을 바라보다가 불쌍한 규리를 도와주기 위해 규리의 코드를 수정하기로 했다. 당신은 시간 제한 안에 실행되면서, 규리의 코드와 같은 값을 리턴하는 함수를 작성해야 한다.",22.680%,24732,1,17.0,"자료 구조,누적 합,스택,","자료구조,자구,구간합,부분합,rangesum,"
/problem/24892,이차 함수,"이차 함수 $f(x) = (x-a)(x-b)$가 주어진다.좌표평면 상의 $y = f(x)$ 그래프 위에 $a = x_0 < x_1 < x_2 <\cdots < x_n = b$ 이도록 $n+1$개의 점 $(x_0,f(x_0)),(x_1,f(x_1)),\cdots,(x_n,f(x_n))$을 찍을 때, 이 $n+1$개의 점들로 만들어지는 볼록다각형 넓이의 최댓값을 구하시오.모든 입력에 대해 정답은 항상 유리수임을 증명할 수 있다.다각형 넓이의 최댓값이 $\displaystyle \frac{p}{q}$($p$와 $q$는 서로소인 자연수)일 때, $q\cdot v\equiv p (\bmod 1\,000\,000\,007$)이 되는 $0$이상 $1\,000\,000\,006$ 이하의 정수 $v$를 출력한다.",80.822%,24892,1,15.0,"미적분학,수학,모듈로 곱셈 역원,정수론,","미분,적분,modinv,"
/problem/25008,문자열 찾기,"영어 소문자로 구성된 두 문자열 $A$와 $B$에 대해서 다음의 조건이 만족될 때, 두 문자열은 “사실상 같다”고 한다.$A$와 $B$의 길이가 같다.모든 가능한 정수 $i$와 $j$에 대해 $A$의 $i$번째와 $j$번째 글자가 같으면 $B$의 $i$번째와 $j$번째 글자도 같다.모든 가능한 정수 $i$와 $j$에 대해 $A$의 $i$번째와 $j$번째 글자가 다르면 $B$의 $i$번째와 $j$번째 글자도 다르다.예를 들어, $A = $aba와 $B = $pqp는 사실상 같은 문자열들이다. 하지만, $A = $abca와 $B =$abcb는 사실상 같은 문자열의 쌍이 아니다.문자열 $T$와 $P$를 받아서 $T$의 연속된 부분문자열들 중 $P$와 사실상 같은 부분문자열의 개수를 계산하는 프로그램을 작성하라.예를 들어, $T =$abababbab이고 $P =$pqp인 경우 $T$의 왼쪽부터 aba, bab, aba, bab, bab의 $5$개의 부분문자열이 $P$와 사실상 같은 것들임을 알 수 있다. 여러분은 다음 함수를 작성하여야 한다.int findP( char T [], char P [], int N, int M ) : T는 길이 N+1인 배열(문자열)이다. P는 길이 M+1인 배열이다. T와 P에는 각각 길이 N과 M인 영어 소문자 문자열이 저장되어 있다. T와 P의 마지막 위치에는 ‘\0’이 저장되어 있다. findP는 T의 연속된 부분문자열들 중 P와 사실상 같은 부분문자열의 개수를 리턴해야 한다.",5,25008,1,19.0,"해싱,KMP,문자열,","스트링,"
/problem/25009,뚫기,"가까운 미래 싱가포르에서는 뚫기라는 게임이 유행 중이다. 게임 규칙은 간단하다. 쐐기 모양의 비행선이 $N \times M$ 크기의 터널을 왼쪽에서 오른쪽으로 통과하도록 움직이면 된다. 터널에는 비행선의 전진을 방해하기 위한 초록색의 막이 $N$개 존재한다. 막은 각 칸의 왼쪽 벽에 위치하며, 여러 칸에 걸쳐 연속되게 존재하는 막은 하나의 막으로 간주한다. 편의상 비행선의 전진 방향을 $x$축, 그에 수직된 방향을 $y$축으로 나타내면, 동일한 $x$좌표에는 하나의 막만 존재한다.예를 들어, 아래 그림은 $11 \times 6$ 크기의 터널에 $11$개의 막이 존재하는 경우이다. 가장 왼쪽 막은 $(0, 2)$ 칸에서 $(0, 5)$ 칸까지 이어진 하나의 막이고, 가장 오른쪽 막은 $(10, 1)$ 칸에서 $(10,5)$ 칸까지 이어진 하나의 막이다.비행선은 각 칸에서 두 가지 움직임 중 한가지를 할 수 있다. 첫 번째 움직임은 순간이동이다. 순간이동은 현재 비행선이 위치한 칸과 동일한 $x$좌표의 임의의 칸으로 비행선을 이동시키는 것이다. 이 경우 이동하는 칸의 위치와는 무관하게 항상 비용 $A$만큼만 든다. 예를 들어, 아래 그림은 $(0, 1)$에 위치한 비행선이 $(0, 5)$로 순간이동하는 경우로, 비용 $A$가 들게 된다.비행선의 두 번째 움직임은 전진이다. 비용은 $0$이다. 비행선이 전진하려는 방향에 막이 있더라도 비행선은 이를 뚫고 지나갈 수 있다. 다만 이 경우에는 비용 $B$가 든다. 예를 들어, 아래 그림은 $(6,5)$에 위치한 비행선이 $(7,5)$로 전진하는 경우로, 마침 $(7,5)$에는 막이 존재하여 비용 $B$가 들게 된다.비행선이 터널을 완전히 통과하면 게임이 끝나게 되며, 게임 스코어는 터널을 통과할 때 발생한 비용의 총합으로 주어진다. 당연한 이야기지만 이 게임은 스코어가 낮을수록 좋다. 게임을 시작할 때 비행기의 $y$좌표는 아무 비용 없이 게이머가 선택할 수 있고, 게임이 끝날 때 비행기의 $y$좌표는 어디여도 상관없다.터널의 크기와 막의 위치가 동일하더라도, 비용 $A$와 비용 $B$가 바뀌면 게임 스코어도 달라질 수 있고 최소의 게임 스코어를 얻기 위한 비행선의 움직임도 달라질 수 있다. 여러분은 주어진 터널의 크기와 막의 위치를 이용하여 비용 $A$와 비용 $B$가 바뀔 때마다 가능한 가장 낮은 게임 스코어를 구하기 위해서 다음 $2$가지 함수를 구현해야만 한다.void init( int N, int M, std::vector<int> Y1, std::vector<int> Y2 ) ; 최초에 호출되며 단 한번 호출되는 함수이다. N과 M은 터널의 크기 $N \times M$을 나타낸다. Y1과 Y2는 막의 위치를 나타내는 크기 $N$인 배열로, $(X, Y_1)$부터 $(X, Y_2)$까지 하나의 막이 있다면 Y1[X]와 Y2[X]의 값은 $Y_1$과 $Y_2$이다.long long minimize( int A, int B ) ; A는 비행선이 한번 순간이동하는 비용, B는 비행선이 한번 막을 뚫는 비용이다 이를 이용하여 터널을 통과하는데 필요한 비용의 최솟값을 구하여 return 한다.",3,25009,1,26.0,"볼록 껍질,자료 구조,기하학,느리게 갱신되는 세그먼트 트리,수학,세그먼트 트리,","컨벡스헐,자료구조,자구,레이지,레이지프로퍼게이션,레이지프로파게이션,구간트리,fenwick,펜윅,구간트리,세그트리,fenwick,펜윅,"
/problem/25010,지름길,"$N$개의 도시들이 평면 위의 서로 다른 곳에 위치한다. 이 도시들은 $1$부터 $N$까지 정수로 나타낸다.도시 $i$와 도시 $i+1$사이에는 도로가 존재하고 $R_i$로 나타낸다($i = 1 , \dots , N-1$). 따라서 모두 $N-1$ 개의 도로들이 존재한다. 각 $i = 1 , \dots , N-1$ 에 대해서, 도시 $i$가 위치하고 있는 좌표를 $(x_i,y_i)$로 나타내면, 도로 $R_i$의 길이는 $\left| x_i - x_{i+1} \right| + \left| y_i - y_{i+1} \right|$로 주어진다.도시 $i$와 $j$사이의 경로 $P$는 $i$로부터 $j$로 이동할 때 지나는 도로들의 집합이다. 경로 $P$의 길이는 $P$에 속한 도로들의 길이의 합이다. 우리는 도시들의 지름에 관심이 있다. 지름은 모든 도시간의 최단 경로들의 길이의 최댓값이다. 물론 위에 주어진 도시들의 지름은 도시 $1$과 $N$사이 경로의 길이와 같다.우리는 위의 도시들 중 한 쌍을 선택해서 두 도시 사이에 새롭게 도로를 건설할 예정이다. 이 도로를 $R_\text{new}$로 나타내고, $R_\text{new}$가 도시 $a$와 $b$를 연결한다면, $R_\text{new}$의 길이는 $\left| x_a - x_b \right| + \left| y_a - y_b \right|$ 로 주어진다. 문제는 도시들의 지름이 최소가 되도록 도로 $R_\text{new}$를 결정하는 것이다.$N$개 도시들의 위치가 주어질 때, 도시들의 지름이 최소가 되도록 도로 $R_\text{new}$를 결정하고 그 지름의 최솟값을 출력하는 프로그램을 작성하시오.예를 들어, 아래 그림에서 $4$개의 도시와 도시사이를 연결하는 $3$개의 도로(실선)가 주어진다. 새롭게 건설할 수 있는 도로의 후보는 $3$개($1$과 $4$사이, $1$과 $3$사이, $4$와 $2$사이)가 존재한다. 이 중에서 그림처럼 $4$와 $2$사이에 도로(점선)를 건설하면 도시들의 지름은 $6$이고 이것이 최솟값이다.여러분은 관리자를 위해 다음 한 가지 함수를 구현해야만 하고, 이 함수를 사용하여 답을 제출하여야 한다.long long shortcut(int N, long long X[], long long Y[]); 도시들의 개수 N, 각 도시의 위치를 나타내는 X[0..N-1]와 Y[0..N-1]를 인자로 받는다. 여기서, X[]와 Y[]는 크기 N인 벡터(vector)이고, X[i]와 Y[i]의 값은 각각 도시 i+1의 x좌표와 y좌표이다. 여러분은 이 함수를 사용하여 결과를 제출한다. 반환 값은 새롭게 건설된 도로가 추가될 때, 도시들의 지름의 최솟값이다.","추가 제한이 없다.
",25010,1,26.0,"자료 구조,덱,매개 변수 탐색,두 포인터,","자료구조,자구,파라메트릭,투포인터,인치웜,inchworm,twopointer,"
/problem/25011,칠하기,"$N \times M$ 칸으로 이루어진 격자가 있다. 격자의 일부 칸들은 막혀서 갈 수 없는 칸들이고, 다른 칸들은 갈 수 있는 칸들이다. 이제 다음 규칙을 따라서 갈 수 있는 칸들에 색을 칠하려고 한다.$N \times M$ 칸 중 한 칸을 현재 칸으로 잡고 시작한다. 시작하는 현재 칸은 갈 수 있는 칸 중 어떤 것이든 가능하다.현재 칸에서 한 방향(위/아래/왼쪽/오른쪽 중 하나)을 정하고, 격자의 왼쪽/오른쪽/위/아래 경계에 도착하거나 이동하려는 칸이 막혀 있을 때까지 계속 이동한다. 중간에 멈출 수 없음에 유의하시오.정지할 때까지 만약 가로 방향(왼쪽 또는 오른쪽)으로 이동했다면 가로로 이동했던 칸들이 모두 노란 색으로 칠해진다. 이동을 시작한 칸도 노란 색으로 칠해진다. 만약 정지할 때까지 세로 방향(위 또는 아래)으로 이동했다면 세로로 이동했던 칸들이 모두 파란 색으로 칠해진다. 이동을 시작한 칸도 파란 색으로 칠해진다. (이동하려는 방향이 바로 막혀 있어서 한 칸도 이동할 수 없었던 경우에도 시작하는 칸에 색이 칠해지는 것으로 정한다.)모든 갈 수 있는 칸을 적어도 한 번 이상 노란 색으로 칠했고, 또 적어도 한 번 이상 파란 색으로 칠했다면 성공이며 종료한다.만약 그렇지 않다면, 2번 과정이 끝났을 때 정지한 칸, 즉 마지막으로 이동할 수 있었던 칸으로부터 시작하여 다시 2-4번 과정을 반복한다. 이 과정을 무한히 반복하더라도 모든 갈 수 있는 칸을 적어도 한 번 이상 노란색으로, 또 적어도 한 번 이상 파란 색으로 칠할 방법이 없다면 실패이다.예를 들어 다음 예를 살펴보자. $2 \times 3$ 격자의 모든 칸이 갈 수 있는 칸들인 다음 예제에서, 가장 왼쪽 위인 $(0, 0)$에서 출발하면 왼쪽 그림과 가운데 그림의 예와 같이, 어떻게 이동하더라도 모든 갈 수 있는 칸을 적어도 한 번 파란색, 그리고 적어도 한 번 노란색으로 칠할 수 없다. 반면, $(0, 1)$에서 출발하여 오른쪽 그림처럼 이동하면 모든 갈 수 있는 칸을 적어도 한 번 파란색, 그리고 적어도 한 번 노란색으로 칠할 수 있음을 알 수 있다.격자의 크기와 배치가 주어졌을 때, 모든 갈 수 있는 칸을 파란색과 노란색으로 칠할 수 있는 지를 구하려 한다. 여러분은 이 문제를 풀기 위해서 다음 함수를 구현해야만 한다.int yellowblue( int N, int M, vector<string> V ) ; 단 한번 호출되는 함수 이다. N과 M은 격자의 크기를 나타낸다. V는 격자의 상태를 나타내는 크기 N인 string 의 배열(vector)이다. V의 각 string의 길이는 M이다. 격자의 $(i, j)$번째 칸이 갈 수 있는 칸이라면 V[$i$]의 $j$번째 글자는 ‘.’이고, 막혀 있는 칸이면 ‘#’이다. 만약 어떤 위치에 서 시작하여 격자의 모든 갈 수 있는 칸을 적어도 한 번 파란색, 적어도 한 번 노란색으로 칠할 수 있다면 $1$을, 그렇지 않다면 $0$을 return해야 한다.","추가 제한이 없다.
",25011,1,21.0,"그래프 이론,강한 연결 요소,","그래프이론,"
/problem/25012,마법의 다이얼,"계속되는 알고리즘 공부에 잠시 지친 경근이는 다른 세계에서 몇 일간 쉬고 오면 좋을 것이라는 생각을 했다. 그러던 어느 날, 다른 세계로 떠나는 문이 있는 장소를 상수에게 듣게 되어 그 곳으로 갔다. 그 곳에는 다른 세계로 떠나는 문이 있었는데 잠겨 있었고, 문을 열 수 있는 커다란 다이얼 식 자물쇠가 있었다.자물쇠는 위아래로 $M$개의 다이얼로 만들어져 있다. 각 다이얼은 $R$개의 칸이 있고 좌우로 칸에 맞추어 돌릴 수 있다. 다이얼의 각 칸에는 점이 있을 수도 있고 점이 없을 수도 있다. 각 다이얼에는 최소 $1$개의 점이 있다. 다이얼들을 돌려서 어떤 위치에서든 세로로 모든 칸에 점이 있도록 만들면 문이 열린다고 한다. 각각의 다이얼은 따로 돌아간다. 다이얼이 아주 무거워 돌리기 힘들기 때문에 다이얼을 돌리는 칸 수의 합을 최소화하고 싶다.위 그림은 다이얼의 한 예를 보여 준다. 가능한 최선의 방법 중 하나는, 위에서 첫 번째 다이얼을 왼쪽으로 한 칸, 두 번째 다이얼을 왼쪽으로 두 칸, 세 번째 다이얼을 오른쪽으로 한 칸, 네 번째 다이얼을 돌리지 않아서, 총 4칸을 돌리는 방법이다.다이얼의 크기와 점들의 위치를 입력으로 받아서 문이 열리도록 최소 칸 수로 다이얼을 돌리는 방법을 알아내는 프로그램을 작성하라. 점들의 위치는 다이얼 번호와 칸 번호의 쌍인 좌표로 주어진다. 제일 위의 다이얼이 $0$번 다이얼이다. 아래로 가면서 다이얼 번호가 $1$씩 증가한다. 제일 아래 다이얼이 $M-1$번 다이얼이 될 것이다. 칸 번호를 정하기 위해 임의의 동일한 위치의 (즉, 세로로 한 줄에 위치한) 칸들을 $0$번으로 잡는다. 오른쪽으로 가면서 칸 번호가 $1$씩 증가한다. $0$번 칸의 왼쪽에는 $R-1$번 칸이 있을 것이다. 주어진 점들의 좌표가 겹치는 경우는 없다.long long findMinClicks( int M, int R, vector< pair<int, int> > P ) : M은 다이얼의 개수이다. R은 한 다이얼의 칸 수이다. P는 크기 N인 int 쌍들의 배열이다. 한 쌍의 첫 자연수는 다이얼 번호, 두 번째 자연수는 칸 번호이다. 주어진 점들의 좌표가 겹치는 경우는 없다. findMinClicks() 함수는 문이 열리도록 최소 칸 수로 다이얼을 돌리는 방법에서 돌리는 칸 수를 리턴해야 한다.",4,25012,1,19.0,"다이나믹 프로그래밍,구현,함수 개형을 이용한 최적화,스위핑,","동적계획법,동적 계획법,다이나믹프로그래밍,슬로프트릭,슬로프 트릭,라인 스위핑,"
/problem/25013,하나 둘 셋,"길이가 $N$인 배열 $A$가 있다. 이 배열은 $1$, $2$, $3$ 세 값으로만 이루어져 있다. 우리는 이 배열에서 다음 조건을 만족하는 세 인덱스의 순서쌍 $(i, j, k)$들을 최대한 많이 찾으려고 한다. 배열의 세 인덱스 $i$, $j$, $k$, ($0 ≤ i < j < k < N$)에 대해서 $A[i] = 1$, $A[j] = 2$, $A[k] = 3$이거나, $A[i] = 3$, $A[j] = 2$, $A[k] = 1$이어야 한다. 단, 한 인덱스는 최대 한 개의 순서쌍에만 들어갈 수 있다.예를 들어 $A = \{1, 2, 3, 2, 3, 1\}$이 주어졌다고 하자. 조건을 만족하는 답은 $(0, 1, 4)$, $(2, 3, 5)$ 가 된다. ($A[0] = 1$, $A[1] = 2$, $A[4] = 3$이고 $A[2] = 3$, $A[3] = 2$, $A[5] = 1$)$A$가 주어졌을 때, 조건을 만족하는 순서쌍을 최대한 많이 찾아서 보고하는 프로그램을 작성하라.여러분은 다음 함수를 작성하여야 한다.void maximize( vector<int> A ) : A는 길이 $N$인 vector로, $1$, $2$, $3$ 세 값으로만 이루어 져 있다. maximize는 A에서 문제의 조건에 맞는 순서쌍 $(i, j, k)$들을 최대한 많이 찾아내고, 찾아낸 $(i, j, k)$ 하나마다 grader의 answer(int i, int j, int k) 함수를 정확하게 한 번 호출한다. 최대 개수의 순서쌍들을 찾는 방법이 여러 가지인 경우 그 중 어떤 것을 찾아도 좋다. 또, 순서쌍들끼리의 호출 순서는 무시된다. 즉, 문제의 예에서는 answer(0, 1, 4)를 호출하고 answer(2, 3, 5)를 호출해도 되고, answer(2, 3, 5)를 호출한 후 answer(0, 1, 4)를 호출해도 된다.",2 3 5,25013,1,24.0,"그리디 알고리즘,두 포인터,","탐욕법,투포인터,인치웜,inchworm,twopointer,"
/problem/25014,열차의 이동,"조차장은 열차의 객차들을 잇거나 떼어 내면서 열차를 유지하고 보수하는 장소이다. 조차장에 는 열차를 움직일 수 있는 선로가 존재한다. 우리는 선로 상에서 열차의 객차들의 위치를 그래프로 나타낼 것이다. 그래프의 각 간선은 열차의 한 객차가 위치한 상태를 나타내고, 따라서 열차는 그래프상의 경로로 나타낸다. 이때, 경로상의 정점들과 간선들은 모두 달라야 한다. 특별히, 문제에서 주어지는 그래프는 항상 트리이다.그림 1각각 초기와 마지막 열차의 위치를 나타내는 길이 $m$의 경로 $P$와 $Q$가 주어진다. 경로의 길이는 경로에 포함된 간선의 개수이다. 여기서 두 경로 $P$와 $Q$는 어떠한 간선도 공유하지 않는다. 다시 말해서, $P$와 $Q$가 동시에 지나는 간선은 존재하지 않는다. 우리는 경로 $P$를 이동해서 마지막에 경로 $Q$가 되도록 해야 한다. 이때, 최소 단계의 이동을 찾아야 한다.$n$개 정점을 가진 트리 $T$와 초기와 마지막 열차를 나타내는 길이 $m$의 경로 $P$와 $Q$가 주어질 때, $P$를 $Q$로 이동할 수 있는지 검사하고 이동할 수 있다면 최소 단계수를 출력하는 프로그램을 작성하시오.예를 들어, 그림2에서 어떠한 간선도 공유하지 않는 길이 $2$의 두 경로 $P$와 $Q$가 주어진다. 그림에서와 같이 경로 $P$에서 $Q$로 5단계에 이동할 수 있고, 이것이 최소 단계의 이동이다.그림 2여러분은 관리자를 위해 다음 두 가지 함수를 구현해야만 한다.void init(int n, vector<int> X, vector<int> Y) ; 최초에 호출되며 단 한번 호출되는 함수이다. 트리의 정점의 개수는 n이고 정점은 $1$부터 n까지의 정수로 나타낸다. X 와 Y는 크기 n-1인 vector로 트리의 각 간선은 (X[i], Y[i])로 나타낸다.long long train(vector<int> Z) ; Z는 크기 $4$인 vector로 초기 경로 $P$의 두 끝점 Z[0]과 Z[1], 마지막 경로 $Q$의 두 끝점 Z[2]와 Z[3]를 나타낸다. $P$를 $Q$로 이동시키는 최소 단계수를 return한다. 만약, 이동할 수 없다면, $-1$을 return한다.",7,25014,1,25.0,"자료 구조,다이나믹 프로그래밍,트리에서의 다이나믹 프로그래밍,그리디 알고리즘,트리,","자료구조,자구,동적계획법,동적 계획법,다이나믹프로그래밍,트리dp,탐욕법,trees,"
/problem/25015,아이싱,"수많은 중고등학생들에게 아이싱이라는 온라인 일대일 대전 게임이 유행하고 있다. 게임회사에서는 이 게임을 확장하여 팀 I와 팀 Sing 사이에 대전을 할 수 있는 팀플레이 전용 아이싱II를 개발하였다. 아이싱II는 게이머들의 기존 아이싱에서의 대전 이력을 활용하여 독특한 방식으로 팀을 구성하도록 설계되었다. 즉, 아이싱에서 일대일 대전을 한 두 게이머는 서로 다른 팀에 속해야 한다. 각 팀의 인원수는 1명 이상이며 두 팀의 인원수는 서로 달라도 된다.예를 들어, 아래 표는 네 명의 게이머 A, B, C, D가 아이싱에서 일대일 대전을 한 기록을 이용하여 아이싱II의 팀을 구성한 예이다.<예시 1>그런데, 이제 3분 후면 아이싱II 서버 오픈인데 치명적인 문제가 발견되었다. 예를 들어, 게이머 A, B, C가 모두 서로 대전한 적이 있다면 각각 다른 팀에 들어가야 하므로 팀 I와 팀 Sing 구성이 불가능한 것이다.이 문제를 해결하기 위해 다음과 같은 해법을 적용하려 한다. 바로 아이싱 대전 기록 중 최소 개수의 대전 기록을 지우는 것이다. 예를 들어, 아래 그림과 같이 네 명의 게이머 A, B, C, D의 아이싱에서 일대일 대전 기록이 주어질 때(왼쪽)를 생각해 보자. 이 경우 최소 하나의 기록을 지워야 하며, 대전 기록 중 A – B를 지운다면(가운데) 두 팀 구성이 가능하다(오른쪽).<예시 2>다른 예로, 다음과 같은 아이싱 대전 기록을 생각해 보자. 이 경우 최소 두 개의 대전 기록을 지워야 하며, A – B와 C – D를 지운다면 아래와 같이 두 팀을 구성할 수 있다.<예시 3>하지만, 게임의 런칭이 3분 밖에 남지 않았기 때문에 지울 수 있는 기록의 개수는 최대 두 개로 한정된다. 만약에 3개 이상의 기록을 지워야 한다면 런칭을 지연하는 것이 더 좋을 수도 있다.이 와중에 게임회사 대표는 두 팀을 구성하기 위해 지울 수 있는 최소 크기의 대전 기록 집합이 얼마나 다양하게 존재하는지 궁금해졌다. 즉, 최소로 지워야 하는 대전 기록의 개수가 $K$일 때, 크기 $K$인 지울 수 있는 대전 기록의 부분집합의 경우의 수를 세어야 한다.<예시 2>에서는 {A – B}, {A - C}, 또는 {B – C}를 지우면 최소 개수의 대전 기록을 지우면서 두 팀을 구성할 수 있다. 이 경우의 답은 3이다. <예시 3>에서는 {A – B, C – D}, {A – C, B – D}, 또는 {A – D, B – C}를 지우면 최소 개수의 대전 기록을 지우면서 두 팀을 구성할 수 있다. 이 경우의 답은 3이다.여러분은 주어진 아이싱 대전 기록을 이용하여 두 팀을 구성할 수 있도록 지울 수 있는 최소 개수의 대전 기록을 선택하는 서로 다른 방법의 개수를 구하기 위해서 다음 함수를 구현해야만 한다. 이때 지울 대전 기록의 선택 순서는 중요하지 않다. 또한, 2개 이하의 대전 기록을 지워서 게임을 진행할 수 없다면, 0을 반환한다. 만약, 아무 기록도 지워야 할 필요가 없다면, 아무 것도 안 지우는 것이 가장 빠른 유일한 방법이니 방법의 개수는 1이다.long long count_ways( int N, vector<int> U, vector<int> V ) ; N은 게이머 수, U와 V는 크기 M인 vector로 U[i]와 V[i] 사이에 아이싱 대전 기록이 존재한다. 이를 이용하여 지울 최소 크기의 대전 기록을 선택하는 서로 다른 방법의 개수를 구하여 return한다. 단, 3개 이상의 기록을 지워야만 한다면 0을 return한다.",1,25015,1,26.0,"깊이 우선 탐색,그래프 이론,그래프 탐색,해싱,무작위화,","depth first,depthfirst,그래프이론,bfs,dfs,랜덤,"
/problem/25022,마법 구슬 찾기,"당신은 모양과 질량이 완전히 동일한 $k+1$개의 구슬을 갖고 있다. 이 중 $k$개의 구슬은 일반적인 구슬이고, 1개는 마법 구슬이다. 당신은 마법 구슬을 찾아 마법의 성에 들어가려고 한다.마법 구슬과 일반 구슬을 육안으로 구별할 수 있는 방법은 없지만, 마법 구슬을 찾아내는 데에 사용할 수 있는 $M$ ($M \ge 2$)개의 주머니가 있다. 주머니에는 $0$부터 $M-1$까지의 번호가 붙어 있다.주머니를 활용하여 마법 구슬을 찾을 수 있는 방법은 아래와 같다.갖고 있는 모든 구슬을 $M$개의 주머니에 나눠 담는다. 	어떤 주머니에도 넣지 않은 구슬이 있으면 안 된다.구슬을 담지 않은 빈 주머니는 있어도 된다.주머니 속에는 구슬만 담을 수 있으며, 다른 주머니를 담을 수는 없다.주문을 외운다.주문을 외운 직후:	마법 구슬이 들어 있지 않은 주머니 속의 구슬들은 모두 소멸된다.마법 구슬이 들어 있는 주머니 속의 구슬들은 마법 구슬의 보호를 받아서 소멸되지 않는다. 하지만, 주문으로 인한 부수 효과를 수습해야 하고, 이 과정에서 비용이 든다. 마법 구슬이 $i$번 주머니에 들어 있었고, $i$번 주머니에 구슬 $j$개가 들어 있었다면, $A[i] \times j + B[i]$원 ($A[i] \ge 0$, $B[i] \ge 1$)이 든다.마법 구슬은 절대로 소멸되지 않으므로, 위의 과정을 마법 구슬 1개만 남을 때까지 반복하면 마법 구슬을 찾을 수 있다.당신은 구슬들을 주머니에 나눠 담는 전략을 수립하여, 최악의 경우에 마법 구슬을 찾는 데에 드는 비용을 최소화하고자 한다. 즉, $k+1$개의 구슬 중 어떤 구슬이 마법 구슬이더라도 총 $w$원 이하를 들여 마법 구슬을 찾을 수 있는 최소한의 $w$를 찾고자 한다.$0$ 이상 $N-1$ 이하의 모든 $k$에 대해 이 문제를 해결하는 함수를 작성하라.","추가 제약 조건 없음
",25022,1,20.0,"자료 구조,다이나믹 프로그래밍,그리디 알고리즘,우선순위 큐,","자료구조,자구,동적계획법,동적 계획법,다이나믹프로그래밍,탐욕법,heap,힙,"
/problem/25023,보안 시스템,"KOI국의 기밀 시설은 좌표평면 상에서 왼쪽 아래 꼭짓점이 $(0,0)$, 오른쪽 위 꼭짓점이 $(N+1,N+1)$인 변들이 축에 평행한 정사각형으로 표현할 수 있다. 정사각형의 각 모서리는 기밀 시설들의 벽을 의미한다. 기밀 시설 내에는 $N$개의 레이저 센서가 있다. 레이저 센서에는 $0$부터 $N-1$까지의 번호가 붙어 있다. 기밀 시설의 침입자를 레이저 센서들을 통해 감지하는 보안 시스템을 설계하려고 한다.각각의 레이저 센서는 좌표평면 위의 점으로 나타낼 수 있다. 레이저 센서를 작동시킬 경우, 해당 위치에서 위쪽($+y$축 방향), 오른쪽($+x$축 방향), 아래쪽($-y$축 방향), 왼쪽($-x$축 방향) 중 하나의 방향으로 레이저 빛을 발사한다. 레이저 빛은 벽에 도달할 때까지 나아가므로, 레이저 빛의 경로는 레이저 센서가 있는 위치와 벽 위의 한 점을 잇는 선분으로 나타낼 수 있다.레이저 빛이 발사되는 방향에는 1부터 4까지의 번호가 붙어 있다. $1$은 위쪽 방향, $2$는 오른쪽 방향, $3$은 아래쪽 방향, $4$는 왼쪽 방향을 나타낸다. 아래 그림은 1번, 2번, 3번, 4번 방향으로 레이저 빛을 발사하는 레이저 센서들의 예시를 순서대로 나타낸 것이다. 검은색 점은 레이저 센서를, 빨간색 선분은 레이저 빛을 나타낸다.$i$ ($0 \le i \le N-1$)번 레이저 센서는 $(X[i], Y[i])$에 놓여 있고, 작동시킬 경우 빛을 $D[i]$번 방향으로 발사한다. 서로 다른 레이저 센서는 서로 다른 위치에 놓여 있다. $X[i]$와 $Y[i]$는 $1$ 이상 $N$ 이하의 정수이다.각각의 레이저 센서의 작동 여부를 원하는 대로 정할 수 있다. 단, 서로 다른 레이저 센서가 발사한 레이저 빛이 만나면 인식 오류가 발생할 수 있기 때문에, 레이저 빛들이 끝 점을 포함해서 서로 만나지 않도록 해야 한다. 아래 그림은 레이저 빛끼리 만나는 예시로, 레이저 빛끼리는 한 점에서 만날 수도 있고, 선분으로 만날 수도 있다.$i$ ($0 \le i \le N-1$)번 레이저 센서의 중요도는 $W[i]$이다. 중요도는, 해당 레이저 센서를 작동시켰을 때 보안에 얼마나 도움이 되는지를 수치적으로 나타낸 값이다. 전체 보안 시스템의 보안 수준은 작동시킨 레이저 센서들의 중요도 값의 합이다.레이저 빛끼리 서로 만나지 않도록 레이저 센서들의 작동 여부를 결정했을 때, 가능한 보안 수준의 최댓값을 구하는 함수를 작성하라.","추가 제약 조건 없음
",25023,1,28.0,"많은 조건 분기,자료 구조,다이나믹 프로그래밍,기하학,구현,느리게 갱신되는 세그먼트 트리,수학,세그먼트 트리,스위핑,","케이스,케이스워크,케이스 워크,자료구조,자구,동적계획법,동적 계획법,다이나믹프로그래밍,레이지,레이지프로퍼게이션,레이지프로파게이션,구간트리,fenwick,펜윅,구간트리,세그트리,fenwick,펜윅,라인 스위핑,"
/problem/25029,Joyful KMP,"최근 KMP(Knuth-Morris-Pratt)알고리즘을 배운 홍준이는 실패함수의 이해에 대해서 골몰하고 있다. 어떤 문자열 $S = s_1s_2\cdots s_N$에 대해, 이 문자열의 실패함수는 $N$개의 값 $f[1], f[2], \cdots , f[N]$으로 나타나며, $f[i]$는 $s_1s_2\cdots s_i$의 접두사가 되면서 동시에 접미사가 되는 길이 $i$미만의 문자열 중 가장 긴 것의 길이이다. 만약 그런 문자열이 없다면 $0$을 가진다. 예를 들어, $S = $""abcabd""의 실패함수는 다음과 같다.$i$$1$$2$$3$$4$$5$$6$$s_i$abcabd$f[i]$$0$$0$$0$$1$$2$$0$홍준이는 실패함수를 이해하기 위해서 어떤 문자열을 하나 놓고, 이 문자열과 같은 실패함수를 가지는 알파벳 소문자 만으로 이루어진 문자열을 모두 구해 사전 순으로 나열하려고 한다. 옆에서 지켜보던 당신은 홍준이를 도와 주어진 문자열과 같은 실패함수를 가지는 문자열의 개수와 그 중 사전 순으로 $K$번째인 문자열을 구해주는 프로그램을 작성하기로 했다.첫 번째 줄에는 입력으로 주어진 문자열과 같은 실패 함수를 가지는 알파벳 소문자 만으로 이루어진 문자열의 개수를 출력한다. 이 수는 매우 클 수 있으므로, $1\,000\,000\,007$로 나눈 나머지를 출력하도록 한다.",$0$,25029,1,23.0,"KMP,문자열,트리,","스트링,trees,"
/problem/25352,정령과 눈 감고 숨바꼭질 게임,"Semia와 9명의 친구들은 놀이터에서 눈을 감고 진행하는 숨바꼭질 게임을 하고 있다. 이 게임은 술래가 눈을 감고 놀이터 곳곳에 숨어있는 나머지 9명을 찾아내는 게임이다. 놀이터는 $200 \times 200$ 크기의 격자이다. 격자의 $i$행 $j$열을 $(i, j)$로 표기한다. $(0 \le i, j \le 199)$게임이 시작하기 전, 술래가 아닌 나머지 9명은 격자에서 한 칸을 골라 그 곳에 숨는다. 한 칸에 여러 사람이 숨을 수도 있다. 이후 술래는 코끼리 코를 돌아서 중앙의 $100 \times 100$ 크기 격자의 무작위 위치에서 다른 친구들을 찾기 시작한다. 이 때 코끼리 코를 매우 격렬하게 돌기 때문에, 술래는 자신이 시작하는 위치가 정확히 어디인지조차 알지 못한다. 하지만 술래의 시작 위치를 $(i_{0}, j_{0})$라고 하면 $50 \le i_{0}, j_{0} \le 149$임은 보장할 수 있다.나머지 9명의 위치를 $(i_{k}, j_{k})$ $(1 \le k \le 9)$ 라고 하자. 술래에게 너무 빨리 들키는 것을 방지하기 위해 모든 $1 \le k \le 9$에 대해 $\lvert i_{k} - i_{0} \rvert > 1, \lvert j_{k} - j_{0} \rvert > 1$ 를 만족할 때만 정상적으로 게임을 시작한다. 그렇지 않으면 게임을 다시 시작할 것이므로 무시해도 좋다.이번 게임에서는 Semia가 술래가 되었다. 게임을 이기고 싶은 Semia는 친구들을 찾기 전 남들 몰래 정령을 불러내서 정령의 도움을 받으려고 한다. 정령은 나머지 9명이 숨은 위치를 보고 놀이터의 모든 격자 칸에 양의 정수를 적어 표시해 놓으려고 한다. 안타깝게도 정령은 1부터 24까지의 수밖에 모르기 때문에 1 이상 24 이하의 정수만 표시해 놓을 수 있다. Semia는 정령이 표시해둔 수를 이용해 나머지 9명의 위치를 파악하려고 한다. Semia는 마나를 사용해 다음의 두 가지 능력을 사용할 수 있다. 안타깝게도 두 능력은 마나를 많이 소모하는 행동이라 각각 사용할 수 있는 횟수에 제한이 있다.Find x. 값 $x$가 표시된 격자들 중 유클리드 거리로 가장 가까운 격자가 어디 있는지, 현재 위치를 기준한 상대적인 좌표로 알 수 있다. 조건을 만족하는 격자의 위치가 $(u, v)$라면, Semia는 $(u - i_{0}, v - j_{0})$를 알 수 있는 것이다. 이 능력은 최대 한 번 사용할 수 있으며, 가장 가까운 격자가 여러 개인 경우 그 중 아무 한 점의 좌표만 알아낼 수 있다.Get x y. Semia 기준 상대 좌표가 $(x, y)$인 위치, 다시 말해 $(i_{0} + x, j_{0} + y)$에 정령이 표시한 값을 알 수 있다. 이 때 $|x| \leq 1, |y| \leq 1$이어야 한다. 이 능력은 최대 네 번까지 사용할 수 있다.Semia는 나머지 9명이 각각 자신을 원점으로 하는 사분면 중 어디에 속해있는지 구하려고 한다. 사분면은 아래와 같이 번호를 붙인다.$i - i_{0} > 0, j - j_{0} > 0$인 경우 $(i, j)$는 1사분면에 속한다.$i - i_{0} < 0, j - j_{0} > 0$인 경우 $(i, j)$는 2사분면에 속한다.$i - i_{0} < 0, j - j_{0} < 0$인 경우 $(i, j)$는 3사분면에 속한다.$i - i_{0} > 0, j - j_{0} < 0$인 경우 $(i, j)$는 4사분면에 속한다.$i - i_{0}, j - j_{0}$ 중 하나 이상이 $0$인 경우는 이 문제에서 고려할 필요가 없다.Semia와 정령을 도와 두 명의 전략을 구현해보자!함수 목록 및 정의Grader에서 기본으로 제공하는 함수는 다음과 같다. 여러분은 이 함수들을 적절히 호출하여 문제를 해결해야 한다.pair<int, int> Find(int x)값 $x$가 표시된 격자들 중 유클리드 거리로 가장 가까운 격자의 Semia 기준 상대 좌표를 반환하는 함수이다. 가장 가까운 격자가 여러 개 존재하면 그 중 무작위로 선택된 하나에 대한 값을 반환한다.정령이 칸에 표시해 놓은 값들 중 $x$가 존재해야 한다. 이를 만족하지 않은 경우, ""틀렸습니다""를 받는다.이 함수를 1번보다 많이 호출할 경우 ""틀렸습니다""를 받는다.int Get(int x, int y)Semia 기준 상대 좌표가 $(x, y)$인 위치에 표시된 값을 반환하는 함수이다.$|x| \leq 1, |y| \leq 1$ 을 만족하지 않는 경우 ""틀렸습니다""를 받는다.이 함수를 4번보다 많이 호출할 경우 ""틀렸습니다""를 받는다.여러분은 다음 두 함수를 구현해야 한다. vector< vector<int> > play_spirit(vector< pair<int, int> > &hider_positions)인자로 주어지는 배열 hider_positions의 크기는 9이다. $i$번째 원소는 $i$번째 숨은 사람의 좌표를 나타낸다. (단, $0 \leq i \leq 8$)이 함수는 $200 \times 200$ 크기의 2차원 배열을 반환해야 한다. $i$번째 배열의 $j$번째 원소는 정령이 $(i,j)$ 좌표에 표시할 값을 의미하며 이 값은 $1$ 이상 $24$ 이하여야 한다. vector<int> play_semia()이 함수는 Find 함수를 최대 1번, Get 함수를 최대 4번 호출할 수 있다.이 함수는 길이 9의 배열을 반환한다. 반환하는 배열의 $i$번째 값은 $i$번 사람이 숨어있는 사분면 번호이다.제출하는 소스 코드의 어느 부분에서도 입출력 함수를 실행해서는 안 된다. 각 테스트 케이스에 대해, 위의 함수를 호출하는 프로그램은 다음과 같이 정확히 두 번 실행된다.프로그램이 첫 번째로 실행될 때는 다음과 같다.play_spirit 함수가  호출된다.play_spirit 함수의 실행 결과가 채점 시스템에 저장된다.play_semia 함수는 호출되지 않는다.프로그램이 두 번째로 실행될 때는 다음과 같다.play_semia 함수가 호출된다. play_semia 함수가 호출하는 Find 함수와 Get 함수의 반환 값은 play_spirit의 앞선 실행 결과에 의존한다.play_spirit 함수는 호출되지 않는다.이 문제에서 프로그램의 실행 시간과 메모리 사용량은 두 번의 실행을 합하여 계산된다.Sample Grader Sample Grader는 두 번의 실행에서 다음과 같이 입출력을 수행한다. Sample grader를 포함한 파일은 providing.zip 에서 내려받을 수 있다.여러분의 코드를 sol_template.cpp에 작성한 후 로컬 환경에서 컴파일해볼 수 있다.첫 번째 실행에서는 다음과 같이 입력을 받는다.Line 1: Semia의 위치를 나타내는 두 정수Line 2-10: 친구들의 위치를 나타내는 두 정수첫 번째 실행의 출력이자, 두 번째 실행의 입력은 다음과 같다.Line 1-200: 정령이 각 격자칸에 적은 정수Line 201: Semia의 위치를 나타내는 두 정수두 번째 실행에서 Sample grader는 play_semia함수의 출력값을 한 줄에 공백으로 구분하여 출력한다.",22.222%,25352,1,19.0,"애드 혹,",
/problem/25398,트리와 집합과 쿼리,"N개의 정점으로 이루어진 트리가 있다.트리의 정점들 위에 돌들을 놓을 수 있는데, 한 정점에는 하나의 돌만 놓을 수 있다.또한 이 트리는 특이한 성질이 있어서, 두 인접한 정점에 돌을 모두 놓을 수 없다.트리의 정점들의 부분집합 A 와 B에 대해, A에 포함되는 정점에만 돌이 놓여있는 상태에서 시작하여 하나의 돌을 인접한 정점으로 옮기는 작업만을 반복하여 B에 포함되는 정점에만 돌이 놓여있는 상태를 만들 수 있다면 이 때 f(A,B) = 1, 그렇지 않은 경우  f(A,B) = 0으로 함수  f를 정의하자. 물론, 옮기는 중간 과정에서도 두 인접한 정점에 모두 돌이 있는 경우가 발생해서는 안된다.당신의 태스크는 여러 집합 쌍에 대해 f에 대한 함수값을 계산하는 것이다.처음에 두 집합 U, V 는 빈 집합으로 초기화된 상태이며,  U, V 에 정점 한 개씩을 추가하는 u v 꼴의 쿼리가 Q개 주어진다.이는 U에 정점 u를, V에 정점 v를 추가함을 뜻한다.쿼리가 주어질 때마다 그 쿼리를 처리한 후에 f(U,V)의 값을 계산한 후, 최종적으로 그 Q개의 값들의 합을 출력하시오.각 테스트 케이스마다 첫 줄에는 “Case #C”를 출력하여야 한다. 이때 C는 테스트 케이스의 번호이다.",60.000%,25398,1,29.0,0,
/problem/25426,일차함수들,"$f(x) = ax + b$형태의 일차함수가 $N$개 있다. $i$번째 함수는 $f_i(x) = {a_i}x + {b_i}$로 표현된다.이 함수들 각각의 $x$에 $1$부터 $N$까지의 서로 다른 정수 $N$개를 하나씩 대입하여 만들 수 있는 $f(x)$들의 합의 최댓값을 구해보자.구체적으로는, 길이 $N$의 순열 $x_1, x_2, ... x_N$을 적절히 정해 $\sum_{i=1}^N {a_i}{x_i}+{b_i}$의 값을 최대화하여라.첫째 줄에 문제의 답을 출력한다.","추가 제약 조건 없음
",25426,1,7.0,"그리디 알고리즘,수학,정렬,","탐욕법,"
/problem/25501,재귀의 귀재,"정휘는 후배들이 재귀 함수를 잘 다루는 재귀의 귀재인지 알아보기 위해 재귀 함수와 관련된 문제를 출제하기로 했다.팰린드롬이란, 앞에서부터 읽었을 때와 뒤에서부터 읽었을 때가 같은 문자열을 말한다. 팰린드롬의 예시로 AAA, ABBA, ABABA 등이 있고, 팰린드롬이 아닌 문자열의 예시로 ABCA, PALINDROME 등이 있다.어떤 문자열이 팰린드롬인지 판별하는 문제는 재귀 함수를 이용해 쉽게 해결할 수 있다. 아래 코드의 isPalindrome 함수는 주어진 문자열이 팰린드롬이면 1, 팰린드롬이 아니면 0을 반환하는 함수다.#include <stdio.h>#include <string.h>int recursion(const char *s, int l, int r){    if(l >= r) return 1;    else if(s[l] != s[r]) return 0;    else return recursion(s, l+1, r-1);}int isPalindrome(const char *s){    return recursion(s, 0, strlen(s)-1);}int main(){    printf(""ABBA: %d\n"", isPalindrome(""ABBA"")); // 1    printf(""ABC: %d\n"", isPalindrome(""ABC""));   // 0}정휘는 위에 작성된 isPalindrome 함수를 이용하여 어떤 문자열이 팰린드롬인지 여부를 판단하려고 한다.구체적으로는, 문자열 $S$를 isPalindrome 함수의 인자로 전달하여 팰린드롬 여부를 반환값으로 알아낼 것이다. 더불어 판별하는 과정에서 recursion 함수를 몇 번 호출하는지 셀 것이다.정휘를 따라 여러분도 함수의 반환값과 recursion 함수의 호출 횟수를 구해보자.각 테스트케이스마다, isPalindrome 함수의 반환값과 recursion 함수의 호출 횟수를 한 줄에 공백으로 구분하여 출력한다.",54.626%,25501,1,4.0,"구현,재귀,문자열,","스트링,"
/problem/25619,자취방 정하기,"새내기 현서는 이번 학기에도 고민이 많은데, 그중 가장 큰 고민은 아침 수업이 많아서 수업 시간에 맞춰 강의실을 도착하지 못할 것 같다는 것이다! 고민 끝에 현서는 학교 주변의 자취방을 하나 구하기로 결심했다.학교 주변은 정점이 N개, 간선이 M개인 그래프로 표현된다. 학교는 1번 정점에 있으며, 그 외의 정점에는 현서가 계약할 수 있는 자취방이 하나씩 있다. 간선은 학교와 자취방, 또는 자취방과 자취방 사이의 도로를 나타낸다. 도로는 양쪽 방향으로 모두 사용할 수 있다.각 도로는 교통량이라는 값을 가지며, 교통량이 x인 도로를 통과하는 데에는 양쪽 방향으로 동일하게 x분의 시간이 걸린다. 다양한 사건에 의해서 각 도로의 교통량은 매번 일정하지는 않는데, 구체적으로 i번 도로의 교통량은 절반의 확률로 ai이고, 나머지 절반의 확률로 bi가 된다. 교통량은 각 도로마다 독립적으로 정해지며, 현서가 길을 지날 때마다 바뀔 수 있다. ai 또는 bi가 음수일 수도 있는데, 이 경우에는 도로를 통과할 때 시간이 역행한다고 생각하면 된다.이 상황에서 현서는, 적당한 정해진 이동을 선택했을 때 학교에 도착했을 때 걸리는 시간의 기댓값이 T분 이하가 되도록 할 수 있는 위치의 자취방을 고려하려고 한다. 구체적으로는 아래와 같다.1번 정점을 제외한 모든 정점 i에 대해, Wi를 i번 정점에서 1번 정점으로의 모든 가능한 이동의 집합이라고 정의하자.	s에서 e로의 이동은 s에서 시작해서 연결된 간선들만을 따라 이동해 e에 도착하는 것이다.이동은 간선을 중복해서 사용하는 것도 허용하며, 도착 정점인 1번 정점에 도착했다고 해서 멈출 필요 역시 없다.모든 2 ≤ i ≤ n에 대해 함수 fi : Wi → ℝ을	fi(w) = (i번 정점에서 이동 w를 이용하여 1번 정점으로 갈 때 걸리는 분 단위 시간의 기댓값)	으로 정의하자. 이때 ℝ은 실수 전체의 집합이다.현서는 fi(w) ≤ T인 w ∈ Wi가 존재하는 정점만을 고려하려고 한다.현서를 위해 위 조건을 만족하는 자취방들을 모두 구해주자.첫째 줄에 조건을 만족하는 자취방의 개수 K를 출력한다. 조건을 만족하는 자취방이 없으면 0을 출력한다.",41.722%,25619,1,14.0,"데이크스트라,그래프 이론,기댓값의 선형성,수학,확률론,","다익,다익스트라,데이크스트라,그래프이론,expected value,기대값,기댓값,"
/problem/25927,Parity Constraint Maximum Flow,"flow network $(G, c, s, t)$는 다음과 같이 정의된다.$G$는 방향 그래프 $(V, E)$를 의미한다.$c : E \rightarrow \mathbb{R}^+$는 간선의 capacity를 나타내는 함수다.$s, t \in V$는 각각 source와 sink를 의미하고, $s \ne t$를 만족한다.주어진 flow network $(G, c, s, t)$에 대한 $s$-$t$ flow $f$는 다음과 같이 정의된다.모든 $e \in E$에 대해서 $0 \le f(e) \le c(e)$를 만족한다.모든 $v \in V-\{s, t\}$에 대해서 $\displaystyle \sum_{(u,v) \in E} f(u,v)= \sum_{(v,w) \in E} f(v,w)$를 만족해야 한다.이때, flow $f$의 값은 $\displaystyle |f| = \sum_{(s,v) \in E} f(s,v) - \sum_{(v,s) \in E} f(v,s) = \sum_{(v,t) \in E} f(v,t) - \sum_{(t,v) \in E} f(t,v)$로 정의된다.maximum flow는 주어진 flow network $(G, c, s, t)$에 대한 $s$-$t$ flow 중 값이 최대인 $s$-$t$ flow를 의미한다. 모든 $c(e)$가 정수라면, 모든 $f(e)$가 정수인 maximum flow $f$를 다항 시간에 구할 수 있음이 알려져 있다. 이에 대한 다항 시간 알고리즘의 예시로, 시간 복잡도 $O(VE^2)$의 Edmonds-Karp Algorithm과 시간 복잡도 $O(V^2 E)$의 Dinic's Algorithm이 있다.여기에 추가로 함수 $p : E \rightarrow \{ 0, 1 \}$이 주어진다. 이 때, 우리는 다음 조건을 만족하는 $s$-$t$ flow $f$를 parity constraint flow라고 할 것이다.모든 $e \in E$에 대해서 $f(e)$는 정수여야 한다.$f(e) \equiv p(e)$ $mod$ $2$parity constraint flow 중 값이 최대인 것을 parity constraint maximum flow라고 할 것이다.flow network $(G, c, s, t)$와 함수 $p$가 주어졌을 때, 이에 대한 parity constraint maximum flow를 구해보자.첫 번째 줄에는 parity constraint maximum flow $f$의 값을 출력한다. 만약에 parity constraint flow가 존재하지 않는다면 -1을 출력한다.","추가 제약 조건 없음.
",25927,1,23.0,"서큘레이션,최대 유량,","dinic,dinitz,ford,fulkerson,fordfulkerson,디닉,디니츠,포드풀커슨,플로우,"
/problem/25968,구분구적,"$y = a_1 x^{2n} + a_2 x^{2n-2} +a_3 x^{2n-4} + .... + a_{n+1} x^0$의 꼴의 함수가 주어진다. 당신은 이 함수의 그래프와 x축이 둘러싸고 있는 닫힌 영역의 넓이를 구분구적법으로 구하려 한다. 이 때, 다항식의 계수들은 실수이다. 또한 주어지는 함수와 x축으로 둘러싸인 닫힌 영역은 유일하고 반드시 존재하며, 모든 근의 절대값은 32를 넘지 않는다.구분구적법은 주어진 함수의 적분값의 근사값을 구하기 위한 방법이다. 어떤 함수 $f(x)$의 구간 $[a, b]$ $(a < b)$에서의 적분값의 근사값을 구간 $[a, b]$를 $k$ 개의 하위 구간 $[c, d]$ $(a \le c < d \le b)$으로 나눈 후 하위 구간 $[c, d]$ 안의 어떤 값 $e$의 함수값 $f(e)$를 높이로 두어 직사각형의 넓이 $(d-c) \times f(e)$의 합으로 계산한다.구간의 크기는 임의로 설정할 수 있으나, 일반적으로는 모든 구간의 크기를 동일하게 두는 것이 일반적이며, 이 문제에서도 그렇게 계산할 것이다. 또한 구간의 넓이를 계산할 때 높이를 구간의 중간값 $f \left(e=\frac{c+d}{2}\right)$으로 계산한다.동일한 크기의 $k$개 구간으로 나누어 구분구적법으로 계산한 넓이의 합을 구하라.",20.408%,25968,1,14.0,"이분 탐색,미적분학,수학,수치해석,","이분탐색,이진탐색,미분,적분,수학,"
/problem/26008,해시 해킹,"그린닷컴의 운영자 연두는 비밀번호를 평문 그대로 저장하는 과오를 뒤로하고, 이제부터 암호에 해시 함수를 적용해 저장하려고 한다. 연두가 아는 해시 함수라고는 알고리즘 문제 풀이에 많이 사용되는 롤링 해시 함수밖에 없기 때문에 이것을 응용하여 사용하기로 했다.그린닷컴의 비밀번호 규칙은 꽤 특이한데, 길이가 정확히 $N$이어야 하며, 비밀번호를 이루는 문자는 지정된 $M$개의 문자 중 하나여야 한다. 따라서, 사용 가능한 각 문자를 $0$부터 차례대로 정수에 대응시키면, 비밀번호를 길이가 $N$이고 모든 원소가 $0$ 이상 $M-1$ 이하인 배열 $P = [P_0, P_1, \dots, P_{N-1} ]$로 나타낼 수 있다.이렇게 비밀번호를 배열 $P$로 나타낸 후, 미리 정해진 정수 $A$를 이용하여 다음과 같은 해시 함수 $h$를 적용한다.$h(P) = (P_0 \cdot A^0 + P_1 \cdot A^1 + ... + P_{N-1} \cdot A^{N-1}) \mod M$예를 들어 배열 $P = [10, 30, 20], A = 7, M = 55$인 경우를 생각해보자. 이 경우 $h(P) = (10 \cdot 7^0 + 30 \cdot 7^1 + 20 \cdot 7^2) \mod 55 = (10 + 210 + 980) \mod 55 = 45$이다. 여기서 $\bmod$는 나머지 연산으로 $1200 = 21 \cdot 55 + 45$이므로 $1200 \mod 55 = 45$이다. 따라서 해시값은 항상 $0$ 이상 $M-1$ 이하의 정수이다.그린닷컴 관리자 계정의 비밀번호 해시값을 해킹한 재현이는, 이 해시값으로 실제 비밀번호가 뭐였는지 역추적해보려고 한다. 하지만 그린닷컴에서 사용 가능한 비밀번호는 $M^N$개나 있고, 이 중 과연 알아낸 해시값과 일치하는 비밀번호는 몇 개나 될지 궁금해졌다. 여러분이 이것을 대신 구해주자.주어진 해시값을 갖는 비밀번호의 개수를 출력한다. 출력하는 값이 너무 커질 수 있으므로, 이것을 $1\,000\,000\,007 ( = 10^9 + 7)$로 나눈 나머지를 출력한다.",55.977%,26008,1,12.0,"수학,정수론,",
/problem/26037,지수 · 로그와 테일러 다항식(Large),"어떤 함수 \(f(x)\) 의 (\(x=0\)에서의) \(n\)차 테일러 다항식이란,\[ T_n f(x) := \sum_{i=0}^{n} \frac{f^{(i)}(0)}{i!} x^i\]를 말한다.차수가 \(n\) 이하이고 상수항이 \(0\)인 다항식 \( P(x)\)가 \(a_0 + a_1x + \cdots + a_nx^n\)의 꼴로 주어진다. 두 함수 \(\ln(1+P(x)) \)와 \( e^{P(x)}-1 \)의 \(n\)차 테일러 다항식을 계산해 보자.첫째 줄에 함수 \(\ln(1+P(x))\)의 \(n\)차 테일러 다항식의 계수를 의미하는 \(n+1\)개의 정수를 오름차순으로 출력한다.",20.896%,26037,1,25.0,"고속 푸리에 변환,수학,","푸리에변환,컨볼루션,convolution,"
/problem/26038,지수 · 로그와 테일러 다항식(Small),"어떤 함수 \(f(x)\) 의 (\(x=0\)에서의) \(n\)차 테일러 다항식이란,\[ T_n f(x) := \sum_{i=0}^{n} \frac{f^{(i)}(0)}{i!} x^i\]를 말한다.차수가 \(n\) 이하이고 상수항이 \(0\)인 다항식 \( P(x)\)가 \(a_0 + a_1x + \cdots + a_nx^n\)의 꼴로 주어진다. 두 함수 \(\ln(1+P(x)) \)와 \( e^{P(x)}-1 \)의 \(n\)차 테일러 다항식을 계산해 보자.첫째 줄에 함수 \(\ln(1+P(x))\)의 \(n\)차 테일러 다항식의 계수를 의미하는 \(n+1\)개의 정수를 오름차순으로 출력한다.",55.172%,26038,1,18.0,"미적분학,다이나믹 프로그래밍,수학,","미분,적분,동적계획법,동적 계획법,다이나믹프로그래밍,"
/problem/26258,다중 일차 함수,"2차원 좌표 평면에 점 $N$개가 주어진다. $i$번째 점의 위치는 $(x_i, y_i)$이고, $1 \leq i \lt N$인 모든 $i$에 대하여 $x_i \lt x_{i+1}$을 만족하며, 점 $i$와 점 $i + 1$을 잇는 일차 함수가 그려진다. 각각 구간 $(x_1, x_2), (x_2, x_3), \cdots, (x_{N-1}, x_N)$에서 정의되는 $N-1$ 개의 일차 함수를 합쳐 $F(x)$라고 정의하자.예를 들어, 점이 $(0, 0)$,$(1,5)$,$(2,4)$,$(3,3)$,$(6,10)$으로 주어지면 그려지는 함수는 다음과 같다.질의마다 실수 $k$가 주어지면 $x=k$에서 함수 $F(x)$의 증가/감소 여부를 구하자.$k$가 속하는 일차 함수가 증가 함수면 $1$, 감소 함수면 $-1$, 둘 다 아니면 $0$을 각 줄마다 차례로 출력한다.",38.164%,26258,1,8.0,"이분 탐색,수학,","이분탐색,이진탐색,"
/problem/26517,연속인가? ?,"실수 $t$에 대하여, 함수 $f(x)$가 $x=t$에서 정의되어 있고, $\lim_{x \rightarrow t} f(x) = f(t)$인 경우 ""$f(x)$는 $x=t$에서 연속이다""라고 한다. 함수 $f(x) = \begin{cases}ax+b & (x \leq k)\\ cx+d & (x > k)\end{cases}$가 주어질 때, 이 함수가 $x=k$에서 연속인지 판별하자.$f(x)$가 $x=k$에서 연속이라면, Yes와 $f(k)$를 공백으로 구분하여 출력하고, 아니라면 No를 출력한다.",59.228%,26517,1,6.0,"미적분학,수학,","미분,적분,"
/problem/26519,함수와 최소 스패닝 트리,"$1$부터 $V$까지 번호가 붙은 정점이 $V$개, 간선이 $E$개인 단순 연결그래프가 주어진다.각 간선의 가중치는 시간 $t$에 따라 변화하는 이차함수 $at^2+b_it+c_i$ 꼴이다. 모든 간선에 대해 $a$는 동일하다.이때 함수 $f(t)$를 시간 $t$에서의 최소 스패닝 트리의 가중치의 합으로 정의하자. 정수 $t_1$, $t_2$가 주어지면 $\int_{t_1}^{t_2}f(t)dt$의 값을 구하시오.최소 스패닝 트리란, 주어진 그래프의 모든 정점들을 연결하는 부분 그래프 중에서 그 가중치의 합이 최소인 트리이다.$\int_{t_1}^{t_2}f(t)dt$의 값이 정수 $m$, 양의 정수 $n$에 대하여 기약분수 $\frac{m}{n}$일 때, $m\times n^{-1}\bmod (10^9+7)$을 출력한다. $n^{-1}$은 $n$의 모듈러 곱셈에 대한 역원이다.",13.846%,26519,1,18.0,"미적분학,그래프 이론,수학,모듈로 곱셈 역원,최소 스패닝 트리,정수론,정렬,","미분,적분,그래프이론,modinv,"
/problem/26520,다항함수의 적분과 쿼리,"길이가 $N + 1$인 수열 $A_0, A_1, A_2, \cdots, A_N$이 주어질 때, $N$개의 다항함수 $f_1(x), f_2(x), f_3(x), \cdots, f_N(x)$와 함수 $g(x)$가 다음 조건에 따라 정해진다.$N$ 이하인 모든 음이 아닌 정수 $n$에 대해서 $g(n) = A_n$이다.$N$ 이하인 모든 양의 정수 $n$에 대해서 $n - 1 \le x \le n$이면 $g(x) = f_n(x)$이다.$g(x)$는 구간 $(0, N)$에서 미분가능하다.$f_1(x), f_2(x), f_3(x), \cdots, f_N(x)$의 차수를 나열한 수열이 사전 순으로 가능한 한 앞에 위치하도록 한다.이때, 다음 쿼리를 수행하는 프로그램을 작성하시오. 1 i v : $A_i$를 $v$로 바꾼다. 2 a b : $6 \times \int_a^b g(x)dx$를 출력한다.각 2번 쿼리의 결과를 한 줄에 하나씩 순서대로 출력한다. 2번 쿼리의 결과가 항상 정수임을 증명할 수 있다.",48.718%,26520,1,20.0,"자료 구조,수학,세그먼트 트리,","자료구조,자구,구간트리,세그트리,fenwick,펜윅,"
/problem/26522,이차함수와 직선,"Azber과 Biou는 2차원 좌표평면에서 게임을 한다. Azber는 게임이 시작하기 전에 자신이 그릴 수 있는 $N$개의 이차함수를 가지고 있다. Azber가 가지고 있는 이차함수의 이차항 계수는 $1$ 아니면 $-1$이다.처음에 Azber는 자신이 가진 이차함수 중 몇 개를 좌표평면 위에 그린다.Biou가 모든 이차함수와 만나지 않는 직선을 그릴 수 있으면 Biou의 승리고, 어떠한 직선을 그려도 적어도 하나의 이차함수와 만나게 되면 Azber의 승리이다.Azber는 이길 수 있다면 최소 개수의 이차함수를 좌표평면에 그려서 게임을 이기고 싶다.Azber가 게임에 이길 수 있는지, 이길 수 있다면 좌표평면에 그려야 하는 최소 이차함수의 개수를 구하고 그 경우에 좌표평면에 그리는 이차함수를 구하시오.만약 Azber가 Biou를 이길 수 없다면 -1을 출력한다.",100.000%,26522,1,24.0,"미적분학,볼록 껍질을 이용한 최적화,구현,수학,스위핑,","미분,적분,컨벡스헐트릭,컨벡스헐최적화,라인 스위핑,"
/problem/26523,균등분포와 정규분포,"다음 중 하나의 방법으로 만들어진 크기 $n$의 표본이 주어졌을 때, 어느 방법으로 만들어졌는지 알아내시오.방법 A: 균등 분포 $U(0, 1)$에서 크기 $n$의 표본을 뽑는다.방법 B: 정규 분포 $N(0.5, 0.1)$에서 관측값 하나를 뽑고, 이 값이 $0$ 이상 $1$ 이하이면 표본에 넣는다. 이를 표본의 크기가 $n$이 될 때까지 반복한다. 이때, 0.1은 이 분포의 분산이다.다음은 두 분포의 확률밀도함수를 나타내는 그림이다.각 테스트케이스마다 한 줄에 하나씩, 표본이 방법 A로 만들어졌으면 A를, 방법 B로 만들어졌으면 B를 출력한다.",16.479%,26523,1,9.0,"애드 혹,수학,확률론,통계학,","expected value,기대값,기댓값,average,평균,variance,분산,표준편차,표준 편차,"
/problem/26528,이항분포에서 가장 큰 직사각형,"$B(n, p)$는 앞면이 나올 확률이 $p$인 동전을 $n$번 던질 때 앞면이 나오는 횟수에 대한 확률분포이다. 즉 확률변수 $X \sim B(n, p)$에 대해, $X = i$일 확률 $P(X = i)$는 동전을 던져서 앞면이 $i$번 나올 확률과 같다.이 확률변수 $X$의 확률질량함수로 길이 $n+1$의 히스토그램을 만들자. 막대는 왼쪽부터 차례대로 $0, \cdots, n$의 번호가 붙어 있고, 막대 $i$는 너비가 $1$이고 높이가 $P(X = i)$이다.히스토그램이 있으니 역시 히스토그램의 영역 안에 포함되는 가장 큰 직사각형의 넓이를 구해야 될 것 같다. 단, 직사각형의 한 변이 히스토그램의 밑변과 평행해야 한다.$[l, r]$로 표현되는 쿼리 $Q$개가 주어진다. 각 쿼리에 대해, 막대 $l$부터 $r$까지로만 이루어진 히스토그램에서 가장 큰 직사각형의 넓이를 구하시오.각 쿼리에 대해 가장 큰 직사각형의 넓이를 한 줄에 하나씩 출력한다. 절대/상대오차는 $10^{-6}$까지 허용한다.",46.667%,26528,1,20.0,"다이나믹 프로그래밍,수학,확률론,통계학,","동적계획법,동적 계획법,다이나믹프로그래밍,expected value,기대값,기댓값,average,평균,variance,분산,표준편차,표준 편차,"
/problem/26657,진단 0 : 1,"$2$ 이상의 양의 정수 $m$에 대해서, 음이 아닌 정수 집합을 정의역으로 갖는 함수 $f_{m}$을 다음과 같이 정의한다.$$f_{m}(x) = \begin{cases} 0 & (x = 0) \\ f_{m}{\left(\dfrac{x}{m}\right)} & (x \equiv 0 \pmod {m}) \\ f_{m}{\left(\left\lfloor\dfrac{x}{m}\right\rfloor\right)} + 1 & (x \not\equiv 0 \pmod {m}) \end{cases}$$양의 정수 $a$, $b$, $m$, $n$이 주어질 때, $a \le k \le b$에서 $f_{m}(k) = n$인 정수 $k$의 개수를 구하여라.$T$개의 줄에 걸쳐, 각각의 $a$, $b$, $m$, $n$에 대해 $a \le k \le b$에서 $f_{m}(k) = n$인 정수 $k$의 개수를 출력한다.",33.333%,26657,1,18.0,"조합론,다이나믹 프로그래밍,수학,","combination,permutation,probability,확률,순열,동적계획법,동적 계획법,다이나믹프로그래밍,"
/problem/27506,함수열과 쿼리,"함수열이란 함수들의 열로 $\{f_i\}_{i\in\mathbb{N}}$의 형태로 정의되며, 나열하면 $f_1, f_2, f_3,...$ 과 같이 표현됩니다.함수의 합성 ""$\circ$""는 $(f\circ g)(x) = f(g(x))$의 식으로 정의됩니다. 이것도 마찬가지로 여러 개로 이어지면, $$(f_1\circ f_2 \circ f_3)(x) = (f_1 \circ f_2)(f_3(x)) = f_1(f_2(f_3(x))$$ 이렇게 표현됩니다.예를 들어 $f_1(3) = 2, f_2(1) = 3, f_3(2) = 1$  이라면 $$(f_1\circ f_2 \circ f_3)(2) = f_1(f_2(f_3(2)) = f_1(f_2(1)) = f_1(3) = 2$$와 같이 계산할 수 있습니다.문제에서는 다음 조건을 만족하는 함수 $n$개가 차례대로 주어집니다. $1 \le x \le 5$ 를 만족하는 자연수 $x$에 대해 $f(x)$는 자연수이고, $1 \le f(x) \le 5$ 입니다. $x \ne y$ 이면 $f(x) \ne f(y)$ 입니다.즉, $1$ 부터 $5$ 까지로 이루어진 순열이 $n$개 주어집니다.이어서 다음과 같은 쿼리가 주어집니다.$u$ $a$ $b$ $y_1$ $y_2$ $y_3$ $y_4$ $y_5$각 쿼리에서 $a$와 $b$는 $a \le u \le b$를 만족하게 주어지며, $g = (f_a\circ f_{a+1}\circ f_{a+2}\circ ... \circ f_{b})$인 $g$가 $1 \le i \le 5$ 인 $i$에 대해 $g(i) = y_i$가 되도록 $f_u$를 변경했음을 의미합니다.각각의 쿼리마다 $f_u$가 어떤 함수로 변했는지 구합니다.단, 쿼리에 의해 변한 $f_u$는 그대로 유지됩니다. 즉, 쿼리가 누적됩니다.각 쿼리마다 $f_u(1)$, $f_u(2)$, $f_u(3)$, $f_u(4)$, $f_u(5)$가 어떤 값으로 변했는지 차례대로 공백으로 구분하여 출력합니다. 경우에 따라서는 $f_u$가 변하지 않았을 때에 쿼리를 만족할 수 있습니다. 만약 $f_u$가 변경되지 않았어도 같은 형식으로 출력합니다.",50.820%,27506,1,18.0,"자료 구조,수학,세그먼트 트리,","자료구조,자구,구간트리,세그트리,fenwick,펜윅,"
/problem/27519,소수의 합,"소수 (Prime Number)란 $1$이 아니면서, $1$과 자기 자신 이외에 약수가 존재하지 않는 양의 정수를 의미합니다. 예를 들어, $2$, $3$, $5$, $7$ 등이 소수에 해당합니다. 함수 $f(n)$을 ""$n$을 $0$개 이상의 소수의 합으로 표현하는 경우의 수""로 정의합시다. 이 때, 소수의 종류는 중복해서 사용할 수 있으며, 종류가 같고 순서만 다른 경우는 같은 경우로 봅니다. 예를 들어, $5$는 $2+3$ 또는 $5$로 나타낼 수 있으며, 다른 방법은 존재하지 않습니다. 따라서 $f(5)$는 $2$입니다.정수 $n$이 주어질 때, $f(n)$의 값을 구하여 출력하세요. 단, 정답이 커질 수 있으니 정답을 $1 \, 000 \, 000 \, 007$로 나눈 나머지를 출력하세요.각 테스트 케이스에 대해 정답을 각각 한 줄에 출력하세요. 단, 정답이 커질 수 있으니 정답을 $1\,000\,000\,007$로 나눈 나머지를 출력하세요.",50.307%,27519,1,14.0,"다이나믹 프로그래밍,수학,정수론,소수 판정,에라토스테네스의 체,","동적계획법,동적 계획법,다이나믹프로그래밍,소수,소수판별,소수판정,prime,sieve,에라체,소수,prime,"
/problem/27900,4차 산업 혁명 2,"《Connect Four》는 $6$행 $7$열의 수직으로 세워진 직사각형 게임판에서 진행하는 게임입니다. 두 플레이어가 번갈아가며 턴을 진행하며, 각 턴에 플레이어는 아직 채워지지 않은 칸이 있는 열을 하나 골라 자신의 말을 떨어뜨립니다. 떨어뜨린 말은 채워지지 않은 가장 아래쪽 칸에 들어갑니다. 먼저 자신의 말 네 개를 가로, 세로, 또는 대각선으로 한 줄을 이루도록 하는 플레이어가 승리합니다. 편의상 먼저 말을 놓는 플레이어의 말을 빨간색, 상대편의 말을 노란색이라 하겠습니다. 또한 열 번호는 가장 왼쪽에 있는 열에서 시작하여 오른쪽으로 가면서 $1$번부터 $7$번까지 붙입니다.여러분은 현존하는 최강의 Connect Four 인공지능을 상대로 승리해야 합니다. 여러분이 먼저 플레이합니다.최선의 수는 다음과 같이 (게임 상태에 대해 재귀적으로) 정의합니다.이길 수 있다면, 두 플레이어가 최선의 수를 둘 때 내가 이기면서 말을 최대한 적게 놓게 되는 수가 최선의 수입니다.이길 수는 없지만 비길 수 있다면, 두 플레이어가 최선의 수를 둘 때 비기는 수가 최선의 수입니다.이길 수도 없고 비길 수도 없다면, 두 플레이어가 최선의 수를 둘 때 (내가 지면서) 말을 최대한 많이 놓게 되는 수가 최선의 수입니다.이 문제에서는 게임판을 길이가 $14$인 문자열로 인코딩합니다. 먼저 각 열을 다음과 같이 인코딩합니다.$x = 1$로 초기화합니다.놓여있는 말을 위에서부터 하나씩 읽습니다. 빨간색 말이라면 $2x$가, 노란색 말이라면 $2x+1$이 새로운 $x$가 됩니다.모두 읽은 다음 $x$의 값을 $16$진수로 씁니다. 한 자리 수인 경우 앞에 $0$을 붙입니다. (ex. $x=13$이면 0d, $x=127$이면 7f)간단하게 설명하자면, 열을 위에서부터 순서대로 읽고, 노란색 말을 $1$, 빨간색 말을 $0$으로 치환한 다음, 맨 왼쪽에 $1$을 추가한 이진수를 $16$진수로 쓰면 됩니다.다음으로 게임판의 $1$열부터 $7$열까지를 인코딩한 문자열을 순서대로 이어 붙여 하나의 문자열을 만듭니다. 이 문자열이 게임판의 상태를 인코딩한 결과입니다. 아래는 인코딩한 결과가 각각 01010102010101, 0305146a032501, 55656a6a2c5555인 게임판을 나타낸 그림입니다.플레이어의 플레이는 말을 떨어뜨릴 열의 번호로 나타낼 수 있습니다. 예를 들어 $4$, $5$, $3$, $2$, $4$, $4$, $1$, $7$ 순서로 플레이한 뒤의 게임판은 다음과 같으며, 이 게임판을 인코딩한 문자열은 0203020c030103입니다.여러분은 아래 함수들을 구현해야 합니다.void init()이 함수는 단 한 번, 다른 모든 next_move() 함수가 호출되기 전에 호출됩니다.int next_move(std::string state)state: 위에서 설명한 방법대로 현재 판의 상태가 인코딩된 문자열이 함수는 판의 상태에 따라 다음 플레이, 즉 말을 떨어뜨릴 열을 반환해야 합니다. 열 번호는 $1$부터 시작합니다.이 함수의 반환값은 $0$ 이상 $7$ 이하여야 합니다.반환값이 $0$인 경우, 해당 상태에서는 게임을 더 이상 진행하지 않고 패배합니다.이 함수는 테스트 케이스당 최대 $21$번 호출됩니다.이 문제에는 $10$개의 테스트 케이스가 있습니다. 각 테스트 케이스마다 여러분은 항상 최선의 수 중 하나를 두는 인공지능과 대결합니다. 채점기는 다음과 같이 동작합니다.처음 게임판을 인코딩한 문자열인 ""01010101010101""을 next_move() 함수의 state 인자로 넘겨줍니다.next_move() 함수의 반환값을 확인합니다. 만약 반환값이 state에 대한 최선의 수가 아니거나 $0$이라면 게임을 더 이상 진행하지 않습니다. 그렇지 않다면 반환값과 state를 바탕으로 새로운 게임판을 만듭니다.만약 새로운 게임판에서 당신의 말 네 개가 가로, 세로, 또는 대각선으로 한 줄을 이루고 있다면 당신의 승리로 프로그램을 종료합니다. 그렇지 않다면 그 상태에서 인공지능이 최선의 수를 둔 후의 게임판을 인코딩한 문자열을 다시 next_move() 함수의 state 인자로 넘겨줍니다.하나의 테스트 케이스에서 채점기는 항상 정해진 대로 동작합니다. 다시 말해서, 3번 과정에서 만약 최선의 수가 여러 개일 때 인공지능이 선택하는 최선의 수는, 해당 테스트 케이스의 채점 과정에서 도달할 수 있는 모든 게임판에 대해 정해져 있습니다. 인공지능의 선택은 각 테스트 케이스마다 다를 수 있습니다.각 테스트 케이스마다, 만약 당신이 게임을 이겼다면 $2790$점을 받습니다. 그렇지 않고 만약 당신의 next_move() 함수가 $0$ 이상 $7$ 이하의 정수가 아닌 값을 반환했다면 $0$점을 받습니다. 그렇지 않다면 당신의 next_move() 함수가 최선의 수를 반환한 횟수를 $n$이라 할 때, 이 테스트 케이스에 대한 여러분의 점수는 다음 표와 같습니다.조건점수$n = 0$$0$$1 \le n \le 9$$2^{n-1}$$n = 10$$343$$n = 11$$486$$n = 12$$512$$n = 13$$666$$n = 14$$1024$$n = 15$$1248$$n = 16$$1557$$n = 17$$1717$$n = 18$$2023$$n = 19$$2320$$n = 20$$2780$모든 테스트 케이스에서 채점 프로그램이 시간 내에 정상적으로 종료했을 경우에 한해, 각 테스트 케이스의 점수의 합이 여러분의 점수가 됩니다. 예를 들어, 모든 테스트 케이스에서 $n = 3$인 경우 $40$점을 받습니다.Sample grader는 인터랙티브하게 동작합니다. Sample grader의 동작을 위해서는 당신의 next_move() 함수의 반환값이 최선의 수인지 판단하고, 인공지능이 선택할 최선의 수를 직접 입력해야 합니다.만약 next_move() 함수의 반환값대로 게임을 진행했을 때 게임이 끝났다면 $0$을 입력해야 합니다.만약 next_move() 함수의 반환값이 최선의 수가 아니라면 $-1$을 입력해야 합니다.이외의 경우 인공지능이 선택할 최선의 수를 입력해야 합니다.다음은 Sample grader의 동작 예시입니다. next_move() 함수input이전 state새로운 statecallreturnnext_move(""01010101010101"")4 ""01010101010101""""01010102010101""  4""01010102010101""""01010106010101""next_move(""01010106010101"")3 ""01010106010101""""01010206010101""  -1최선의 수가 아니라고 판단, 게임 종료next_move() 함수가 최선의 수를 반환한 횟수: $1$, 점수: $1$Sample grader는 실제 채점에서 사용하는 그레이더와 다를 수 있습니다. 또한, 위 예시의 input은 실제 인공지능의 최선의 수가 아닐 수 있습니다.sample_grader.cpp","next_move() 함수가 최선의 수를 반환한 횟수: $1$, 점수: $1$",27900,1,0.0,0,
/problem/28409,산 색칠,"히스토그램 모양의 도화지에 산 색칠을 반복하여 히스토그램 모양의 그림을 그리려고 한다.히스토그램은 밑변이 $x$축에 평행한 한 개 이상의 직사각형이 공통된 밑변을 가지면서 빈틈없이 좌우로 붙어있는 도형을 말한다. 각 직사각형의 너비와 높이는 정수이며 서로 다를 수 있다.한 번의 산 색칠은 다음과 같이 이루어진다.도화지의 윗변 중 한 곳을 산의 정상으로 잡는다.그에 맞는 산 모양 중 넓이가 최대인 모양으로 색칠한다.산은 도화지를 벗어날 수 없으며, 이전의 색칠은 현재 색칠에 영향을 주지 않는다. 또한 직사각형의 왼쪽이나 오른쪽 끝은 산의 정상이 될 수 없다.산의 구체적인 정의는 다음과 같다.산의 정상이 가장 높은 히스토그램 모양이다.산의 정상을 포함하는 왼쪽 부분은 높이가 단조 증가한다.산의 정상을 포함하는 오른쪽 부분은 높이가 단조 감소한다.단, 함수 $f$가 $x_1<x_2$인 모든 $x_1,x_2$에 대하여 $f(x_1)\le f(x_2)$을 만족하면 단조 증가한다고 하고, $f(x_1)\ge f(x_2)$을 만족하면 단조 감소한다고 한다.산 색칠을 반복하여 주어진 그림을 그릴 수 있다면 최소한의 색칠 횟수로 그리고, 불가능하다면 -1을 출력하시오.첫 번째 줄에 필요한 산 색칠의 최소 횟수를 출력한다. 만일 그림을 완성할 수 없다면 -1을 출력하고 종료한다.",(b) 예제 2의 도화지와 그림,28409,1,16.0,"구현,스위핑,","라인 스위핑,"
/problem/28418,회장님께 바치는 합성함수,"우리의 회장님은 성격이 괴팍하다. 그의 마음에 들면 ""Nice"", ""Go ahead""이라고 말하지만, 그의 마음에 들지 않으면 ""Remember my character"", 그의 선을 넘으면 가차 없이 ""Head on""이라는 핍박을 듣게 된다. 그의 요구는 두 다항함수 $f(x)$와 $g(x)$를 이용하여 합성 함수를 만드는 것이다.$p(x) = f(g(x))$이고 $q(x) = g(f(x))$이다. 이때 $f(x)$의 최고차항은 2 이하이고 $g(x)$의 최고차항은 1 이하이다. 회장님은 이 두 함수 $y=p(x)$와 $y=q(x)$가 만나는 지점이 무한개인지, 2개인지, 1개인지, 0개인지에 따라 다음과 같이 말한다.무한개: ""Nice""2개: ""Go ahead""1개: ""Remember my character""0개: ""Head on""두 함수 $y=p(x)$와 $y=q(x)$가 만나는 지점의 개수는 $p(x)-q(x)=0$을 통해 $x$축과 만나는 점의 개수를 파악하여 알 수 있다.두 함수가 닿는 점의 개수에 따라 ""Nice"", ""Go ahead"", ""Remember my character"", ""Head on"" 중 하나를 출력한다.",49.246%,28418,1,8.0,"많은 조건 분기,구현,수학,","케이스,케이스워크,케이스 워크,"
/problem/28692,선형 회귀는 너무 쉬워 2,"유림이는 선형 회귀에 자신이 있다. 그래서 MatKor 동아리에서 선형 회귀에 관한 수업을 할 때 집중하지 않았다. 당시 강사였던 동우는 이를 못마땅하게 여겨 유림이에게 다른 문제 선형 회귀는 너무 쉬워 1을 내주었고, 유림이는 문제를 쉽게 풀었다.동우는 이제 기존의 선형 회귀 문제를 내주었다. 데이터 $(x_1, y_1), (x_2, y_2), \cdots , (x_n, y_n)$이 주어졌을 때, 이를 가장 잘 설명하는 일차함수 $y=ax+b$를 찾는 문제이다. 여기서 주어진 점들 $(x_i, y_i)$에 대해 $x_i$를 통해 얻는 추정치 $\hat{y_i} = ax_i+b$로 정의하고, 실제 $y_i$에서 예측치인 $\hat{y_i}$를 뺀 값 $y_i-\hat{y_i}$를 잔차 $\epsilon_i$로 정의한다.선형 회귀 문제는 이 잔차 제곱의 합이 $0$에 가장 가깝도록, 즉 $\displaystyle\sum_{i=1}^n \epsilon_i^2 = \displaystyle\sum_{i=1}^n (y_i-ax_i-b)^2$이 최소가 되도록 하는 실수 $a$와 $b$를 찾는 문제이다. 이 값이 최소가 되도록 하는 $a$와 $b$를 $a_2$, $b_2$라고 한다. 여기서 $\displaystyle\sum_{i=1}^n \epsilon_i^2$은 $\epsilon_1^2+\epsilon_2^2+\cdots+\epsilon_n^2$를, $\displaystyle\sum_{i=1}^n (y_i-ax_i-b)^2$은 $(y_1-ax_1-b)^2+(y_2-ax_2-b)^2+\cdots+(y_n-ax_n-b)^2$를 나타낸다.동우는 유림이에게 주어진 점들에 대해 잔차 제곱의 합이 최소가 되도록 하는 실수 $a_2$와 $b_2$를 구해보라는 문제를 내주었다.그러나 유림이는 이미 답을 알고 있고, 바로 코딩하기로 했다. 답은 다음과 같다.먼저 $x_i$의 합을 $S_x$, $y_i$의 합을 $S_y$, $x_i^2$의 합을 $S_{xx}$, $x_iy_i$의 합을 $S_{xy}$라 하고, 이를 구하자. 그렇다면 $a_2$와 $b_2$는 경우에 따라 다음과 같다.	만약 $S_x^2\ne nS_{xx}$라면 아래와 같이 답을 구할 수 있다. \[\begin{align*}a_2&=\frac{nS_{xy}-S_xS_y}{nS_{xx}-S_x^2}\\ b_2&=\frac{S_y-a_2S_x}{n}\end{align*}\]		계산 중 분자와 분모에 대해 $2\times 10^{18}$의 큰 수가 등장할 수 있음에 유의해 적절한 자료형을 사용하도록 하자.만약 $S_x^2=nS_{xx}$이라면 가능한 $a_2$와 $b_2$ 쌍이 유일하지 않고 여러 개 존재한다.위의 결과에 대한 구체적인 증명 과정은 아래 노트에 있으므로, 관심이 있다면 나중에 읽어보자.첫 번째 줄에 $\displaystyle\sum_{i=1}^n (a_2x_i+b_2-y_i)^2$의 값이 $0$에 가장 가깝도록 하는 $a_2$와 $b_2$가 유일하게 존재한다면, 이를 공백으로 구분하여 출력한다",62.733%,28692,1,6.0,"구현,수학,",
